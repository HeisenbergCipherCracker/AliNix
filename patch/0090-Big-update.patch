From 9514208ab675b6c8fd05528e8e00a1295786c857 Mon Sep 17 00:00:00 2001
From: Heisenberg <alimirmohammad.1386@gmail.com>
Date: Mon, 1 Apr 2024 18:53:07 -0400
Subject: [PATCH 090/493] Big update

---
 lib/include/api.h                          |  18 +
 lib/include/bitreader.h                    |  72 +++
 lib/include/convert.h                      |  21 +
 lib/include/datetime.h                     |  29 +
 lib/include/gui/canvas.h                   |  42 ++
 lib/include/gui/colors.h                   |  46 ++
 lib/include/gui/context.h                  |  94 +++
 lib/include/gui/contextheap.h              |  23 +
 lib/include/gui/contextinfo.h              | 113 ++++
 lib/include/gui/directgui.h                |  35 ++
 lib/include/gui/events.h                   | 187 ++++++
 lib/include/gui/fonts/font.h               |  19 +
 lib/include/gui/fonts/fontparser.h         |  27 +
 lib/include/gui/gui.h                      | 117 ++++
 lib/include/gui/property.h                 |  77 +++
 lib/include/gui/rect.h                     |  80 +++
 lib/include/gui/widgets/button.h           |  55 ++
 lib/include/gui/widgets/control.h          | 153 +++++
 lib/include/gui/widgets/label.h            |  25 +
 lib/include/gui/widgets/listview.h         |  50 ++
 lib/include/gui/widgets/scrollbar.h        |  67 ++
 lib/include/gui/widgets/scrollbox.h        |  22 +
 lib/include/gui/widgets/slider.h           |  46 ++
 lib/include/gui/widgets/window.h           |  93 +++
 lib/include/heap.h                         |  47 ++
 lib/include/imaging/bmpformat.h            |  48 ++
 lib/include/imaging/image.h                |  62 ++
 lib/include/imaging/jpeg_decoder.h         | 678 +++++++++++++++++++++
 lib/include/imaging/pngformat.h            | 146 +++++
 lib/include/ipc.h                          |  50 ++
 lib/include/list.h                         | 204 +++++++
 lib/include/listing.h                      |  10 +
 lib/include/log.h                          |  23 +
 lib/include/math.h                         |  53 ++
 lib/include/new.h                          |  48 ++
 lib/include/proc.h                         |  99 +++
 lib/include/random.h                       |  17 +
 lib/include/shared.h                       | 105 ++++
 lib/include/string.h                       |  27 +
 lib/include/syscall.h                      | 113 ++++
 lib/include/systeminfo.h                   |  85 +++
 lib/include/time.h                         |  22 +
 lib/include/types.h                        |  32 +
 lib/include/vector.h                       |  90 +++
 lib/include/vfs.h                          |  35 ++
 lib/makefile                               |  50 ++
 lib/src/api.cpp                            |  15 +
 lib/src/convert.cpp                        | 115 ++++
 lib/src/crt/crt0.asm                       |  10 +
 lib/src/datetime.cpp                       |  68 +++
 lib/src/gui/canvas.cpp                     | 357 +++++++++++
 lib/src/gui/colors.cpp                     |  32 +
 lib/src/gui/context.cpp                    | 160 +++++
 lib/src/gui/contextheap.cpp                | 111 ++++
 lib/src/gui/directgui.cpp                  | 116 ++++
 lib/src/gui/fonts/font.cpp                 |  52 ++
 lib/src/gui/fonts/fontparser.cpp           |  41 ++
 lib/src/gui/gui.cpp                        | 230 +++++++
 lib/src/gui/property.cpp                   |   9 +
 lib/src/gui/rect.cpp                       | 210 +++++++
 lib/src/gui/widgets/button.cpp             |  51 ++
 lib/src/gui/widgets/control.cpp            | 204 +++++++
 lib/src/gui/widgets/label.cpp              |  18 +
 lib/src/gui/widgets/scrollbar.cpp          |  47 ++
 lib/src/gui/widgets/slider.cpp             |  58 ++
 lib/src/gui/widgets/window.cpp             | 135 ++++
 lib/src/heap.cpp                           | 152 +++++
 lib/src/imaging/bmpformat.cpp              |  75 +++
 lib/src/imaging/image.cpp                  | 244 ++++++++
 lib/src/imaging/pngformat.cpp              | 575 +++++++++++++++++
 lib/src/ipc.cpp                            |  41 ++
 lib/src/log.cpp                            | 131 ++++
 lib/src/main.cpp                           | 105 ++++
 lib/src/math.cpp                           | 136 +++++
 lib/src/proc.cpp                           |  72 +++
 lib/src/random.cpp                         |  21 +
 lib/src/string.cpp                         | 166 +++++
 lib/src/syscall.cpp                        |  21 +
 lib/src/systeminfo.cpp                     | 142 +++++
 lib/src/time.cpp                           |  17 +
 lib/src/vfs.cpp                            |  58 ++
 {lib => libz}/abi/arm/call.c               |   0
 {lib => libz}/abi/arm/crt0.s               |   0
 {lib => libz}/abi/arm/qrules.mk            |   0
 {lib => libz}/abi/arm/rules.mk             |   0
 {lib => libz}/abi/call.c                   |   0
 {lib => libz}/abi/call.h                   |   0
 {lib => libz}/abi/channel.c                |   0
 {lib => libz}/abi/channel.h                |   0
 {lib => libz}/abi/crt0.c                   |   0
 {lib => libz}/abi/crt0.h                   |   0
 {lib => libz}/abi/job.c                    |   0
 {lib => libz}/abi/job.h                    |   0
 {lib => libz}/abi/option.c                 |   0
 {lib => libz}/abi/option.h                 |   0
 {lib => libz}/abi/riscv/call.c             |   0
 {lib => libz}/abi/riscv/crt0.s             |   0
 {lib => libz}/abi/riscv/qrules.mk          |   0
 {lib => libz}/abi/riscv/rules.mk           |   0
 {lib => libz}/abi/rules.mk                 |   0
 {lib => libz}/abi/x86/call.s               |   0
 {lib => libz}/abi/x86/crt0.s               |   0
 {lib => libz}/abi/x86/qcall.s              |   0
 {lib => libz}/abi/x86/qrules.mk            |   0
 {lib => libz}/abi/x86/rules.mk             |   0
 {lib => libz}/fudge/arm/__aeabi_idiv.c     |   0
 {lib => libz}/fudge/arm/__aeabi_idivmod.s  |   0
 {lib => libz}/fudge/arm/__aeabi_uidiv.c    |   0
 {lib => libz}/fudge/arm/__aeabi_uidivmod.s |   0
 {lib => libz}/fudge/arm/__clzsi2.c         |   0
 {lib => libz}/fudge/arm/__divsi3.c         |   0
 {lib => libz}/fudge/arm/__modsi3.c         |   0
 {lib => libz}/fudge/arm/__udivmodsi4.c     |   0
 {lib => libz}/fudge/arm/__udivsi3.c        |   0
 {lib => libz}/fudge/arm/__umodsi3.c        |   0
 {lib => libz}/fudge/arm/atomic.c           |   0
 {lib => libz}/fudge/arm/rules.mk           |   0
 {lib => libz}/fudge/atomic.h               |   0
 {lib => libz}/fudge/base64.c               |   0
 {lib => libz}/fudge/base64.h               |   0
 {lib => libz}/fudge/buffer.c               |   0
 {lib => libz}/fudge/buffer.h               |   0
 {lib => libz}/fudge/cpio.c                 |   0
 {lib => libz}/fudge/cpio.h                 |   0
 {lib => libz}/fudge/cstring.c              |   0
 {lib => libz}/fudge/cstring.h              |   0
 {lib => libz}/fudge/ctrl.h                 |   0
 {lib => libz}/fudge/elf.c                  |   0
 {lib => libz}/fudge/elf.h                  |   0
 {lib => libz}/fudge/event.h                |   0
 {lib => libz}/fudge/file.h                 |   0
 {lib => libz}/fudge/keys.c                 |   0
 {lib => libz}/fudge/keys.h                 |   0
 {lib => libz}/fudge/list.c                 |   0
 {lib => libz}/fudge/list.h                 |   0
 {lib => libz}/fudge/message.c              |   0
 {lib => libz}/fudge/message.h              |   0
 {lib => libz}/fudge/mtwist.c               |   0
 {lib => libz}/fudge/mtwist.h               |   0
 {lib => libz}/fudge/p9p.c                  |   0
 {lib => libz}/fudge/p9p.h                  |   0
 {lib => libz}/fudge/pcf.c                  |   0
 {lib => libz}/fudge/pcf.h                  |   0
 {lib => libz}/fudge/record.h               |   0
 {lib => libz}/fudge/regexp.c               |   0
 {lib => libz}/fudge/regexp.h               |   0
 {lib => libz}/fudge/ring.c                 |   0
 {lib => libz}/fudge/ring.h                 |   0
 {lib => libz}/fudge/riscv/atomic.c         |   0
 {lib => libz}/fudge/riscv/rules.mk         |   0
 {lib => libz}/fudge/rules.mk               |   0
 {lib => libz}/fudge/spinlock.c             |   0
 {lib => libz}/fudge/spinlock.h             |   0
 {lib => libz}/fudge/tar.c                  |   0
 {lib => libz}/fudge/tar.h                  |   0
 {lib => libz}/fudge/time.c                 |   0
 {lib => libz}/fudge/time.h                 |   0
 {lib => libz}/fudge/url.c                  |   0
 {lib => libz}/fudge/url.h                  |   0
 {lib => libz}/fudge/utf8.c                 |   0
 {lib => libz}/fudge/utf8.h                 |   0
 {lib => libz}/fudge/x86/atomic.s           |   0
 {lib => libz}/fudge/x86/rules.mk           |   0
 {lib => libz}/hash/crc.c                   |   0
 {lib => libz}/hash/crc.h                   |   0
 {lib => libz}/hash/md5.c                   |   0
 {lib => libz}/hash/md5.h                   |   0
 {lib => libz}/hash/rules.mk                |   0
 {lib => libz}/hash/sha1.c                  |   0
 {lib => libz}/hash/sha1.h                  |   0
 {lib => libz}/image/pcx.c                  |   0
 {lib => libz}/image/pcx.h                  |   0
 {lib => libz}/image/rules.mk               |   0
 {lib => libz}/math/math.c                  |   0
 {lib => libz}/math/math.h                  |   0
 {lib => libz}/math/rules.mk                |   0
 {lib => libz}/net/arp.c                    |   0
 {lib => libz}/net/arp.h                    |   0
 {lib => libz}/net/dns.c                    |   0
 {lib => libz}/net/dns.h                    |   0
 {lib => libz}/net/ethernet.c               |   0
 {lib => libz}/net/ethernet.h               |   0
 {lib => libz}/net/icmp.c                   |   0
 {lib => libz}/net/icmp.h                   |   0
 {lib => libz}/net/ipv4.c                   |   0
 {lib => libz}/net/ipv4.h                   |   0
 {lib => libz}/net/ipv6.h                   |   0
 {lib => libz}/net/net.c                    |   0
 {lib => libz}/net/net.h                    |   0
 {lib => libz}/net/rules.mk                 |   0
 {lib => libz}/net/tcp.c                    |   0
 {lib => libz}/net/tcp.h                    |   0
 {lib => libz}/net/udp.c                    |   0
 {lib => libz}/net/udp.h                    |   0
 {lib => libz}/rules.mk                     |   0
 {lib => libz}/socket/rules.mk              |   0
 {lib => libz}/socket/socket.c              |   0
 {lib => libz}/socket/socket.h              |   0
 {lib => libz}/tcc/rules.mk                 |   0
 {lib => libz}/tcc/tcc.c                    |   0
 {lib => libz}/tcc/tcc.h                    |   0
 201 files changed, 7550 insertions(+)
 create mode 100644 lib/include/api.h
 create mode 100644 lib/include/bitreader.h
 create mode 100644 lib/include/convert.h
 create mode 100644 lib/include/datetime.h
 create mode 100644 lib/include/gui/canvas.h
 create mode 100644 lib/include/gui/colors.h
 create mode 100644 lib/include/gui/context.h
 create mode 100644 lib/include/gui/contextheap.h
 create mode 100644 lib/include/gui/contextinfo.h
 create mode 100644 lib/include/gui/directgui.h
 create mode 100644 lib/include/gui/events.h
 create mode 100644 lib/include/gui/fonts/font.h
 create mode 100644 lib/include/gui/fonts/fontparser.h
 create mode 100644 lib/include/gui/gui.h
 create mode 100644 lib/include/gui/property.h
 create mode 100644 lib/include/gui/rect.h
 create mode 100644 lib/include/gui/widgets/button.h
 create mode 100644 lib/include/gui/widgets/control.h
 create mode 100644 lib/include/gui/widgets/label.h
 create mode 100644 lib/include/gui/widgets/listview.h
 create mode 100644 lib/include/gui/widgets/scrollbar.h
 create mode 100644 lib/include/gui/widgets/scrollbox.h
 create mode 100644 lib/include/gui/widgets/slider.h
 create mode 100644 lib/include/gui/widgets/window.h
 create mode 100644 lib/include/heap.h
 create mode 100644 lib/include/imaging/bmpformat.h
 create mode 100644 lib/include/imaging/image.h
 create mode 100644 lib/include/imaging/jpeg_decoder.h
 create mode 100644 lib/include/imaging/pngformat.h
 create mode 100644 lib/include/ipc.h
 create mode 100644 lib/include/list.h
 create mode 100644 lib/include/listing.h
 create mode 100644 lib/include/log.h
 create mode 100644 lib/include/math.h
 create mode 100644 lib/include/new.h
 create mode 100644 lib/include/proc.h
 create mode 100644 lib/include/random.h
 create mode 100644 lib/include/shared.h
 create mode 100644 lib/include/string.h
 create mode 100644 lib/include/syscall.h
 create mode 100644 lib/include/systeminfo.h
 create mode 100644 lib/include/time.h
 create mode 100644 lib/include/types.h
 create mode 100644 lib/include/vector.h
 create mode 100644 lib/include/vfs.h
 create mode 100644 lib/makefile
 create mode 100644 lib/src/api.cpp
 create mode 100644 lib/src/convert.cpp
 create mode 100644 lib/src/crt/crt0.asm
 create mode 100644 lib/src/datetime.cpp
 create mode 100644 lib/src/gui/canvas.cpp
 create mode 100644 lib/src/gui/colors.cpp
 create mode 100644 lib/src/gui/context.cpp
 create mode 100644 lib/src/gui/contextheap.cpp
 create mode 100644 lib/src/gui/directgui.cpp
 create mode 100644 lib/src/gui/fonts/font.cpp
 create mode 100644 lib/src/gui/fonts/fontparser.cpp
 create mode 100644 lib/src/gui/gui.cpp
 create mode 100644 lib/src/gui/property.cpp
 create mode 100644 lib/src/gui/rect.cpp
 create mode 100644 lib/src/gui/widgets/button.cpp
 create mode 100644 lib/src/gui/widgets/control.cpp
 create mode 100644 lib/src/gui/widgets/label.cpp
 create mode 100644 lib/src/gui/widgets/scrollbar.cpp
 create mode 100644 lib/src/gui/widgets/slider.cpp
 create mode 100644 lib/src/gui/widgets/window.cpp
 create mode 100644 lib/src/heap.cpp
 create mode 100644 lib/src/imaging/bmpformat.cpp
 create mode 100644 lib/src/imaging/image.cpp
 create mode 100644 lib/src/imaging/pngformat.cpp
 create mode 100644 lib/src/ipc.cpp
 create mode 100644 lib/src/log.cpp
 create mode 100644 lib/src/main.cpp
 create mode 100644 lib/src/math.cpp
 create mode 100644 lib/src/proc.cpp
 create mode 100644 lib/src/random.cpp
 create mode 100644 lib/src/string.cpp
 create mode 100644 lib/src/syscall.cpp
 create mode 100644 lib/src/systeminfo.cpp
 create mode 100644 lib/src/time.cpp
 create mode 100644 lib/src/vfs.cpp
 rename {lib => libz}/abi/arm/call.c (100%)
 rename {lib => libz}/abi/arm/crt0.s (100%)
 rename {lib => libz}/abi/arm/qrules.mk (100%)
 rename {lib => libz}/abi/arm/rules.mk (100%)
 rename {lib => libz}/abi/call.c (100%)
 rename {lib => libz}/abi/call.h (100%)
 rename {lib => libz}/abi/channel.c (100%)
 rename {lib => libz}/abi/channel.h (100%)
 rename {lib => libz}/abi/crt0.c (100%)
 rename {lib => libz}/abi/crt0.h (100%)
 rename {lib => libz}/abi/job.c (100%)
 rename {lib => libz}/abi/job.h (100%)
 rename {lib => libz}/abi/option.c (100%)
 rename {lib => libz}/abi/option.h (100%)
 rename {lib => libz}/abi/riscv/call.c (100%)
 rename {lib => libz}/abi/riscv/crt0.s (100%)
 rename {lib => libz}/abi/riscv/qrules.mk (100%)
 rename {lib => libz}/abi/riscv/rules.mk (100%)
 rename {lib => libz}/abi/rules.mk (100%)
 rename {lib => libz}/abi/x86/call.s (100%)
 rename {lib => libz}/abi/x86/crt0.s (100%)
 rename {lib => libz}/abi/x86/qcall.s (100%)
 rename {lib => libz}/abi/x86/qrules.mk (100%)
 rename {lib => libz}/abi/x86/rules.mk (100%)
 rename {lib => libz}/fudge/arm/__aeabi_idiv.c (100%)
 rename {lib => libz}/fudge/arm/__aeabi_idivmod.s (100%)
 rename {lib => libz}/fudge/arm/__aeabi_uidiv.c (100%)
 rename {lib => libz}/fudge/arm/__aeabi_uidivmod.s (100%)
 rename {lib => libz}/fudge/arm/__clzsi2.c (100%)
 rename {lib => libz}/fudge/arm/__divsi3.c (100%)
 rename {lib => libz}/fudge/arm/__modsi3.c (100%)
 rename {lib => libz}/fudge/arm/__udivmodsi4.c (100%)
 rename {lib => libz}/fudge/arm/__udivsi3.c (100%)
 rename {lib => libz}/fudge/arm/__umodsi3.c (100%)
 rename {lib => libz}/fudge/arm/atomic.c (100%)
 rename {lib => libz}/fudge/arm/rules.mk (100%)
 rename {lib => libz}/fudge/atomic.h (100%)
 rename {lib => libz}/fudge/base64.c (100%)
 rename {lib => libz}/fudge/base64.h (100%)
 rename {lib => libz}/fudge/buffer.c (100%)
 rename {lib => libz}/fudge/buffer.h (100%)
 rename {lib => libz}/fudge/cpio.c (100%)
 rename {lib => libz}/fudge/cpio.h (100%)
 rename {lib => libz}/fudge/cstring.c (100%)
 rename {lib => libz}/fudge/cstring.h (100%)
 rename {lib => libz}/fudge/ctrl.h (100%)
 rename {lib => libz}/fudge/elf.c (100%)
 rename {lib => libz}/fudge/elf.h (100%)
 rename {lib => libz}/fudge/event.h (100%)
 rename {lib => libz}/fudge/file.h (100%)
 rename {lib => libz}/fudge/keys.c (100%)
 rename {lib => libz}/fudge/keys.h (100%)
 rename {lib => libz}/fudge/list.c (100%)
 rename {lib => libz}/fudge/list.h (100%)
 rename {lib => libz}/fudge/message.c (100%)
 rename {lib => libz}/fudge/message.h (100%)
 rename {lib => libz}/fudge/mtwist.c (100%)
 rename {lib => libz}/fudge/mtwist.h (100%)
 rename {lib => libz}/fudge/p9p.c (100%)
 rename {lib => libz}/fudge/p9p.h (100%)
 rename {lib => libz}/fudge/pcf.c (100%)
 rename {lib => libz}/fudge/pcf.h (100%)
 rename {lib => libz}/fudge/record.h (100%)
 rename {lib => libz}/fudge/regexp.c (100%)
 rename {lib => libz}/fudge/regexp.h (100%)
 rename {lib => libz}/fudge/ring.c (100%)
 rename {lib => libz}/fudge/ring.h (100%)
 rename {lib => libz}/fudge/riscv/atomic.c (100%)
 rename {lib => libz}/fudge/riscv/rules.mk (100%)
 rename {lib => libz}/fudge/rules.mk (100%)
 rename {lib => libz}/fudge/spinlock.c (100%)
 rename {lib => libz}/fudge/spinlock.h (100%)
 rename {lib => libz}/fudge/tar.c (100%)
 rename {lib => libz}/fudge/tar.h (100%)
 rename {lib => libz}/fudge/time.c (100%)
 rename {lib => libz}/fudge/time.h (100%)
 rename {lib => libz}/fudge/url.c (100%)
 rename {lib => libz}/fudge/url.h (100%)
 rename {lib => libz}/fudge/utf8.c (100%)
 rename {lib => libz}/fudge/utf8.h (100%)
 rename {lib => libz}/fudge/x86/atomic.s (100%)
 rename {lib => libz}/fudge/x86/rules.mk (100%)
 rename {lib => libz}/hash/crc.c (100%)
 rename {lib => libz}/hash/crc.h (100%)
 rename {lib => libz}/hash/md5.c (100%)
 rename {lib => libz}/hash/md5.h (100%)
 rename {lib => libz}/hash/rules.mk (100%)
 rename {lib => libz}/hash/sha1.c (100%)
 rename {lib => libz}/hash/sha1.h (100%)
 rename {lib => libz}/image/pcx.c (100%)
 rename {lib => libz}/image/pcx.h (100%)
 rename {lib => libz}/image/rules.mk (100%)
 rename {lib => libz}/math/math.c (100%)
 rename {lib => libz}/math/math.h (100%)
 rename {lib => libz}/math/rules.mk (100%)
 rename {lib => libz}/net/arp.c (100%)
 rename {lib => libz}/net/arp.h (100%)
 rename {lib => libz}/net/dns.c (100%)
 rename {lib => libz}/net/dns.h (100%)
 rename {lib => libz}/net/ethernet.c (100%)
 rename {lib => libz}/net/ethernet.h (100%)
 rename {lib => libz}/net/icmp.c (100%)
 rename {lib => libz}/net/icmp.h (100%)
 rename {lib => libz}/net/ipv4.c (100%)
 rename {lib => libz}/net/ipv4.h (100%)
 rename {lib => libz}/net/ipv6.h (100%)
 rename {lib => libz}/net/net.c (100%)
 rename {lib => libz}/net/net.h (100%)
 rename {lib => libz}/net/rules.mk (100%)
 rename {lib => libz}/net/tcp.c (100%)
 rename {lib => libz}/net/tcp.h (100%)
 rename {lib => libz}/net/udp.c (100%)
 rename {lib => libz}/net/udp.h (100%)
 rename {lib => libz}/rules.mk (100%)
 rename {lib => libz}/socket/rules.mk (100%)
 rename {lib => libz}/socket/socket.c (100%)
 rename {lib => libz}/socket/socket.h (100%)
 rename {lib => libz}/tcc/rules.mk (100%)
 rename {lib => libz}/tcc/tcc.c (100%)
 rename {lib => libz}/tcc/tcc.h (100%)

diff --git a/lib/include/api.h b/lib/include/api.h
new file mode 100644
index 0000000..41f43a8
--- /dev/null
+++ b/lib/include/api.h
@@ -0,0 +1,18 @@
+#ifndef __CACTUSOSLIB__API_H
+#define __CACTUSOSLIB__API_H
+
+#include <types.h>
+
+namespace LIBCactusOS
+{
+    class API
+    {
+    public:
+        /**
+         * Initialize the CactusOS Api for this process
+        */
+        static void Initialize();
+    };
+}
+
+#endif
\ No newline at end of file
diff --git a/lib/include/bitreader.h b/lib/include/bitreader.h
new file mode 100644
index 0000000..5ee100d
--- /dev/null
+++ b/lib/include/bitreader.h
@@ -0,0 +1,72 @@
+#ifndef __LIBCACTUSOS__BITREADER_H
+#define __LIBCACTUSOS__BITREADER_H
+
+#include <types.h>
+
+namespace LIBCactusOS
+{
+    // Used to read specific bits of a datastream
+    class BitReader
+    {
+    private:
+        uint8_t* dataPtr = 0;
+        uint32_t pos = 0;
+        uint8_t  byte = 0;
+        uint32_t numBits = 0;
+    public:
+        BitReader(uint8_t* data)
+        {
+            this->dataPtr = data;
+            this->pos = 0;
+            this->byte = 0;
+            this->numBits = 0;
+        }
+
+        // Read single byte
+        uint8_t ReadByte()
+        {
+            // Discard other bits
+            this->numBits = 0;
+            uint8_t b = this->dataPtr[this->pos];
+            this->pos += 1;
+            return b;
+        }
+
+        // Read single bit
+        uint8_t ReadBit()
+        {
+            if(this->numBits <= 0) {
+                this->byte = this->ReadByte();
+                this->numBits = 8;
+            }
+            this->numBits -= 1;
+            uint8_t bit = this->byte & 1;
+            this->byte >>= 1;
+            return bit;
+        }
+
+        // Read bits as type
+        template<typename T>
+        T ReadBits(uint32_t n)
+        {
+            T ret = 0;
+            for(uint32_t i = 0; i < n; i++)
+                ret |= (this->ReadBit() << i);
+            
+            return ret;            
+        }
+
+        // Read bytes as type
+        template<typename T>
+        T ReadBytes(uint32_t n)
+        {
+            T ret = 0;
+            for(uint32_t i = 0; i < n; i++)
+                ret |= (this->ReadByte() << (i*8));
+            
+            return ret;
+        }
+    };
+}
+
+#endif
\ No newline at end of file
diff --git a/lib/include/convert.h b/lib/include/convert.h
new file mode 100644
index 0000000..a0d6026
--- /dev/null
+++ b/lib/include/convert.h
@@ -0,0 +1,21 @@
+#ifndef __LIBCACTUSOS__CONVERT_H
+#define __LIBCACTUSOS__CONVERT_H
+
+#include <types.h>
+
+namespace LIBCactusOS
+{
+    class Convert
+    {
+    public:
+        static char* IntToString(int i);
+
+        static char* IntToHexString(uint8_t w);
+        static char* IntToHexString(uint16_t w);
+        static char* IntToHexString(uint32_t w);
+
+        static int StringToInt(char* string);
+    };
+}
+
+#endif
\ No newline at end of file
diff --git a/lib/include/datetime.h b/lib/include/datetime.h
new file mode 100644
index 0000000..d3c3323
--- /dev/null
+++ b/lib/include/datetime.h
@@ -0,0 +1,29 @@
+#ifndef __LIBCACTUSOS__DATETIME_H
+#define __LIBCACTUSOS__DATETIME_H
+
+namespace LIBCactusOS
+{
+    class DateTime
+    {
+    public:
+        signed char Day = -1;
+        signed char Month = -1;
+        int Year = -1;
+
+        signed char Seconds = -1;
+        signed char Minutes = -1;
+        signed char Hours = -1;
+
+        /**
+         * Get the current date and time of this system
+        */
+        static DateTime Current();
+
+        /**
+         * Convert DateTime into a readable string
+        */
+        char* ToString();
+    };
+}
+
+#endif
\ No newline at end of file
diff --git a/lib/include/gui/canvas.h b/lib/include/gui/canvas.h
new file mode 100644
index 0000000..19c59d7
--- /dev/null
+++ b/lib/include/gui/canvas.h
@@ -0,0 +1,42 @@
+#ifndef __LIBCACTUSOS__GUI__CANVAS_H
+#define __LIBCACTUSOS__GUI__CANVAS_H
+
+#include <types.h>
+#include <gui/fonts/font.h>
+
+namespace LIBCactusOS
+{
+    class Canvas
+    {
+    private:
+        void DrawCircleHelper(int x, int y, int radius, uint32_t corner, uint32_t color);
+        void FillCircleHelper(int x, int y, int radius, uint32_t corner, int delta, uint32_t color);
+    public:
+        void* bufferPointer;
+        int Width;
+        int Height;
+
+        Canvas(void* buffer, int w, int h);
+
+        void SetPixel(int x, int y, uint32_t color);
+        uint32_t GetPixel(int x, int y);
+
+        void Clear();
+        void Clear(uint32_t color);
+        void DrawHorizontalLine(uint32_t color, int dx, int x1, int y1);
+        void DrawVerticalLine(uint32_t color, int dx, int x1, int y1);
+        void DrawLine(uint32_t color, int x1, int y1, int x2, int y2);
+        void DrawDiagonalLine(uint32_t color, int dx, int dy, int x1, int y1);
+        void DrawRect(uint32_t color, int x, int y, int width, int height);
+        void DrawRoundedRect(uint32_t color, int x, int y, int width, int height, int radius);
+        void DrawFillRoundedRect(uint32_t color, int x, int y, int width, int height, int radius);
+        void DrawFillRect(uint32_t color, int x_start, int y_start, int width, int height);
+        void DrawCircle(uint32_t color, int x_center, int y_center, int radius);
+        void DrawFillCircle(uint32_t color, int x_center, int y_center, int radius);
+        void DrawEllipse(uint32_t color, int x_center, int y_center, int x_radius, int y_radius);
+
+        void DrawString(Font* font, char* string, int x, int y, uint32_t color);
+    };
+}
+
+#endif
\ No newline at end of file
diff --git a/lib/include/gui/colors.h b/lib/include/gui/colors.h
new file mode 100644
index 0000000..16123c7
--- /dev/null
+++ b/lib/include/gui/colors.h
@@ -0,0 +1,46 @@
+#ifndef __LIBCACTUSOS__GUI__COLORS_H
+#define __LIBCACTUSOS__GUI__COLORS_H
+
+#include <types.h>
+
+namespace LIBCactusOS
+{
+    // Union describing a ARGB color in the following format:
+    // 0xAARRGGBB
+    typedef union Color4Tag
+    {
+        uint32_t c;
+        struct ColorComponents
+        {
+            uint8_t b;
+            uint8_t g;
+            uint8_t r;
+            uint8_t a;
+        } argb;
+    } Color4;
+  
+    class Colors
+    {
+    public:
+        static const uint32_t Black = 0xFF000000;
+        static const uint32_t White = 0xFFFFFFFF;
+        static const uint32_t Red   = 0xFFFF0000;
+        static const uint32_t Green = 0xFF00FF00;
+        static const uint32_t Blue  = 0xFF0000FF;
+        static const uint32_t Transparent = 0x00000000;
+    public:
+        /**
+         * Blend to colors using alpha blending
+         * Color1 is background
+         * Color2 is foreground
+        */
+        static const uint32_t AlphaBlend(uint32_t color1, uint32_t color2);
+        
+        /**
+         * Convert a ARGB color to 0xAARRGGBB format
+        */
+        static const uint32_t FromARGB(uint8_t a, uint8_t r, uint8_t g, uint8_t b);
+    };
+}
+
+#endif
\ No newline at end of file
diff --git a/lib/include/gui/context.h b/lib/include/gui/context.h
new file mode 100644
index 0000000..4b860ca
--- /dev/null
+++ b/lib/include/gui/context.h
@@ -0,0 +1,94 @@
+#ifndef __LIBCACTUSOS__GUI__CONTEXT_H
+#define __LIBCACTUSOS__GUI__CONTEXT_H
+
+#include <types.h>
+#include <gui/rect.h>
+#include <gui/contextinfo.h>
+#include <gui/widgets/control.h>
+#include <shared.h>
+
+namespace LIBCactusOS
+{   
+    /**
+     * Represents a region of framebuffer shared between client and server
+    */
+    class Context : public EventObject
+    { 
+    public:
+        /**
+         * Which control is contained in this context.
+        */
+        Control* Window;
+
+        /**
+         * With this canvas you can directly draw to this context
+        */
+        Canvas* canvas;
+
+        /**
+         * A struct that is shared with the compositor that describes the physical dimensions of this context
+        */
+        ContextInfo* sharedContextInfo;
+
+        /**
+         * Create a new context by a framebuffer and dimensions
+        */
+        Context(uint32_t framebufferAddr, int width = 0, int height = 0);
+
+        /**
+         * Draw all the gui components to this context
+        */
+        void DrawGUI();
+
+        /**
+         * Move this context to a new position.
+        */
+        void MoveToPosition(int newX, int newY);
+
+        /**
+         * Remove this context from the screen and free all the used memory 
+        */
+        void CloseContext();
+
+        /**
+         * Function to draw a peice of text aligned within a boundry
+        */
+        static void DrawStringAligned(Canvas* target, Font* font, char* string, uint32_t color, Rectangle bounds, Alignment align, int xoff = 0, int yoff = 0);
+
+    /*///////////////
+    // Events called by GUI class
+    *////////////////
+    friend class GUI;
+    protected:
+        /**
+         * Called when mouse is down on context
+        */
+        void OnMouseDown(int x_abs, int y_abs, uint8_t button);
+        /**
+         * Called when mouse is up on context
+        */
+        void OnMouseUp(int x_abs, int y_abs, uint8_t button);
+        /**
+         * Called when mouse moves above context or enters/leaves context
+        */
+        void OnMouseMove(int prevX_abs, int prevY_abs, int newX_abs, int newY_abs);
+        /**
+         * Called when a key is held down and this is the active context.
+        */
+        void OnKeyDown(uint8_t key, KEYPACKET_FLAGS modifiers);
+        /**
+         * Called when a key is held up and this is the active context.
+        */
+        void OnKeyUp(uint8_t key, KEYPACKET_FLAGS modifiers);
+        /**
+         * Called when contex is resized
+        */
+        void OnResize(Rectangle old);
+        /**
+         * Called when scroll wheel is used on context
+        */
+        void OnScroll(int32_t deltaZ, int x_abs, int y_abs);
+    };
+}
+
+#endif
\ No newline at end of file
diff --git a/lib/include/gui/contextheap.h b/lib/include/gui/contextheap.h
new file mode 100644
index 0000000..fb81045
--- /dev/null
+++ b/lib/include/gui/contextheap.h
@@ -0,0 +1,23 @@
+#ifndef __LIBCACTUSOS__GUI__CONTEXTHEAP_H
+#define __LIBCACTUSOS__GUI__CONTEXTHEAP_H
+
+#include <types.h>
+
+namespace LIBCactusOS
+{
+    //Class that provides functions for allocating memory space for contexts.
+    //Note: Memory region is not allocated, just a block that is reserved after allocating.
+    class ContextHeap
+    {
+    public:
+        static void Init();
+        //Allocate a area of memory, blocks is in units per 4096 bytes
+        static uint32_t AllocateArea(uint32_t blocks);
+        //Free area of memory
+        static void FreeArea(uint32_t address, uint32_t blocks);
+        //Get amount of memory used as factor [0-1]
+        static double MemoryUsage();
+    };
+}
+
+#endif
\ No newline at end of file
diff --git a/lib/include/gui/contextinfo.h b/lib/include/gui/contextinfo.h
new file mode 100644
index 0000000..4ef7e9d
--- /dev/null
+++ b/lib/include/gui/contextinfo.h
@@ -0,0 +1,113 @@
+#ifndef CONTEXTINFO_H
+#define CONTEXTINFO_H
+
+#include <types.h>
+#include <proc.h>
+#include <gui/rect.h>
+
+// We reserve 1 page for the context info structure for alignment reasons
+// The struct itself is not actually this big though
+#define CONTEXT_INFO_SIZE 4_KB
+
+// Maximum of dirty rects per frame per contextinfo struct
+#define CONTEXT_INFO_MAX_DIRTY 200
+
+// Directions a context can be resized in
+enum Direction
+{
+    None = (0<<0),
+    Top = (1<<0),
+    Right = (1<<1),
+    Bottom = (1<<2),
+    Left = (1<<3)
+};
+
+inline Direction operator|(Direction a, Direction b)
+{
+    return static_cast<Direction>(static_cast<int>(a) | static_cast<int>(b));
+}
+
+struct ContextInfo
+{
+    // To which memory address is the framebuffer mapped on the server side (ContextInfo is placed just before this address)
+    LIBCactusOS::uint32_t virtAddrServer;
+    // To which memory address is the framebuffer mapped on the client side (ContextInfo is placed just before this address)
+    LIBCactusOS::uint32_t virtAddrClient;
+
+    // How many bytes does this context use? This includes the memory used by this struct
+    LIBCactusOS::uint32_t bytes;
+    // The width of this context
+    LIBCactusOS::uint32_t width;
+    // The height of this context
+    LIBCactusOS::uint32_t height;
+    // The position on the horizontal axis
+    LIBCactusOS::int32_t x;
+    // The position on the vertical axis
+    LIBCactusOS::int32_t y;
+
+    // The PID of the process that created this context
+    int clientID;
+
+    // Does this context support transparency? If so it will be drawn using an alternative method.
+    // Warning: If set to true the drawing will be slower.
+    bool supportsTransparency;
+
+    // Can this context be moved to the front using a mouse click in it? (this will be done automatically when set to false)
+    bool background;
+
+    // Each context gets it own unique id, this way the compositor can find the right context for each message. For example when a keypress occurs.
+    int id;
+
+    // Does this context support the dirty rectangle technique?
+    bool supportsDirtyRects;
+
+    // Spinlock for modifying dirty rectangles
+    bool dirtyLockFlag;
+
+    // Number of dirty rectangles in the array below
+    LIBCactusOS::uint16_t numDirtyRects;
+
+    // Array of dirty rectangles specific to this context
+    struct
+    {
+        // The width of this rectangle
+        int width;
+        // The height of this rectangle
+        int height;
+        // The x coördinate of this rectangle
+        int x;
+        // The y coördinate of this rectangle
+        int y;
+    } dirtyRects[CONTEXT_INFO_MAX_DIRTY];
+
+    // Mark an area as dirty so that the compositor draws it
+    void AddDirtyArea(int x, int y, int width, int height)
+    {
+        // Wait until no one else is also doing this
+        while(dirtyLockFlag) Process::Yield();
+
+        if(this->numDirtyRects >= CONTEXT_INFO_MAX_DIRTY)
+            return; // Skip this one since the array is full :(
+
+        // Now we take control
+        dirtyLockFlag = true;
+
+        // Add dirty rectangle
+        this->dirtyRects[this->numDirtyRects].x = x;
+        this->dirtyRects[this->numDirtyRects].y = y;
+        this->dirtyRects[this->numDirtyRects].width = width;
+        this->dirtyRects[this->numDirtyRects].height = height;
+        this->numDirtyRects += 1;
+
+        // Release lock
+        dirtyLockFlag = false;
+    }
+
+    // Mark an area as dirty so that the compositor draws it
+    void AddDirtyArea(Rectangle* rect) { this->AddDirtyArea(rect->x, rect->y, rect->width, rect->height); }
+};
+
+// Check if the structure doesn't cross page boundary
+STATIC_ASSERT(sizeof(ContextInfo) < CONTEXT_INFO_SIZE);
+
+#endif
\ No newline at end of file
diff --git a/lib/include/gui/directgui.h b/lib/include/gui/directgui.h
new file mode 100644
index 0000000..e5238ee
--- /dev/null
+++ b/lib/include/gui/directgui.h
@@ -0,0 +1,35 @@
+#ifndef __CACTUSOSLIB__GUI__DIRECTGUI_H
+#define __CACTUSOSLIB__GUI__DIRECTGUI_H
+
+#include <types.h>
+#include <gui/canvas.h>
+
+namespace LIBCactusOS
+{
+    class DirectGUI
+    {
+    public:
+        static bool RequestFramebuffer();
+        static Canvas* GetCanvas();
+
+        static void SetPixel(int x, int y, uint32_t color);
+        static uint32_t GetPixel(int x, int y);
+
+        static void Clear();
+        static void Clear(uint32_t color);
+        static void DrawHorizontalLine(uint32_t color, int dx, int x1, int y1);
+        static void DrawVerticalLine(uint32_t color, int dx, int x1, int y1);
+        static void DrawLine(uint32_t color, int x1, int y1, int x2, int y2);
+        static void DrawDiagonalLine(uint32_t color, int dx, int dy, int x1, int y1);
+        static void DrawRect(uint32_t color, int x, int y, int width, int height);
+        static void DrawFillRect(uint32_t color, int x_start, int y_start, int width, int height);
+        static void DrawCircle(uint32_t color, int x_center, int y_center, int radius);
+        static void DrawFillCircle(uint32_t color, int x_center, int y_center, int radius);
+        static void DrawEllipse(uint32_t color, int x_center, int y_center, int x_radius, int y_radius);
+
+        static void DrawChar(char character, int x, int y, uint32_t color);
+        static void DrawString(char* string, int x, int y, uint32_t color);
+    };
+}
+
+#endif
\ No newline at end of file
diff --git a/lib/include/gui/events.h b/lib/include/gui/events.h
new file mode 100644
index 0000000..99003a1
--- /dev/null
+++ b/lib/include/gui/events.h
@@ -0,0 +1,187 @@
+#ifndef __LIBCACTUSOS__GUI__EVENTS_H
+#define __LIBCACTUSOS__GUI__EVENTS_H
+
+#include <list.h>
+#include <gui/widgets/control.h>
+#include <shared.h>
+
+namespace LIBCactusOS
+{
+    // A class that defines a callback function 
+    template<typename ArgumentType>
+    class IEventCallback
+    {
+    public:
+        virtual void Invoke(void*, ArgumentType) {}
+    };
+
+    // A callback that is a class method
+    template<typename T, typename ArgumentType>
+    class MethodCallback : public IEventCallback<ArgumentType>
+    {
+    private:
+        T* instance;
+        void (T::*function)(void* s, ArgumentType arg);
+    public:
+        // Create a new callback based on a member function
+        MethodCallback(T* instance, void (T::*function)(void* s, ArgumentType arg))
+        : instance(instance), function(function) 
+        {}
+
+        virtual void Invoke(void* s, ArgumentType arg) override
+        {
+            (instance->*function)(s, arg); 
+        }
+    };
+
+    // A callback that is a static function
+    template<typename ArgumentType>
+    class StaticFunctionCallback : public IEventCallback<ArgumentType>
+    {
+    private:
+        void (*func_)(void*, ArgumentType);
+    
+    public:
+        StaticFunctionCallback(void (*func)(void*, ArgumentType))
+        : func_(func)
+        {}
+        
+        virtual void Invoke(void* s, ArgumentType a)
+        {
+            return (*func_)(s, a);
+        }
+    };
+
+    // A class that manages a list of multipile callback for a specific event
+    template<typename ArgumentType>
+    class EventHandlerList
+    {
+    private:
+	    List<IEventCallback<ArgumentType>*> Callbacks;
+    public:
+        EventHandlerList() {}
+        ~EventHandlerList() {}
+
+        void AddHandler(IEventCallback<ArgumentType>* action)
+        {
+            Callbacks.push_back(action);
+        }
+	    void RemoveHandler(IEventCallback<ArgumentType>* action)
+        {
+            Callbacks.Remove(action);
+            delete action;
+        }
+	    void Invoke(void* sender, ArgumentType arg)
+        {
+            for (IEventCallback<ArgumentType>* action : Callbacks)
+                action->Invoke(sender, arg);
+        }
+
+        void operator+= (IEventCallback<ArgumentType>* action)
+        {
+            AddHandler(action);
+        }
+        void operator+= (void (*func)(void*, ArgumentType))
+        {
+            AddHandler(new StaticFunctionCallback<ArgumentType>(func));
+        }
+        void operator-= (IEventCallback<ArgumentType>* action)
+        {
+            RemoveHandler(action);
+        }
+    };
+
+    ////////////////////
+    // Argument macro implementations
+    ////////////////////
+    #define CREATE_ARGUMENT_CLASS0(name) \
+        class name \
+        { \
+        public: \
+            name() {} \
+        }; \
+    
+    #define CREATE_ARGUMENT_CLASS1(name, t1, var1) \
+        class name \
+        { \
+        public: \
+            t1 var1; \
+            name(t1 var1) \
+            { \
+                this->var1 = var1; \
+            } \
+        }; \
+    
+    #define CREATE_ARGUMENT_CLASS2(name, t1, var1, t2, var2) \
+        class name \
+        { \
+        public: \
+            t1 var1; \
+            t2 var2; \
+            name(t1 var1, t2 var2) \
+            { \
+                this->var1 = var1; \
+                this->var2 = var2; \
+            } \
+        }; \
+    
+    #define CREATE_ARGUMENT_CLASS3(name, t1, var1, t2, var2, t3, var3) \
+        class name \
+        { \
+        public: \
+            t1 var1; \
+            t2 var2; \
+            t3 var3; \
+            name(t1 var1, t2 var2, t3 var3) \
+            { \
+                this->var1 = var1; \
+                this->var2 = var2; \
+                this->var3 = var3; \
+            } \
+        }; \
+    
+    #define CREATE_ARGUMENT_CLASS4(name, t1, var1, t2, var2, t3, var3, t4, var4) \
+        class name \
+        { \
+        public: \
+            t1 var1; \
+            t2 var2; \
+            t3 var3; \
+            t4 var4; \
+            name(t1 var1, t2 var2, t3 var3, t4 var4) \
+            { \
+                this->var1 = var1; \
+                this->var2 = var2; \
+                this->var3 = var3; \
+                this->var4 = var4; \
+            } \
+        }; \
+
+    ///////////
+    // Argument classes for keypress or mouse events, more will be added later
+    ///////////
+    CREATE_ARGUMENT_CLASS4(MouseMoveArgs, int, prevX, int, prevY, int, newX, int, newY)
+    CREATE_ARGUMENT_CLASS3(MouseButtonArgs, int, x, int, y, int, button)
+    CREATE_ARGUMENT_CLASS2(KeypressArgs, uint8_t, key, KEYPACKET_FLAGS, modifiers)
+    CREATE_ARGUMENT_CLASS3(MouseScrollArgs, int, delta, int, x, int, y);
+
+    /**
+     * An object that hosts multiple gui events
+     */
+    class EventObject
+    {
+    public:
+        EventHandlerList<MouseButtonArgs> MouseDown;
+        EventHandlerList<MouseButtonArgs> MouseUp;
+        EventHandlerList<MouseButtonArgs> MouseClick;
+        EventHandlerList<KeypressArgs> KeyDown;
+        EventHandlerList<KeypressArgs> KeyUp;
+        EventHandlerList<MouseScrollArgs> MouseScroll;
+
+        EventObject()
+        : MouseDown(), MouseUp(), MouseClick(), KeyDown(), KeyUp(), MouseScroll()
+        {        }
+    };
+}
+
+#endif
\ No newline at end of file
diff --git a/lib/include/gui/fonts/font.h b/lib/include/gui/fonts/font.h
new file mode 100644
index 0000000..561eb30
--- /dev/null
+++ b/lib/include/gui/fonts/font.h
@@ -0,0 +1,19 @@
+#ifndef __LIBCACTUSOS__GUI__FONTS__FONT_H
+#define __LIBCACTUSOS__GUI__FONTS__FONT_H
+
+#include <types.h>
+
+namespace LIBCactusOS
+{
+    struct Font
+    {
+        uint8_t* data           = 0; // Raw font data including header
+        char* name              = 0; // Name of this font, stored inside data buffer
+        int size                = 0; // Size of this font in points
+        uint32_t* offsetTable   = 0; // Offsets for each character data sorted by character
+
+        void BoundingBox(char* str, int* retW, int* retH);
+    };
+}
+
+#endif
\ No newline at end of file
diff --git a/lib/include/gui/fonts/fontparser.h b/lib/include/gui/fonts/fontparser.h
new file mode 100644
index 0000000..f157434
--- /dev/null
+++ b/lib/include/gui/fonts/fontparser.h
@@ -0,0 +1,27 @@
+#ifndef __LIBCACTUSOS__GUI__FONTS__FONTPARSER_H
+#define __LIBCACTUSOS__GUI__FONTS__FONTPARSER_H
+
+#include <types.h>
+#include <gui/fonts/font.h>
+
+namespace LIBCactusOS
+{
+    // Header of a CactusOS Font File (CFF)
+    struct CFFHeader
+    {
+        uint32_t Magic;                     // Magic number containing 0xCFF
+        uint8_t  Version;                   // Version of this font file, propably 1
+        uint16_t FontSize;                  // Size of font in dots
+        uint32_t FontNameOffset;            // Offset in file data where font name is stored
+
+        uint32_t CharacterOffsets[127-32];  // Table which contains offsets to the data for each character
+    } __attribute__((packed));
+
+    class FontParser
+    {
+    public:
+        static Font* FromFile(char* filename);
+    };
+}
+
+#endif
\ No newline at end of file
diff --git a/lib/include/gui/gui.h b/lib/include/gui/gui.h
new file mode 100644
index 0000000..8cb42f9
--- /dev/null
+++ b/lib/include/gui/gui.h
@@ -0,0 +1,117 @@
+#ifndef __LIBCACTUSOS__GUI__GUI_H
+#define __LIBCACTUSOS__GUI__GUI_H
+
+#include <gui/widgets/control.h>
+#include <gui/widgets/window.h>
+#include <gui/context.h>
+
+namespace LIBCactusOS
+{
+    // Event definitions
+    enum GUIEvents
+    {
+        MouseDown,
+        MouseUp,
+        MouseMove,
+        Keypress,
+        MouseScroll,
+    };
+    
+    // Communication to the compositor definitions
+    enum GUICommunction
+    {
+        REQUEST_CONTEXT,
+        REQUEST_CLOSE,
+        CONTEXT_MOVED
+    };
+
+    // Buttons present on a regular mouse
+    enum MouseButtons
+    {
+        Left,
+        Middle,
+        Right
+    };
+
+    class Window;
+    class GUI
+    {
+    private:
+        static Context* FindTargetContext(int m_x, int m_y);
+    public:
+        // Current Width of video mode
+        static int Width;
+
+        // Current Height of video mode
+        static int Height;
+    public:
+        /**
+         * The PID used by the compositor process
+        */
+        static int compositorPID;
+
+        /**
+         * The list of all contexts in this application
+        */
+        static List<Context*>* contextList;
+        
+        /**
+         * System default font
+        */
+        static Font* defaultFont;
+
+        /**
+         * Initialize the gui for this process
+        */
+        static void Initialize();
+
+        /**
+         * Initialize the text rendering by loading the default font file from disk
+        */
+        static void SetDefaultFont(const char* filename = "B:\\fonts\\Ubuntu15.cff");
+        
+        /**
+         * Remove all gui elements created by this process
+        */
+        static void CleanUp();
+        
+        /**
+         * Process all the possible gui events
+        */
+        static void ProcessEvents();
+
+        /**
+         * Draw all the contexts to the screen
+        */
+        static void DrawGUI();
+
+        /**
+         * Create a thread for the gui
+        */
+        static void MakeAsync();
+
+        /**
+         * Is the current number of contexts larger than 0? 
+        */
+        static bool HasItems();
+
+        /**
+         * Request a context buffer for the application to draw to, this buffer is shared between the process and the compositor
+         * This buffer can be used for a gui but also for raw drawing to the screen
+         * 
+         * returns a pointer to the context struct
+         * @param width The width of the context
+         * @param height The height of the context
+         * @param x The position on horizontal axis
+         * @param y The position on vertical axis
+        */
+        static Context* RequestContext(int width, int height, int x, int y);
+
+        /**
+         * Find the window associated with the control
+        */
+        static Window* GetControlWindow(Control* control);
+    };
+}
+
+#endif
\ No newline at end of file
diff --git a/lib/include/gui/property.h b/lib/include/gui/property.h
new file mode 100644
index 0000000..eab6c79
--- /dev/null
+++ b/lib/include/gui/property.h
@@ -0,0 +1,77 @@
+#ifndef __LIBCACTUSOS__GUI__PROPERTY_H
+#define __LIBCACTUSOS__GUI__PROPERTY_H
+
+#include <types.h>
+
+namespace LIBCactusOS
+{
+    class Control;
+
+    template <typename>
+    class EventHandlerList;
+
+    // Function to force a control to update its GUI
+    // We need this because if we place it in the template we get a lot of warnings
+    // This a nice way to fix it
+    void UpdateGUIPropertyTargetGUI(Control* target);
+
+    // Property that is used to declare a gui specific variable
+    // When this property changes the gui needs to be repainted
+    template <typename T>
+    class GUIProperty
+    {
+    friend class Control;
+    protected:
+        // Value of this property
+        T value;
+
+        // Which control is the owner of this property
+        Control* parent = 0;
+    public:
+        // Called when value of this property is changed
+        // Make sure this does not create an infinite loop!
+        EventHandlerList<T> onChanged;
+    public:
+        // Create new property with default value and pointer to parent control
+        GUIProperty(Control* p, T def) { this->parent = p; this->value = def; }
+
+        // Deconstructor
+        ~GUIProperty() { }
+
+        
+        // Assignment operator
+        GUIProperty& operator=(T newVal)
+        {
+            this->value = newVal;
+            this->onChanged.Invoke(this, this->value);
+            UpdateGUIPropertyTargetGUI(this->parent);
+            return *this;
+        }
+
+        // Increase operator
+        GUIProperty& operator+=(T newVal)
+        {
+            this->value += newVal;
+            this->onChanged.Invoke(this, this->value);
+            UpdateGUIPropertyTargetGUI(this->parent);
+            return *this;
+        }
+
+        // Decrease operator
+        GUIProperty& operator-=(T newVal)
+        {
+            this->value -= newVal;
+            this->onChanged.Invoke(this, this->value);
+            UpdateGUIPropertyTargetGUI(this->parent);
+            return *this;
+        }
+
+        // Get operator, used for value feedback
+        operator T() const
+        {
+            return this->value;
+        }
+    };        
+}
+
+#endif
\ No newline at end of file
diff --git a/lib/include/gui/rect.h b/lib/include/gui/rect.h
new file mode 100644
index 0000000..5661f23
--- /dev/null
+++ b/lib/include/gui/rect.h
@@ -0,0 +1,80 @@
+#ifndef __LIBCACTUSOS__GUI__RECT_H
+#define __LIBCACTUSOS__GUI__RECT_H
+
+#include <types.h>
+#include <list.h>
+
+namespace LIBCactusOS
+{
+    /**
+     * A class that describes a rectangular shape
+    */
+    class Rectangle
+    {
+    public:
+        /**
+         * The width of this rectangle
+        */
+        int width;
+        /**
+         * The height of this rectangle
+        */
+        int height;
+        /**
+         * The x coördinate of this rectangle
+        */
+        int x;
+        /**
+         * The y coördinate of this rectangle
+        */
+        int y;
+
+        /**
+         * Create a new instance of the Rectangle Class
+        */
+        Rectangle(int w, int h, int x = 0, int y = 0);
+        
+        /**
+         * Create a new instance of the Rectangle Class
+        */
+        Rectangle();
+
+        /**
+         * Get the area of this rectangle
+         * Basically just width * height
+         */
+        int Area();
+
+        /**
+         * Get the intersection rectangle between this one and the target 
+         * Results holds the intersected rect
+         * Returns true for a intersection
+        */
+        bool Intersect(Rectangle other, Rectangle* result);
+
+        /**
+         * Does this rect contain the given point?
+        */
+        bool Contains(int x, int y);
+
+        /**
+         * Explode this rect into a list of contiguous rects
+        */
+        List<Rectangle>* Split(Rectangle cuttingRect, List<Rectangle>* output = 0);
+
+        /**
+         * Insert this rectangle into the clip list, splitting all existing rectangles against it to prevent overlap 
+        */
+        void PushToClipList(List<Rectangle>* targetList);
+
+        bool operator==(const Rectangle& right)
+        {
+            return (this->width == right.width && this->height == right.height && this->x == right.x && this->y == right.y);
+        }
+
+        // Return a rectangle of size 0, like Rectangle(0, 0, 0, 0)
+        static Rectangle Zero();
+    };
+}
+
+#endif
\ No newline at end of file
diff --git a/lib/include/gui/widgets/button.h b/lib/include/gui/widgets/button.h
new file mode 100644
index 0000000..c95910e
--- /dev/null
+++ b/lib/include/gui/widgets/button.h
@@ -0,0 +1,55 @@
+#ifndef __LIBCACTUSOS__GUI__BUTTON_H
+#define __LIBCACTUSOS__GUI__BUTTON_H
+
+#include <gui/widgets/control.h>
+#include <gui/gui.h>
+
+namespace LIBCactusOS
+{
+    /**
+     * A GUI button
+    */
+    class Button : public Control
+    {
+    public:
+        /**
+         * The text of this label
+        */
+        GUIProperty<char*> label = GUIProperty<char*>(this, 0);
+
+        /**
+         * Create a new button with a peice of text
+        */
+        Button(char* text = 0);
+
+        /**
+         * Draw this button
+        */
+        void DrawTo(Canvas* context, int x_abs, int y_abs) override;
+
+    /*/////////
+    // Events
+    *//////////
+    friend class Window;
+    friend class Context;
+    protected:
+        /**
+         * Called when mouse is down on control
+        */
+        void OnMouseDown(int x_abs, int y_abs, uint8_t button) override;
+        /**
+         * Called when mouse is up on control
+        */
+        void OnMouseUp(int x_abs, int y_abs, uint8_t button) override;
+        /**
+         * Called when mouse enters control
+        */
+        void OnMouseEnter(int prevX_abs, int prevY_abs, int newX_abs, int newY_abs) override;
+        /**
+         * Called when mouse leaves control
+        */
+        void OnMouseLeave(int prevX_abs, int prevY_abs, int newX_abs, int newY_abs) override;
+    };
+}
+
+#endif
\ No newline at end of file
diff --git a/lib/include/gui/widgets/control.h b/lib/include/gui/widgets/control.h
new file mode 100644
index 0000000..8bf1555
--- /dev/null
+++ b/lib/include/gui/widgets/control.h
@@ -0,0 +1,153 @@
+#ifndef __LIBCACTUSOS__GUI__CONTROL_H
+#define __LIBCACTUSOS__GUI__CONTROL_H
+
+#include <types.h>
+#include <gui/rect.h>
+#include <list.h>
+#include <gui/canvas.h>
+#include <gui/events.h>
+#include <gui/contextinfo.h>
+#include <gui/property.h>
+#include <gui/fonts/font.h>
+#include <gui/colors.h>
+
+namespace LIBCactusOS
+{
+    // Defines the alignment of a specific entry
+    // This is for the x and the y direction
+    struct Alignment
+    {
+        // Possible options for the alignment on the x-axis
+        enum class Horizontal
+        {
+            Left,
+            Center,
+            Right
+        };
+
+        // Possible options for the alignment on the y-axis
+        enum class Vertical
+        {
+            Top,
+            Center,
+            Bottom
+        };
+
+        Horizontal x; // X-Axis
+        Vertical y; // Y-Axis
+    };
+
+    // Possible style options for corners of controls
+    enum CornerStyle
+    {
+        Sharp,
+        Rounded
+    };
+
+    /**
+     * A class describing a gui object with possible children
+    */
+    class Control : public EventObject, public Rectangle
+    {
+    public:
+        // All controls that are present on this control.
+        List<Control*> childs;
+
+        // Which control currently is focused?
+        Control* focusedChild = 0;
+
+        // If we are a child of some control this will point to our parent.
+        Control* parent = 0;
+
+        // Does this control needs to be painted again?
+        bool needsRepaint = false;
+        
+        // Public properties for this control
+        GUIProperty<uint32_t>       backColor       = GUIProperty<uint32_t>(this, 0xFF919191);
+        GUIProperty<uint32_t>       borderColor     = GUIProperty<uint32_t>(this, 0xFF333333);
+        GUIProperty<Font*>          font            = GUIProperty<Font*>(this, 0);
+        GUIProperty<Alignment>      textAlignment   = GUIProperty<Alignment>(this, { Alignment::Horizontal::Left, Alignment::Vertical::Top });
+        GUIProperty<uint32_t>       textColor       = GUIProperty<uint32_t>(this, Colors::Black);
+        GUIProperty<CornerStyle>    cornerStyle     = GUIProperty<CornerStyle>(this, CornerStyle::Sharp);
+        GUIProperty<uint16_t>       cornerRadius    = GUIProperty<uint16_t>(this, 5);
+
+        // Anchor of this control
+        Direction anchor = Direction::None;
+    public:
+        /**
+         * Create new control with a given width, height, x and y position
+        */
+        Control(int w, int h, int x = 0, int y = 0);
+        /**
+         * Destructor
+        */
+        virtual ~Control();
+
+        /**
+         * Draw this control to a canvas
+         * 
+         * x_abs/y_abs: the coördinate of this control in absolute related to the canvas
+        */
+        virtual void DrawTo(Canvas* context, int x_abs, int y_abs);
+
+        // Add a control to the childs of this control, this will also set the parent property of the child to us.
+        virtual void AddChild(Control* child, bool focus = true);
+
+        // Remove a child from this control, does not delete the child!
+        virtual void RemoveChild(Control* child);
+
+        // Is this control focused?
+        virtual bool Focused();
+
+        // Force this control to be drawn aggain
+        virtual void ForcePaint();
+
+        // Return the visual portion of this control in aspect with the parent
+        virtual Rectangle GetParentsBounds(int xOffset, int yOffset);
+
+    /*/////////
+    // Events called by parent or context
+    *//////////
+    friend class Window;
+    friend class Context;
+    protected:
+        /**
+         * Called when mouse is down on control
+        */
+        virtual void OnMouseDown(int x_abs, int y_abs, uint8_t button);
+        /**
+         * Called when mouse is up on control
+        */
+        virtual void OnMouseUp(int x_abs, int y_abs, uint8_t button);
+        /**
+         * Called when mouse is moved on control
+        */
+        virtual void OnMouseMove(int prevX_abs, int prevY_abs, int newX_abs, int newY_abs);
+        /**
+         * Called when mouse enters control
+        */
+        virtual void OnMouseEnter(int prevX_abs, int prevY_abs, int newX_abs, int newY_abs);
+        /**
+         * Called when mouse leaves control
+        */
+        virtual void OnMouseLeave(int prevX_abs, int prevY_abs, int newX_abs, int newY_abs);
+        /**
+         * Called when key is held down
+        */
+        virtual void OnKeyDown(uint8_t key, KEYPACKET_FLAGS modifiers);
+        /**
+         * Called when key is held up
+        */
+        virtual void OnKeyUp(uint8_t key, KEYPACKET_FLAGS modifiers);
+        /**
+         * Called when control is resized
+        */
+        virtual void OnResize(Rectangle old);
+        /**
+         * Called when there is a scroll event on control
+        */
+        virtual void OnScroll(int32_t deltaZ, int x_abs, int y_abs);
+    };
+}
+
+#endif
\ No newline at end of file
diff --git a/lib/include/gui/widgets/label.h b/lib/include/gui/widgets/label.h
new file mode 100644
index 0000000..fada0df
--- /dev/null
+++ b/lib/include/gui/widgets/label.h
@@ -0,0 +1,25 @@
+#ifndef __LIBCACTUSOS__GUI__LABEL_H
+#define __LIBCACTUSOS__GUI__LABEL_H
+
+#include <gui/widgets/control.h>
+
+namespace LIBCactusOS
+{
+    class Label : public Control
+    {
+    public:
+        GUIProperty<char*> text = GUIProperty<char*>(this, 0);
+
+        /**
+         * Create a new label with a peice of text
+        */
+        Label(char* text = 0);
+
+        /**
+         * Draw this label
+        */
+        void DrawTo(Canvas* context, int x_abs, int y_abs) override;
+    };
+}
+
+#endif
\ No newline at end of file
diff --git a/lib/include/gui/widgets/listview.h b/lib/include/gui/widgets/listview.h
new file mode 100644
index 0000000..8e0a3a2
--- /dev/null
+++ b/lib/include/gui/widgets/listview.h
@@ -0,0 +1,50 @@
+#ifndef __LIBCACTUSOS__GUI__LISTVIEW_H
+#define __LIBCACTUSOS__GUI__LISTVIEW_H
+
+#include <gui/widgets/control.h>
+#include <imaging/image.h>
+#include <gui/gui.h>
+
+namespace LIBCactusOS
+{
+    class ListViewItem
+    {
+    public:
+        char* title;
+        Imaging::Image* icon;
+    public:
+        ListViewItem();
+        ~ListViewItem();
+    };
+
+    class ListView : public Control
+    {
+    private:
+        List<ListViewItem> items;
+    public:
+        ListView();
+        ~ListView();
+
+        /**
+         * Draw this button
+        */
+        void DrawTo(Canvas* context, int x_abs, int y_abs) override;
+
+    /*/////////
+    // Events
+    *//////////
+    friend class Window;
+    friend class Context;
+    protected:
+        /**
+         * Called when mouse is down on control
+        */
+        void OnMouseDown(int x_abs, int y_abs, uint8_t button) override;
+        /**
+         * Called when mouse is up on control
+        */
+        void OnMouseUp(int x_abs, int y_abs, uint8_t button) override;
+    };
+}
+
+#endif
\ No newline at end of file
diff --git a/lib/include/gui/widgets/scrollbar.h b/lib/include/gui/widgets/scrollbar.h
new file mode 100644
index 0000000..a2083e4
--- /dev/null
+++ b/lib/include/gui/widgets/scrollbar.h
@@ -0,0 +1,67 @@
+#ifndef __LIBCACTUSOS__GUI__SCROLLBAR_H
+#define __LIBCACTUSOS__GUI__SCROLLBAR_H
+
+#include <gui/widgets/control.h>
+#include <gui/property.h>
+#include <gui/events.h>
+#include <gui/colors.h>
+
+namespace LIBCactusOS
+{
+    // Different type of scrollbars
+    enum ScrollBarType
+    {
+        Horizontal,
+        Vertical
+    };
+
+    #define SCROLLBAR_DEFAULT_WIDTH  100
+    #define SCROLLBAR_DEFAULT_HEIGHT 20
+
+    // Represents an item where the user can drag a square to scroll something for example
+    // Childs are not drawn for logic reasons
+    class ScrollBar : public Control
+    {
+    public:
+        // Type of this scrollbar
+        GUIProperty<ScrollBarType> type = GUIProperty<ScrollBarType>(this, Vertical);
+        
+        // Minumum value, can be < 0
+        GUIProperty<int> minValue = GUIProperty<int>(this, 0);
+        
+        // Maximum value
+        GUIProperty<int> maxValue = GUIProperty<int>(this, 100);
+        
+        // Current value, usually changed by cursor
+        GUIProperty<int> value = GUIProperty<int>(this, 0);
+        
+        // Size of field where user can drag with the mouse in pixels
+        GUIProperty<int> dragSize = GUIProperty<int>(this, 20);
+
+        // Color of dragbar
+        GUIProperty<uint32_t> dragColor = GUIProperty<uint32_t>(this, 0xFF444444);
+
+        // The impact of the scrollbar on the value parameter
+        GUIProperty<double> scrollFactor = GUIProperty<double>(this, 2.0);
+    public:
+        // Create new scrollbar of some type
+        ScrollBar(ScrollBarType type, int min = 0, int max = 100, int dragSize = 20);
+
+        // Draw this scrollbar
+        void DrawTo(Canvas* context, int x_abs, int y_abs) override;
+
+        // Called when user scrolls mouse
+        void OnScroll(int32_t deltaZ, int x_abs, int y_abs) override;
+
+        // Called when mouse is down on this control
+        void OnMouseDown(int x_abs, int y_abs, uint8_t button) override;
+
+        // Called when mouse is up this control
+        void OnMouseUp(int x_abs, int y_abs, uint8_t button) override;
+
+        // Called when mouse is moved this control
+        void OnMouseMove(int prevX_abs, int prevY_abs, int newX_abs, int newY_abs) override;
+    };
+}
+
+#endif
\ No newline at end of file
diff --git a/lib/include/gui/widgets/scrollbox.h b/lib/include/gui/widgets/scrollbox.h
new file mode 100644
index 0000000..ca47672
--- /dev/null
+++ b/lib/include/gui/widgets/scrollbox.h
@@ -0,0 +1,22 @@
+#ifndef __LIBCACTUSOS__GUI__SCROLLBOX_H
+#define __LIBCACTUSOS__GUI__SCROLLBOX_H
+
+#include <gui/widgets/control.h>
+#include <gui/widgets/scrollbar.h>
+
+namespace LIBCactusOS
+{
+    class ScrollBox : public Control
+    {
+    public:
+        ScrollBar* scrollVertical = 0;
+        ScrollBar* scrollHorizontal = 0;
+    public:
+        ScrollBox();
+
+        // Draw this scrollbox
+        void DrawTo(Canvas* context, int x_abs, int y_abs) override;
+    };
+}
+
+#endif
\ No newline at end of file
diff --git a/lib/include/gui/widgets/slider.h b/lib/include/gui/widgets/slider.h
new file mode 100644
index 0000000..33491bc
--- /dev/null
+++ b/lib/include/gui/widgets/slider.h
@@ -0,0 +1,46 @@
+#ifndef __LIBCACTUSOS__GUI__SLIDER_H
+#define __LIBCACTUSOS__GUI__SLIDER_H
+
+#include <gui/widgets/control.h>
+#include <gui/property.h>
+#include <gui/events.h>
+#include <gui/colors.h>
+
+namespace LIBCactusOS
+{
+    class Slider : public Control
+    {
+    private:
+        bool mouseDown = false;
+    public:
+        GUIProperty<int> minValue = GUIProperty<int>(this, 0);
+        GUIProperty<int> maxValue = GUIProperty<int>(this, 0);
+        GUIProperty<int> position = GUIProperty<int>(this, 0);
+        GUIProperty<uint32_t> knobColor = GUIProperty<uint32_t>(this, Colors::Blue);
+        GUIProperty<int> knobSize = GUIProperty<int>(this, 10);
+
+        EventHandlerList<int> OnValueChanged;
+    public:    
+        Slider(int min = 0, int max = 100, int current = 50);
+
+        // Called when mouse is down on this control
+        void OnMouseDown(int x_abs, int y_abs, uint8_t button) override;
+
+        // Called when mouse is up this control
+        void OnMouseUp(int x_abs, int y_abs, uint8_t button) override;
+
+        // Called when mouse is moved this control
+        void OnMouseMove(int prevX_abs, int prevY_abs, int newX_abs, int newY_abs) override;
+
+        // Called when mouse enters control
+        void OnMouseEnter(int prevX_abs, int prevY_abs, int newX_abs, int newY_abs) override;
+        
+        // Called when mouse leaves control
+        void OnMouseLeave(int prevX_abs, int prevY_abs, int newX_abs, int newY_abs) override;
+
+        // Draw this slider
+        void DrawTo(Canvas* context, int x_abs, int y_abs) override;
+    };
+}
+
+#endif
\ No newline at end of file
diff --git a/lib/include/gui/widgets/window.h b/lib/include/gui/widgets/window.h
new file mode 100644
index 0000000..1468676
--- /dev/null
+++ b/lib/include/gui/widgets/window.h
@@ -0,0 +1,93 @@
+#ifndef __LIBCACTUSOS__WINDOW_H
+#define __LIBCACTUSOS__WINDOW_H
+
+#include <gui/widgets/control.h>
+#include <gui/widgets/button.h>
+#include <gui/context.h>
+#include <gui/property.h>
+
+namespace LIBCactusOS
+{
+    class Button;
+    
+    class Window : public Control
+    {
+    public:
+        GUIProperty<uint32_t> titleBarColor = GUIProperty<uint32_t>(this, 0xFF1E9AFF);
+        GUIProperty<uint16_t> titleBarHeight = GUIProperty<uint16_t>(this, 30);
+    private:
+        // Is the mouse down on the title bar?
+        GUIProperty<bool> titleBarMouseDown = GUIProperty<bool>(this, false);
+
+        // Remember where the mouse was held down for a smooth window drag
+        int mouseDownX = 0;
+        int mouseDownY = 0;
+
+        // Window Control Buttons
+        Button* closeButton = 0;
+
+        // Create the close button for this window
+        void CreateButtons();
+    public:
+        GUIProperty<char*> titleString = GUIProperty<char*>(this, 0);
+
+        /**
+         * In which context are we located?
+        */
+        Context* contextBase = 0;
+
+        /**
+         * Create a new window with a context as base
+        */
+        Window(Context* base);
+
+        /**
+         * Create a new window that request a context for itself to use
+        */
+        Window(int width, int height, int x, int y);
+        
+        /**
+         * Close this window, this can cause the application to exit
+        */
+        void Close(void* sender, MouseButtonArgs arg);
+        /**
+         * Close this window, this can cause the application to exit
+        */
+        void Close();
+
+        /**
+         * Draw this window to a canvas
+         * 
+         * x_abs/y_abs: the coördinate of this window in absolute related to the canvas
+        */
+        void DrawTo(Canvas* context, int x_abs, int y_abs) override;
+    friend class Context;
+    protected:
+        /**
+         * Called when mouse is down on window
+        */
+        void OnMouseDown(int x_abs, int y_abs, uint8_t button) override;
+        /**
+         * Called when mouse is up on window
+        */
+        void OnMouseUp(int x_abs, int y_abs, uint8_t button) override;
+        /**
+         * Called when mouse is moved on window
+        */
+        void OnMouseMove(int prevX_abs, int prevY_abs, int newX_abs, int newY_abs) override;
+        /**
+         * Called when Window is resized
+        */
+        void OnResize(Rectangle old) override;
+        /**
+         * Called when key is held down
+        */
+        void OnKeyDown(uint8_t key, KEYPACKET_FLAGS modifiers) override;
+        /**
+         * Called when there is a scroll event on window
+        */
+        void OnScroll(int32_t deltaZ, int x_abs, int y_abs) override;
+    };
+}
+
+#endif
\ No newline at end of file
diff --git a/lib/include/heap.h b/lib/include/heap.h
new file mode 100644
index 0000000..003c426
--- /dev/null
+++ b/lib/include/heap.h
@@ -0,0 +1,47 @@
+#ifndef __CACTUSOSLIB__HEAP_H
+#define __CACTUSOSLIB__HEAP_H
+
+#include <types.h>
+
+namespace LIBCactusOS
+{
+    #ifndef align_up
+    #define align_up(num, align) \
+        (((num) + ((align) - 1)) & ~((align) - 1))
+    #endif
+
+    uint32_t pageRoundUp(uint32_t address);
+    uint32_t pageRoundDown(uint32_t address);
+
+    #define HEAP_INCREASE_SIZE 10_MB
+
+    struct MemoryHeader
+    {
+        MemoryHeader* next;
+        MemoryHeader* prev;
+        bool allocated;
+        uint32_t size;
+    } __attribute__((packed));
+
+    class UserHeap
+    {
+    private:
+        static uint32_t startAddress;
+        static uint32_t endAddress;
+        static uint32_t maxAddress;
+
+        static MemoryHeader* firstHeader;
+
+    public:
+        static void Initialize();
+        static void PrintMemoryLayout();
+
+        static void* Malloc(uint32_t size);
+        static void Free(void* ptr);
+
+        static void* alignedMalloc(uint32_t size, uint32_t align);
+        static void allignedFree(void* ptr);
+    };
+}
+
+#endif
\ No newline at end of file
diff --git a/lib/include/imaging/bmpformat.h b/lib/include/imaging/bmpformat.h
new file mode 100644
index 0000000..8e7d31d
--- /dev/null
+++ b/lib/include/imaging/bmpformat.h
@@ -0,0 +1,48 @@
+#ifndef __CACTUSOSLIB__IMAGING__BMPIMAGE_H
+#define __CACTUSOSLIB__IMAGING__BMPIMAGE_H
+
+#include <imaging/image.h>
+
+namespace LIBCactusOS
+{
+    namespace Imaging
+    {
+        struct BMPFileHeader {
+            uint16_t fileType;
+            uint32_t fileSize;
+            uint16_t Reserved1;
+            uint16_t Reserved2;
+            uint32_t dataOffset;
+        } __attribute__((packed));
+
+        struct BMPInfoHeader {
+            uint32_t headerSize;
+            int32_t Width;
+            int32_t Height;
+            uint16_t Planes;
+            uint16_t BitCount;
+            uint32_t Compression;
+            uint32_t SizeImage;
+            int32_t XPelsPerMeter;
+            int32_t YPelsPerMeter;
+            uint32_t ClrUsed;
+            uint32_t ClrImportant;
+        } __attribute__((packed));
+
+        struct BMPColorHeader {
+            uint32_t redMask;
+            uint32_t greenMask;
+            uint32_t blueMask;
+            uint32_t alphaMask;
+            uint32_t colorSpaceType;
+            uint32_t unused[16];
+        } __attribute__((packed));
+
+        // Convert image file into image buffer
+        Image* ConvertBMP(const char* filepath);
+        // Create image from array of bytes in bmp format
+        Image* ConvertBMPRaw(const uint8_t* rawData);   
+    }
+}
+
+#endif
\ No newline at end of file
diff --git a/lib/include/imaging/image.h b/lib/include/imaging/image.h
new file mode 100644
index 0000000..5357579
--- /dev/null
+++ b/lib/include/imaging/image.h
@@ -0,0 +1,62 @@
+#ifndef __CACTUSOSLIB__IMAGING_IMAGE_H
+#define __CACTUSOSLIB__IMAGING_IMAGE_H
+
+#include <types.h>
+#include <gui/canvas.h>
+
+namespace LIBCactusOS
+{
+    namespace Imaging
+    {
+        // Enable alpha for bilinear image scaling or not?
+        #define BILINEAR_ALPHA 1
+
+        enum ResizeMethod
+        {
+            NearestNeighbor,
+            Bilinear
+        };
+
+        class Image
+        {
+        private:
+            int width = 0;
+            int height = 0;
+            Canvas* canvas = 0;
+
+            uint32_t* buffer = 0;
+        public:
+            // Create new image using a width and height
+            Image(const int width, const int height);
+            // Destructor
+            ~Image();
+
+            // Generate a canvas for this image and return it
+            // It will only get generated once for each image and will get destroyed automatically
+            Canvas* GetCanvas();
+
+            // Get width of image
+            int GetWidth();
+
+            // Get height of image
+            int GetHeight();
+
+            // Receive pointer to raw buffer
+            uint32_t* GetBufferPtr();
+
+            // Draw this image directly to a canvas
+            void DrawTo(Canvas* target, int x = 0, int y = 0);
+
+            // Create image from a file present on disk
+            static Image* CreateFromFile(const char* filepath, const char* ext = 0);
+
+            // Resize source image and return result
+            static Image* Resize(Image* source, int newWidth, int newHeight, ResizeMethod method = NearestNeighbor);
+        private:
+            static Image* ResizeNearestNeighbor(Image* source, int newWidth, int newHeight);
+            static Image* ResizeBilinear(Image* source, int newWidth, int newHeight);
+        };
+    }
+}
+
+#endif
\ No newline at end of file
diff --git a/lib/include/imaging/jpeg_decoder.h b/lib/include/imaging/jpeg_decoder.h
new file mode 100644
index 0000000..697505b
--- /dev/null
+++ b/lib/include/imaging/jpeg_decoder.h
@@ -0,0 +1,678 @@
+#ifndef INCLUDED_JPEG_DECODER_H
+#define INCLUDED_JPEG_DECODER_H
+
+// This is a cosmetic restructing and port to C++ class of 'NanoJPEG', found
+// at http://keyj.s2000.ws/?p=137. It's been made somewhat thread safe in that
+// all context information is pulled into an object, rather than being global
+// as the original was. Other than that, the original is superior in
+// configurability, comments, cleanliness, portability, etc. and should be
+// preferred. The only other possible benefit this version can claim is that
+// it's crammed into one header file.
+//
+// Scott Graham <scott.jpegdecoder@h4ck3r.net>
+//
+// The original license follows:
+//
+// NanoJPEG -- KeyJ's Tiny Baseline JPEG Decoder
+// version 1.0 (2009-04-29)
+// by Martin J. Fiedler <martin.fiedler@gmx.net>
+//
+// This software is published under the terms of KeyJ's Research License,
+// version 0.2. Usage of this software is subject to the following conditions:
+// 0. There's no warranty whatsoever. The author(s) of this software can not
+//    be held liable for any damages that occur when using this software.
+// 1. This software may be used freely for both non-commercial and commercial
+//    purposes.
+// 2. This software may be redistributed freely as long as no fees are charged
+//    for the distribution and this license information is included.
+// 3. This software may be modified freely except for this license information,
+//    which must not be changed in any way.
+// 4. If anything other than configuration, indentation or comments have been
+//    altered in the code, the original author(s) must receive a copy of the
+//    modified code.
+
+#include <string.h>
+#include <types.h>
+
+namespace Jpeg
+{
+    class Decoder
+    {
+    public:
+        enum DecodeResult
+        {
+            OK = 0,        // decoding successful
+            NotAJpeg,      // not a JPEG file
+            Unsupported,   // unsupported format
+            OutOfMemory,   // out of memory
+            InternalError, // internal error
+            SyntaxError,   // syntax error
+            Internal_Finished, // used internally, will never be reported
+        };
+
+        // decode the raw data. object is very large, and probably shouldn't
+        // go on the stack.
+        Decoder(const unsigned char* data, uint32_t size, void *(*allocFunc)(uint32_t), void (*freeFunc)(void*));
+        ~Decoder();
+
+        // the result of decode
+        DecodeResult GetResult() const;
+
+        // all remaining functions below are only valid if GetResult() == OK.
+
+        int GetWidth() const;
+        int GetHeight() const;
+        bool IsColor() const;
+
+        // if IsColor() then 24bit as R,G,B bytes
+        // else 8 bit luminance
+        unsigned char* GetImage() const;
+
+        // in bytes
+        uint32_t GetImageSize() const;
+        
+        //////////////////////////////////////////////////////////////////////
+        //////////////////////////////////////////////////////////////////////
+        //////////////////////////////////////////////////////////////////////
+        //
+        // Implementation follows
+        //
+        //////////////////////////////////////////////////////////////////////
+        //////////////////////////////////////////////////////////////////////
+        //////////////////////////////////////////////////////////////////////
+
+    private:
+        struct VlcCode {
+            unsigned char bits, code;
+        };
+
+        struct Component {
+            int cid;
+            int ssx, ssy;
+            int width, height;
+            int stride;
+            int qtsel;
+            int actabsel, dctabsel;
+            int dcpred;
+            unsigned char *pixels;
+        };
+
+        struct Context {
+            DecodeResult error;
+            const unsigned char *pos;
+            int size;
+            int length;
+            int width, height;
+            int mbwidth, mbheight;
+            int mbsizex, mbsizey;
+            int ncomp;
+            Component comp[3];
+            int qtused, qtavail;
+            unsigned char qtab[4][64];
+            VlcCode vlctab[4][65536];
+            int buf, bufbits;
+            int block[64];
+            int rstinterval;
+            unsigned char *rgb;
+        };
+
+        Context ctx;
+        char ZZ[64];
+        void *(*AllocMem)(uint32_t);
+        void (*FreeMem)(void*);
+
+
+        inline unsigned char _Clip(const int x) {
+            return (x < 0) ? 0 : ((x > 0xFF) ? 0xFF : (unsigned char) x);
+        }
+
+        enum {
+            W1 = 2841,
+            W2 = 2676,
+            W3 = 2408,
+            W5 = 1609,
+            W6 = 1108,
+            W7 = 565,
+        };
+
+        inline void _RowIDCT(int* blk) {
+            int x0, x1, x2, x3, x4, x5, x6, x7, x8;
+            if (!((x1 = blk[4] << 11)
+                | (x2 = blk[6])
+                | (x3 = blk[2])
+                | (x4 = blk[1])
+                | (x5 = blk[7])
+                | (x6 = blk[5])
+                | (x7 = blk[3])))
+            {
+                blk[0] = blk[1] = blk[2] = blk[3] = blk[4] = blk[5] = blk[6] = blk[7] = blk[0] << 3;
+                return;
+            }
+            x0 = (blk[0] << 11) + 128;
+            x8 = W7 * (x4 + x5);
+            x4 = x8 + (W1 - W7) * x4;
+            x5 = x8 - (W1 + W7) * x5;
+            x8 = W3 * (x6 + x7);
+            x6 = x8 - (W3 - W5) * x6;
+            x7 = x8 - (W3 + W5) * x7;
+            x8 = x0 + x1;
+            x0 -= x1;
+            x1 = W6 * (x3 + x2);
+            x2 = x1 - (W2 + W6) * x2;
+            x3 = x1 + (W2 - W6) * x3;
+            x1 = x4 + x6;
+            x4 -= x6;
+            x6 = x5 + x7;
+            x5 -= x7;
+            x7 = x8 + x3;
+            x8 -= x3;
+            x3 = x0 + x2;
+            x0 -= x2;
+            x2 = (181 * (x4 + x5) + 128) >> 8;
+            x4 = (181 * (x4 - x5) + 128) >> 8;
+            blk[0] = (x7 + x1) >> 8;
+            blk[1] = (x3 + x2) >> 8;
+            blk[2] = (x0 + x4) >> 8;
+            blk[3] = (x8 + x6) >> 8;
+            blk[4] = (x8 - x6) >> 8;
+            blk[5] = (x0 - x4) >> 8;
+            blk[6] = (x3 - x2) >> 8;
+            blk[7] = (x7 - x1) >> 8;
+        }
+
+        inline void _ColIDCT(const int* blk, unsigned char *out, int stride) {
+            int x0, x1, x2, x3, x4, x5, x6, x7, x8;
+            if (!((x1 = blk[8*4] << 8)
+                | (x2 = blk[8*6])
+                | (x3 = blk[8*2])
+                | (x4 = blk[8*1])
+                | (x5 = blk[8*7])
+                | (x6 = blk[8*5])
+                | (x7 = blk[8*3])))
+            {
+                x1 = _Clip(((blk[0] + 32) >> 6) + 128);
+                for (x0 = 8;  x0;  --x0) {
+                    *out = (unsigned char) x1;
+                    out += stride;
+                }
+                return;
+            }
+            x0 = (blk[0] << 8) + 8192;
+            x8 = W7 * (x4 + x5) + 4;
+            x4 = (x8 + (W1 - W7) * x4) >> 3;
+            x5 = (x8 - (W1 + W7) * x5) >> 3;
+            x8 = W3 * (x6 + x7) + 4;
+            x6 = (x8 - (W3 - W5) * x6) >> 3;
+            x7 = (x8 - (W3 + W5) * x7) >> 3;
+            x8 = x0 + x1;
+            x0 -= x1;
+            x1 = W6 * (x3 + x2) + 4;
+            x2 = (x1 - (W2 + W6) * x2) >> 3;
+            x3 = (x1 + (W2 - W6) * x3) >> 3;
+            x1 = x4 + x6;
+            x4 -= x6;
+            x6 = x5 + x7;
+            x5 -= x7;
+            x7 = x8 + x3;
+            x8 -= x3;
+            x3 = x0 + x2;
+            x0 -= x2;
+            x2 = (181 * (x4 + x5) + 128) >> 8;
+            x4 = (181 * (x4 - x5) + 128) >> 8;
+            *out = _Clip(((x7 + x1) >> 14) + 128);  out += stride;
+            *out = _Clip(((x3 + x2) >> 14) + 128);  out += stride;
+            *out = _Clip(((x0 + x4) >> 14) + 128);  out += stride;
+            *out = _Clip(((x8 + x6) >> 14) + 128);  out += stride;
+            *out = _Clip(((x8 - x6) >> 14) + 128);  out += stride;
+            *out = _Clip(((x0 - x4) >> 14) + 128);  out += stride;
+            *out = _Clip(((x3 - x2) >> 14) + 128);  out += stride;
+            *out = _Clip(((x7 - x1) >> 14) + 128);
+        }
+
+        #define JPEG_DECODER_THROW(e) do { ctx.error = e; return; } while (0)
+
+        inline int _ShowBits(int bits) {
+            unsigned char newbyte;
+            if (!bits) return 0;
+            while (ctx.bufbits < bits) {
+                if (ctx.size <= 0) {
+                    ctx.buf = (ctx.buf << 8) | 0xFF;
+                    ctx.bufbits += 8;
+                    continue;
+                }
+                newbyte = *ctx.pos++;
+                ctx.size--;
+                ctx.bufbits += 8;
+                ctx.buf = (ctx.buf << 8) | newbyte;
+                if (newbyte == 0xFF) {
+                    if (ctx.size) {
+                        unsigned char marker = *ctx.pos++;
+                        ctx.size--;
+                        switch (marker) {
+                            case 0:    break;
+                            case 0xD9: ctx.size = 0; break;
+                            default:
+                                if ((marker & 0xF8) != 0xD0)
+                                    ctx.error = SyntaxError;
+                                else {
+                                    ctx.buf = (ctx.buf << 8) | marker;
+                                    ctx.bufbits += 8;
+                                }
+                        }
+                    } else
+                        ctx.error = SyntaxError;
+                }
+            }
+            return (ctx.buf >> (ctx.bufbits - bits)) & ((1 << bits) - 1);
+        }
+
+        inline void _SkipBits(int bits) {
+            if (ctx.bufbits < bits)
+                (void) _ShowBits(bits);
+            ctx.bufbits -= bits;
+        }
+
+        inline int _GetBits(int bits) {
+            int res = _ShowBits(bits);
+            _SkipBits(bits);
+            return res;
+        }
+
+        inline void _ByteAlign(void) {
+            ctx.bufbits &= 0xF8;
+        }
+
+        inline void _Skip(int count) {
+            ctx.pos += count;
+            ctx.size -= count;
+            ctx.length -= count;
+            if (ctx.size < 0) ctx.error = SyntaxError;
+        }
+
+        inline unsigned short _Decode16(const unsigned char *pos) {
+            return (pos[0] << 8) | pos[1];
+        }
+
+        inline void _DecodeLength(void) {
+            if (ctx.size < 2) JPEG_DECODER_THROW(SyntaxError);
+            ctx.length = _Decode16(ctx.pos);
+            if (ctx.length > ctx.size) JPEG_DECODER_THROW(SyntaxError);
+            _Skip(2);
+        }
+
+        inline void _SkipMarker(void) {
+            _DecodeLength();
+            _Skip(ctx.length);
+        }
+
+        inline void _DecodeSOF(void) {
+            int i, ssxmax = 0, ssymax = 0;
+            Component* c;
+            _DecodeLength();
+            if (ctx.length < 9) JPEG_DECODER_THROW(SyntaxError);
+            if (ctx.pos[0] != 8) JPEG_DECODER_THROW(Unsupported);
+            ctx.height = _Decode16(ctx.pos+1);
+            ctx.width = _Decode16(ctx.pos+3);
+            ctx.ncomp = ctx.pos[5];
+            _Skip(6);
+            switch (ctx.ncomp) {
+                case 1:
+                case 3:
+                    break;
+                default:
+                    JPEG_DECODER_THROW(Unsupported);
+            }
+            if (ctx.length < (ctx.ncomp * 3)) JPEG_DECODER_THROW(SyntaxError);
+            for (i = 0, c = ctx.comp;  i < ctx.ncomp;  ++i, ++c) {
+                c->cid = ctx.pos[0];
+                if (!(c->ssx = ctx.pos[1] >> 4)) JPEG_DECODER_THROW(SyntaxError);
+                if (c->ssx & (c->ssx - 1)) JPEG_DECODER_THROW(Unsupported);  // non-power of two
+                if (!(c->ssy = ctx.pos[1] & 15)) JPEG_DECODER_THROW(SyntaxError);
+                if (c->ssy & (c->ssy - 1)) JPEG_DECODER_THROW(Unsupported);  // non-power of two
+                if ((c->qtsel = ctx.pos[2]) & 0xFC) JPEG_DECODER_THROW(SyntaxError);
+                _Skip(3);
+                ctx.qtused |= 1 << c->qtsel;
+                if (c->ssx > ssxmax) ssxmax = c->ssx;
+                if (c->ssy > ssymax) ssymax = c->ssy;
+            }
+            ctx.mbsizex = ssxmax << 3;
+            ctx.mbsizey = ssymax << 3;
+            ctx.mbwidth = (ctx.width + ctx.mbsizex - 1) / ctx.mbsizex;
+            ctx.mbheight = (ctx.height + ctx.mbsizey - 1) / ctx.mbsizey;
+            for (i = 0, c = ctx.comp;  i < ctx.ncomp;  ++i, ++c) {
+                c->width = (ctx.width * c->ssx + ssxmax - 1) / ssxmax;
+                c->stride = (c->width + 7) & 0x7FFFFFF8;
+                c->height = (ctx.height * c->ssy + ssymax - 1) / ssymax;
+                c->stride = ctx.mbwidth * ctx.mbsizex * c->ssx / ssxmax;
+                if (((c->width < 3) && (c->ssx != ssxmax)) || ((c->height < 3) && (c->ssy != ssymax))) JPEG_DECODER_THROW(Unsupported);
+                if (!(c->pixels = (unsigned char*)AllocMem(c->stride * (ctx.mbheight * ctx.mbsizey * c->ssy / ssymax)))) JPEG_DECODER_THROW(OutOfMemory);
+            }
+            if (ctx.ncomp == 3) {
+                ctx.rgb = (unsigned char*)AllocMem(ctx.width * ctx.height * ctx.ncomp);
+                if (!ctx.rgb) JPEG_DECODER_THROW(OutOfMemory);
+            }
+            _Skip(ctx.length);
+        }
+
+        inline void _DecodeDHT(void) {
+            int codelen, currcnt, remain, spread, i, j;
+            VlcCode *vlc;
+            unsigned char counts[16];
+            _DecodeLength();
+            while (ctx.length >= 17) {
+                i = ctx.pos[0];
+                if (i & 0xEC) JPEG_DECODER_THROW(SyntaxError);
+                if (i & 0x02) JPEG_DECODER_THROW(Unsupported);
+                i = (i | (i >> 3)) & 3;  // combined DC/AC + tableid value
+                for (codelen = 1;  codelen <= 16;  ++codelen)
+                    counts[codelen - 1] = ctx.pos[codelen];
+                _Skip(17);
+                vlc = &ctx.vlctab[i][0];
+                remain = spread = 65536;
+                for (codelen = 1;  codelen <= 16;  ++codelen) {
+                    spread >>= 1;
+                    currcnt = counts[codelen - 1];
+                    if (!currcnt) continue;
+                    if (ctx.length < currcnt) JPEG_DECODER_THROW(SyntaxError);
+                    remain -= currcnt << (16 - codelen);
+                    if (remain < 0) JPEG_DECODER_THROW(SyntaxError);
+                    for (i = 0;  i < currcnt;  ++i) {
+                        register unsigned char code = ctx.pos[i];
+                        for (j = spread;  j;  --j) {
+                            vlc->bits = (unsigned char) codelen;
+                            vlc->code = code;
+                            ++vlc;
+                        }
+                    }
+                    _Skip(currcnt);
+                }
+                while (remain--) {
+                    vlc->bits = 0;
+                    ++vlc;
+                }
+            }
+            if (ctx.length) JPEG_DECODER_THROW(SyntaxError);
+        }
+
+        inline void _DecodeDQT(void) {
+            int i;
+            unsigned char *t;
+            _DecodeLength();
+            while (ctx.length >= 65) {
+                i = ctx.pos[0];
+                if (i & 0xFC) JPEG_DECODER_THROW(SyntaxError);
+                ctx.qtavail |= 1 << i;
+                t = &ctx.qtab[i][0];
+                for (i = 0;  i < 64;  ++i)
+                    t[i] = ctx.pos[i + 1];
+                _Skip(65);
+            }
+            if (ctx.length) JPEG_DECODER_THROW(SyntaxError);
+        }
+
+        inline void _DecodeDRI(void) {
+            _DecodeLength();
+            if (ctx.length < 2) JPEG_DECODER_THROW(SyntaxError);
+            ctx.rstinterval = _Decode16(ctx.pos);
+            _Skip(ctx.length);
+        }
+
+        inline int _GetVLC(VlcCode* vlc, unsigned char* code) {
+            int value = _ShowBits(16);
+            int bits = vlc[value].bits;
+            if (!bits) { ctx.error = SyntaxError; return 0; }
+            _SkipBits(bits);
+            value = vlc[value].code;
+            if (code) *code = (unsigned char) value;
+            bits = value & 15;
+            if (!bits) return 0;
+            value = _GetBits(bits);
+            if (value < (1 << (bits - 1)))
+                value += ((-1) << bits) + 1;
+            return value;
+        }
+
+        inline void _DecodeBlock(Component* c, unsigned char* out) {
+            unsigned char code;
+            int value, coef = 0;
+            memset(ctx.block, 0, sizeof(ctx.block));
+            c->dcpred += _GetVLC(&ctx.vlctab[c->dctabsel][0], NULL);
+            ctx.block[0] = (c->dcpred) * ctx.qtab[c->qtsel][0];
+            do {
+                value = _GetVLC(&ctx.vlctab[c->actabsel][0], &code);
+                if (!code) break;  // EOB
+                if (!(code & 0x0F) && (code != 0xF0)) JPEG_DECODER_THROW(SyntaxError);
+                coef += (code >> 4) + 1;
+                if (coef > 63) JPEG_DECODER_THROW(SyntaxError);
+                ctx.block[(int) ZZ[coef]] = value * ctx.qtab[c->qtsel][coef];
+            } while (coef < 63);
+            for (coef = 0;  coef < 64;  coef += 8)
+                _RowIDCT(&ctx.block[coef]);
+            for (coef = 0;  coef < 8;  ++coef)
+                _ColIDCT(&ctx.block[coef], &out[coef], c->stride);
+        }
+
+        inline void _DecodeScan(void) {
+            int i, mbx, mby, sbx, sby;
+            int rstcount = ctx.rstinterval, nextrst = 0;
+            Component* c;
+            _DecodeLength();
+            if (ctx.length < (4 + 2 * ctx.ncomp)) JPEG_DECODER_THROW(SyntaxError);
+            if (ctx.pos[0] != ctx.ncomp) JPEG_DECODER_THROW(Unsupported);
+            _Skip(1);
+            for (i = 0, c = ctx.comp;  i < ctx.ncomp;  ++i, ++c) {
+                if (ctx.pos[0] != c->cid) JPEG_DECODER_THROW(SyntaxError);
+                if (ctx.pos[1] & 0xEE) JPEG_DECODER_THROW(SyntaxError);
+                c->dctabsel = ctx.pos[1] >> 4;
+                c->actabsel = (ctx.pos[1] & 1) | 2;
+                _Skip(2);
+            }
+            if (ctx.pos[0] || (ctx.pos[1] != 63) || ctx.pos[2]) JPEG_DECODER_THROW(Unsupported);
+            _Skip(ctx.length);
+            for (mby = 0;  mby < ctx.mbheight;  ++mby)
+                for (mbx = 0;  mbx < ctx.mbwidth;  ++mbx) {
+                    for (i = 0, c = ctx.comp;  i < ctx.ncomp;  ++i, ++c)
+                        for (sby = 0;  sby < c->ssy;  ++sby)
+                            for (sbx = 0;  sbx < c->ssx;  ++sbx) {
+                                _DecodeBlock(c, &c->pixels[((mby * c->ssy + sby) * c->stride + mbx * c->ssx + sbx) << 3]);
+                                if (ctx.error)
+                                return;
+                            }
+                    if (ctx.rstinterval && !(--rstcount)) {
+                        _ByteAlign();
+                        i = _GetBits(16);
+                        if (((i & 0xFFF8) != 0xFFD0) || ((i & 7) != nextrst)) JPEG_DECODER_THROW(SyntaxError);
+                        nextrst = (nextrst + 1) & 7;
+                        rstcount = ctx.rstinterval;
+                        for (i = 0;  i < 3;  ++i)
+                            ctx.comp[i].dcpred = 0;
+                    }
+                }
+            ctx.error = Internal_Finished;
+        }
+
+        enum {
+            CF4A = (-9),
+            CF4B = (111),
+            CF4C = (29),
+            CF4D = (-3),
+            CF3A = (28),
+            CF3B = (109),
+            CF3C = (-9),
+            CF3X = (104),
+            CF3Y = (27),
+            CF3Z = (-3),
+            CF2A = (139),
+            CF2B = (-11),
+        };
+
+        inline unsigned char CF(const int x) {
+            return _Clip((x + 64) >> 7);
+        }
+
+        inline void _UpsampleH(Component* c) {
+            const int xmax = c->width - 3;
+            unsigned char *out, *lin, *lout;
+            int x, y;
+            out = (unsigned char*)AllocMem((c->width * c->height) << 1);
+            if (!out) JPEG_DECODER_THROW(OutOfMemory);
+            lin = c->pixels;
+            lout = out;
+            for (y = c->height;  y;  --y) {
+                lout[0] = CF(CF2A * lin[0] + CF2B * lin[1]);
+                lout[1] = CF(CF3X * lin[0] + CF3Y * lin[1] + CF3Z * lin[2]);
+                lout[2] = CF(CF3A * lin[0] + CF3B * lin[1] + CF3C * lin[2]);
+                for (x = 0;  x < xmax;  ++x) {
+                    lout[(x << 1) + 3] = CF(CF4A * lin[x] + CF4B * lin[x + 1] + CF4C * lin[x + 2] + CF4D * lin[x + 3]);
+                    lout[(x << 1) + 4] = CF(CF4D * lin[x] + CF4C * lin[x + 1] + CF4B * lin[x + 2] + CF4A * lin[x + 3]);
+                }
+                lin += c->stride;
+                lout += c->width << 1;
+                lout[-3] = CF(CF3A * lin[-1] + CF3B * lin[-2] + CF3C * lin[-3]);
+                lout[-2] = CF(CF3X * lin[-1] + CF3Y * lin[-2] + CF3Z * lin[-3]);
+                lout[-1] = CF(CF2A * lin[-1] + CF2B * lin[-2]);
+            }
+            c->width <<= 1;
+            c->stride = c->width;
+            FreeMem(c->pixels);
+            c->pixels = out;
+        }
+
+        inline void _UpsampleV(Component* c) {
+            const int w = c->width, s1 = c->stride, s2 = s1 + s1;
+            unsigned char *out, *cin, *cout;
+            int x, y;
+            out = (unsigned char*)AllocMem((c->width * c->height) << 1);
+            if (!out) JPEG_DECODER_THROW(OutOfMemory);
+            for (x = 0;  x < w;  ++x) {
+                cin = &c->pixels[x];
+                cout = &out[x];
+                *cout = CF(CF2A * cin[0] + CF2B * cin[s1]);  cout += w;
+                *cout = CF(CF3X * cin[0] + CF3Y * cin[s1] + CF3Z * cin[s2]);  cout += w;
+                *cout = CF(CF3A * cin[0] + CF3B * cin[s1] + CF3C * cin[s2]);  cout += w;
+                cin += s1;
+                for (y = c->height - 3;  y;  --y) {
+                    *cout = CF(CF4A * cin[-s1] + CF4B * cin[0] + CF4C * cin[s1] + CF4D * cin[s2]);  cout += w;
+                    *cout = CF(CF4D * cin[-s1] + CF4C * cin[0] + CF4B * cin[s1] + CF4A * cin[s2]);  cout += w;
+                    cin += s1;
+                }
+                cin += s1;
+                *cout = CF(CF3A * cin[0] + CF3B * cin[-s1] + CF3C * cin[-s2]);  cout += w;
+                *cout = CF(CF3X * cin[0] + CF3Y * cin[-s1] + CF3Z * cin[-s2]);  cout += w;
+                *cout = CF(CF2A * cin[0] + CF2B * cin[-s1]);
+            }
+            c->height <<= 1;
+            c->stride = c->width;
+            FreeMem(c->pixels);
+            c->pixels = out;
+        }
+
+        inline void _Convert() {
+            int i;
+            Component* c;
+            for (i = 0, c = ctx.comp;  i < ctx.ncomp;  ++i, ++c) {
+                while ((c->width < ctx.width) || (c->height < ctx.height)) {
+                    if (c->width < ctx.width) _UpsampleH(c);
+                    if (ctx.error) return;
+                    if (c->height < ctx.height) _UpsampleV(c);
+                    if (ctx.error) return;
+                }
+                if ((c->width < ctx.width) || (c->height < ctx.height)) JPEG_DECODER_THROW(InternalError);
+            }
+            if (ctx.ncomp == 3) {
+                // convert to RGB
+                int x, yy;
+                unsigned char *prgb = ctx.rgb;
+                const unsigned char *py  = ctx.comp[0].pixels;
+                const unsigned char *pcb = ctx.comp[1].pixels;
+                const unsigned char *pcr = ctx.comp[2].pixels;
+                for (yy = ctx.height;  yy;  --yy) {
+                    for (x = 0;  x < ctx.width;  ++x) {
+                        register int y = py[x] << 8;
+                        register int cb = pcb[x] - 128;
+                        register int cr = pcr[x] - 128;
+                        *prgb++ = _Clip((y            + 359 * cr + 128) >> 8);
+                        *prgb++ = _Clip((y -  88 * cb - 183 * cr + 128) >> 8);
+                        *prgb++ = _Clip((y + 454 * cb            + 128) >> 8);
+                    }
+                    py += ctx.comp[0].stride;
+                    pcb += ctx.comp[1].stride;
+                    pcr += ctx.comp[2].stride;
+                }
+            } else if (ctx.comp[0].width != ctx.comp[0].stride) {
+                // grayscale -> only remove stride
+                unsigned char *pin = &ctx.comp[0].pixels[ctx.comp[0].stride];
+                unsigned char *pout = &ctx.comp[0].pixels[ctx.comp[0].width];
+                int y;
+                for (y = ctx.comp[0].height - 1;  y;  --y) {
+                    memcpy(pout, pin, ctx.comp[0].width);
+                    pin += ctx.comp[0].stride;
+                    pout += ctx.comp[0].width;
+                }
+                ctx.comp[0].stride = ctx.comp[0].width;
+            }
+        }
+
+        DecodeResult _Decode(const unsigned char* jpeg, const int size) {
+            ctx.pos = (const unsigned char*) jpeg;
+            ctx.size = size & 0x7FFFFFFF;
+            if (ctx.size < 2) return NotAJpeg;
+            if ((ctx.pos[0] ^ 0xFF) | (ctx.pos[1] ^ 0xD8)) return NotAJpeg;
+            _Skip(2);
+            while (!ctx.error) {
+                if ((ctx.size < 2) || (ctx.pos[0] != 0xFF)) return SyntaxError;
+                _Skip(2);
+                switch (ctx.pos[-1]) {
+                    case 0xC0: _DecodeSOF();  break;
+                    case 0xC4: _DecodeDHT();  break;
+                    case 0xDB: _DecodeDQT();  break;
+                    case 0xDD: _DecodeDRI();  break;
+                    case 0xDA: _DecodeScan(); break;
+                    case 0xFE: _SkipMarker(); break;
+                    default:
+                        if ((ctx.pos[-1] & 0xF0) == 0xE0)
+                            _SkipMarker();
+                        else
+                            return Unsupported;
+                }
+            }
+            if (ctx.error != Internal_Finished) return ctx.error;
+            ctx.error = OK;
+            _Convert();
+            return ctx.error;
+        }
+    };
+
+
+inline Decoder::Decoder(const unsigned char* data, uint32_t size, void *(*allocFunc)(uint32_t), void (*freeFunc)(void*))
+    : AllocMem(allocFunc)
+    , FreeMem(freeFunc)
+{
+    // should be static data, but this keeps us as a header
+    char temp[64] = { 0, 1, 8, 16, 9, 2, 3, 10, 17, 24, 32, 25, 18,
+        11, 4, 5, 12, 19, 26, 33, 40, 48, 41, 34, 27, 20, 13, 6, 7, 14, 21, 28, 35,
+        42, 49, 56, 57, 50, 43, 36, 29, 22, 15, 23, 30, 37, 44, 51, 58, 59, 52, 45,
+        38, 31, 39, 46, 53, 60, 61, 54, 47, 55, 62, 63 };
+    memcpy(ZZ, temp, sizeof(ZZ));
+    memset(&ctx, 0, sizeof(Context));
+    _Decode(data, size);
+}
+
+inline Decoder::DecodeResult Decoder::GetResult() const { return ctx.error; }
+inline int Decoder::GetWidth() const { return ctx.width; }
+inline int Decoder::GetHeight() const { return ctx.height; }
+inline bool Decoder::IsColor() const { return ctx.ncomp != 1; }
+inline unsigned char* Decoder::GetImage() const { return (ctx.ncomp == 1) ? ctx.comp[0].pixels : ctx.rgb; }
+inline uint32_t Decoder::GetImageSize(void) const { return ctx.width * ctx.height * ctx.ncomp; }
+
+inline Decoder::~Decoder()
+{
+    int i;
+    for (i = 0;  i < 3;  ++i)
+        if (ctx.comp[i].pixels) FreeMem((void*) ctx.comp[i].pixels);
+    if (ctx.rgb) FreeMem((void*) ctx.rgb);
+}
+
+}
+
+#endif
diff --git a/lib/include/imaging/pngformat.h b/lib/include/imaging/pngformat.h
new file mode 100644
index 0000000..bb7ded0
--- /dev/null
+++ b/lib/include/imaging/pngformat.h
@@ -0,0 +1,146 @@
+#ifndef __CACTUSOSLIB__IMAGING__PNGIMAGE_H
+#define __CACTUSOSLIB__IMAGING__PNGIMAGE_H
+
+#include <imaging/image.h>
+#include <bitreader.h>
+#include <list.h>
+#include <string.h>
+#include <vector.h>
+
+namespace LIBCactusOS
+{
+    namespace Imaging
+    {
+        struct PNGChunk
+        {
+            uint32_t length;
+            uint8_t type[4];
+            //uint8_t data;
+            //uint32_t crc;
+        } __attribute__((packed));
+
+        struct IHDRChunk
+        {
+            uint32_t width;
+            uint32_t height;
+            uint8_t bits;
+            uint8_t colorType;
+            uint8_t compression;
+            uint8_t filter;
+            uint8_t interlace;
+        } __attribute__((packed));
+
+        class PNGDecoder
+        {
+        private:
+            static uint8_t PaethPredictor(uint8_t* recon, uint8_t a, uint8_t b, uint8_t c);
+            static uint8_t Recon_a(uint8_t* recon, uint32_t stride, uint32_t r, uint32_t c);
+            static uint8_t Recon_b(uint8_t* recon, uint32_t stride, uint32_t r, uint32_t c);
+            static uint8_t Recon_c(uint8_t* recon, uint32_t stride, uint32_t r, uint32_t c);
+        public:
+            // Convert image file into image buffer
+            static Image* Convert(const char* filepath);
+
+            // Create image from array of bytes in png format
+            static Image* ConvertRAW(const uint8_t* rawData);
+        };
+
+        // Represents a single node in the huffman tree
+        class HuffmanNode
+        {
+        public:
+            uint32_t symbol = 0;
+            HuffmanNode* left = 0;
+            HuffmanNode* right = 0;
+
+            HuffmanNode()
+            {
+                this->symbol = 0;
+                this->left = 0;
+                this->right = 0;
+            }
+        };
+        class HuffmanTree
+        {
+        private:
+            void DeleteNode(HuffmanNode* node)
+            {
+                if(node->left) DeleteNode(node->left);
+                if(node->right) DeleteNode(node->right);
+                delete node;
+            }
+        public:
+            HuffmanNode* root = 0;
+
+            HuffmanTree()
+            {
+                this->root = new HuffmanNode();
+            }
+            ~HuffmanTree()
+            {
+                this->DeleteNode(this->root);
+            }
+            void Insert(uint32_t codeWord, uint32_t n, uint32_t symbol)
+            {
+                HuffmanNode* node = this->root;
+                HuffmanNode* nextNode = 0;
+                for(int i = n - 1; i >= 0; i--) {
+                    uint32_t b = codeWord & (1 << i);
+                    if(b) {
+                        nextNode = node->right;
+                        if(nextNode == 0) {
+                            node->right = new HuffmanNode();
+                            nextNode = node->right;
+                        }
+                    }
+                    else {
+                        nextNode = node->left;
+                        if(nextNode == 0) {
+                            node->left = new HuffmanNode();
+                            nextNode = node->left;
+                        }
+                    }
+                    node = nextNode;
+                }
+                node->symbol = symbol;
+            }
+        };
+
+        struct DecodeTreesResult
+        {
+            HuffmanTree* literalLengthTree;
+            HuffmanTree* distanceTree;
+        };
+
+        // Class used to decompress ZLIB data such as png and zip files
+        class ZLIBDecompressor
+        {
+        private:
+            // Reads data from a non compression block
+            static void InflateBlockNoCompression(BitReader* reader, Vector<uint8_t>* target);
+            
+            // Reads data from dynamic block
+            static void InflateBlockDynamic(BitReader* reader, Vector<uint8_t>* target);
+
+            // Reads data from static block
+            static void InflateBlockStatic(BitReader* reader, Vector<uint8_t>* target);
+
+            // Decodes one symbol from bitstream using a HuffmanTree
+            static uint32_t DecodeSymbol(BitReader* reader, HuffmanTree* tree);
+
+            static void InflateBlockData(BitReader* reader, HuffmanTree* literalLengthTree, HuffmanTree* distanceTree, Vector<uint8_t>* target);
+
+            static HuffmanTree* BitListToTree(Vector<uint32_t>* bitList, Vector<uint8_t>* alphabet);
+        
+            static DecodeTreesResult DecodeTrees(BitReader* reader);
+        public:
+            // Perform decompression on input and return the complete set of data
+            static Vector<uint8_t>* Decompress(uint8_t* input);
+
+            // Perform the actual inflation of the DEFLATE block
+            static Vector<uint8_t>* Inflate(BitReader* reader);
+        };
+    }
+}
+
+#endif
\ No newline at end of file
diff --git a/lib/include/ipc.h b/lib/include/ipc.h
new file mode 100644
index 0000000..92af850
--- /dev/null
+++ b/lib/include/ipc.h
@@ -0,0 +1,50 @@
+#ifndef __LIBCACTUSOS__IPC_H
+#define __LIBCACTUSOS__IPC_H
+
+namespace LIBCactusOS
+{
+    enum IPCMessageType : int
+    {
+        None = 0,
+        GUIRequest = 1,
+        GUIEvent = 2
+    };
+
+    struct IPCMessage
+    {
+        int source; // Who has sended this message?
+        int dest;   // Who is it for
+        
+        int type; // What type of message is it?
+
+        // Arguments
+        unsigned int arg1;
+        unsigned int arg2;
+        unsigned int arg3;
+        unsigned int arg4;
+        unsigned int arg5;
+        unsigned int arg6;
+    };
+
+    /**
+     * Send a message to a other process
+    */
+    int IPCSend(int dest, int type = IPCMessageType::None, unsigned int arg1 = 0, unsigned int arg2 = 0, unsigned int arg3 = 0, unsigned int arg4 = 0, unsigned int arg5 = 0, unsigned int arg6 = 0);
+    /**
+     * Send a message to a other process
+    */
+    int IPCSend(IPCMessage message);
+
+    /**
+     * How many messages are ready for receiving?
+    */
+    int IPCAvailable();
+
+    /**
+     * Receive a single IPCMessage, blocks if none availible
+     * FromID: Only receive a message from specified process
+    */
+    IPCMessage ICPReceive(int fromID = -1, int* errOut = 0, int type = -1);
+}
+
+#endif
\ No newline at end of file
diff --git a/lib/include/list.h b/lib/include/list.h
new file mode 100644
index 0000000..c826f41
--- /dev/null
+++ b/lib/include/list.h
@@ -0,0 +1,204 @@
+#ifndef __CACTUSOS__COMMON__LIST_H
+#define __CACTUSOS__COMMON__LIST_H
+
+namespace LIBCactusOS
+{
+    template <typename T>
+    struct ListNode
+    {
+        ListNode(const T &e) : data(e), next(0), prev(0)
+        {}
+        T data;
+        ListNode<T>* next;
+        ListNode<T>* prev;
+    };
+    template <typename T>
+    class List
+    {
+    public:
+        List() : head_(0), tail_(0), size_(0)
+        {   }
+        ~List()
+        { this->Clear(); /*Remove all the items from the list*/ }
+        int size() { return size_; }
+        void push_back(const T &e);
+        void push_front(const T &e);
+        void Clear();
+        T GetAt(int index);
+        T operator[](int index);
+        void Remove(int index);
+        void Remove(const T &e);
+
+        void operator+=(const T &e);
+        void operator-=(const T &e);
+    private:
+        ListNode<T>* head_;
+        ListNode<T>* tail_;
+        int size_;
+        ListNode<T>* insertInternal(const T &e, ListNode<T>* pos);
+        void removeInternal(ListNode<T> *pos);
+    //Iterators
+    public:
+        class iterator
+        {
+        public:
+            iterator(ListNode<T> *p=0) : pos_(p) { }
+            
+            T &operator*()
+            { return pos_->data; }
+
+            T *operator->()
+            { return &(pos_->data); }
+
+            bool operator!=(const iterator &rhs)
+            { return this->pos_ != rhs.pos_; }
+
+            iterator operator++()
+            { pos_ = pos_->next; return *this; }
+
+            iterator operator--()
+            { pos_ = pos_->prev; return *this; }
+
+        private:
+            ListNode<T> *pos_;
+        };
+        iterator begin()
+        {
+            return iterator(head_);
+        }
+        iterator end()
+        {
+            return iterator(0);
+        }
+    };
+}
+
+using namespace LIBCactusOS;
+
+/////////////
+// Implementations
+////////////
+template <typename T>
+ListNode<T>* List<T>::insertInternal(const T &e, ListNode<T>* pos)
+{
+    ListNode<T> *n = new ListNode<T>(e);
+    size_++;
+    // no operation below this should throw
+    // as state of the list has changed and memory allocated
+    n->next = pos;
+    if(pos)
+    {
+        n->prev = pos->prev;
+        pos->prev = n;
+    }
+    else
+    {
+        // pos is null that is at the very end of the list
+        n->prev = tail_;
+        tail_ = n;
+    }
+    if(n->prev)
+    {
+        n->prev->next = n;
+    }
+    else
+    {
+        // at the very begining of the list
+        head_ = n;
+    }
+    return n;
+}
+template <typename T>
+void List<T>::push_back(const T &e)
+{
+    // inserts before the position, 
+    // 0 is the end() iterator
+    // hence insert at the end
+    insertInternal(e, 0);
+}
+template <typename T>
+void List<T>::push_front(const T &e)
+{
+    // insert before the head
+    insertInternal(e, head_);
+}
+
+template <typename T>
+void List<T>::removeInternal(ListNode<T> *pos)
+{
+	if(pos)
+	{
+		if(pos->prev)
+			pos->prev->next = pos->next;
+		if(pos->next)
+			pos->next->prev = pos->prev;
+		if(pos == head_)
+			head_ = pos->next;
+		if(pos == tail_)
+			tail_ = pos->prev;
+		delete pos;
+		size_--;
+	}
+}
+
+template <typename T>
+void List<T>::Remove(int index)
+{
+    ListNode<T>* cur = head_;
+    for(int i = 0; i < index; ++i)
+        cur = cur->next;
+    removeInternal(cur);
+}
+
+template <typename T>
+void List<T>::Remove(const T &e)
+{
+    for(int i = 0; i < size_; i++)
+        if(GetAt(i) == e)
+            Remove(i);
+}
+
+template <typename T>
+void List<T>::Clear()
+{
+    ListNode<T>* current( head_ );
+
+    while(current)
+    {
+        ListNode<T>* next( current->next );
+        delete current;
+        current = next;
+    }
+    size_ = 0; //Reset the size to 0
+    head_ = 0;
+    tail_ = 0;
+}
+
+template <typename T>
+T List<T>::GetAt(int index)
+{
+    ListNode<T>* cur = head_;
+    for(int i = 0; i < index; ++i)
+        cur = cur->next;
+    return cur->data;
+}
+
+template <typename T>
+T List<T>::operator[](int index)
+{
+    return GetAt(index);
+}
+
+template <typename T>
+void List<T>::operator+=(const T &e)
+{
+    push_back(e);
+}
+
+template <typename T>
+void List<T>::operator-=(const T &e)
+{
+    Remove(e);
+}
+
+#endif
\ No newline at end of file
diff --git a/lib/include/listing.h b/lib/include/listing.h
new file mode 100644
index 0000000..19fb9f9
--- /dev/null
+++ b/lib/include/listing.h
@@ -0,0 +1,10 @@
+#ifndef __LIBCACTUSOS__LISTING_H
+#define __LIBCACTUSOS__LISTING_H
+
+namespace LIBCactusOS
+{
+    #define DIRECTORY_LISTING 0
+    #define DISK_LISTING 1
+}
+
+#endif
\ No newline at end of file
diff --git a/lib/include/log.h b/lib/include/log.h
new file mode 100644
index 0000000..fb0f74a
--- /dev/null
+++ b/lib/include/log.h
@@ -0,0 +1,23 @@
+#ifndef __CACTUSOSLIB__LOG_H
+#define __CACTUSOSLIB__LOG_H
+
+namespace LIBCactusOS
+{
+    enum LogLevel
+    {
+        Info,
+        Warning,
+        Error
+    };
+
+    /**
+     * Send a log message to the system 
+    */
+    void Log(LogLevel level, char* msg);
+    /**
+     * Print a message to the standard output stream 
+    */
+    void Print(const char* __restrict__ format, ...);
+}
+
+#endif
\ No newline at end of file
diff --git a/lib/include/math.h b/lib/include/math.h
new file mode 100644
index 0000000..c6b5f0c
--- /dev/null
+++ b/lib/include/math.h
@@ -0,0 +1,53 @@
+#ifndef __CACTUSOSLIB__MATH_H
+#define __CACTUSOSLIB__MATH_H
+
+#include <types.h>
+
+namespace LIBCactusOS
+{
+    #define MATH_PI 3.14159265358979323846
+
+    struct MXCSR_StatusRegister
+    {
+        uint8_t InvalidOperationFlag : 1;
+        uint8_t DenormalFlag : 1;
+        uint8_t DevideByZeroFlag : 1;
+        uint8_t OverflowFlag : 1;
+        uint8_t UnderflowFlag : 1;
+        uint8_t PrecisionFlag : 1;
+        uint8_t DemormalsAreZeros : 1;
+        uint8_t InvalidOperationMask : 1;
+        uint8_t DenormalOperationMask : 1;
+        uint8_t DevideByZeroMask : 1;
+        uint8_t OverflowMask : 1;
+        uint8_t UnderflowMask : 1;
+        uint8_t PrecisionMask : 1;
+        uint8_t RoundingControl : 2;
+        uint8_t FlushToZero : 1;
+        uint16_t Reserved;
+    } __attribute__((packed));
+
+    class Math
+    {
+    public:
+        static void EnableFPU();
+
+        static long Abs(long v);
+        static double fAbs(double x);
+        static long Sign(long v);
+        static double sin(double x);
+        static double cos(double x);
+
+        static long Max (long a, long b);
+        static long Min (long a, long b);
+        static long Constrain(long x, long a, long b);
+        static long Map(long x, long in_min, long in_max, long out_min, long out_max);
+
+        static float fMod(float a, float b);
+        static double floor(double x);
+        static double sqrt(double n);
+
+        static double Round(double n, uint32_t digits);
+    };
+}
+#endif
\ No newline at end of file
diff --git a/lib/include/new.h b/lib/include/new.h
new file mode 100644
index 0000000..c98799e
--- /dev/null
+++ b/lib/include/new.h
@@ -0,0 +1,48 @@
+#ifndef __LIBCACTUSOS__NEW_H
+#define __LIBCACTUSOS__NEW_H
+
+#include <stddef.h>
+#include <heap.h>
+
+using namespace LIBCactusOS;
+ 
+void *operator new(size_t size)
+{
+    return UserHeap::Malloc(size);
+}
+ 
+void *operator new[](size_t size)
+{
+    return UserHeap::Malloc(size);
+}
+
+void* operator new(size_t size, void* ptr)
+{
+    return ptr;
+}
+
+void* operator new[](size_t size, void* ptr)
+{
+    return ptr;
+}
+ 
+void operator delete(void *p)
+{
+    UserHeap::Free(p);
+}
+ 
+void operator delete[](void *p)
+{
+    UserHeap::Free(p);
+}
+
+void operator delete(void* ptr, size_t size)
+{
+    UserHeap::Free(ptr);
+}
+void operator delete[](void* ptr, size_t size)
+{
+    UserHeap::Free(ptr);
+}
+
+#endif
\ No newline at end of file
diff --git a/lib/include/proc.h b/lib/include/proc.h
new file mode 100644
index 0000000..e7e8833
--- /dev/null
+++ b/lib/include/proc.h
@@ -0,0 +1,99 @@
+#ifndef __LIBCACTUSOS__PROC_H
+#define __LIBCACTUSOS__PROC_H
+
+#include <syscall.h>
+#include <types.h>
+#include <systeminfo.h>
+#include <list.h>
+#include <shared.h>
+
+namespace LIBCactusOS
+{
+    #define DECLARE_LOCK(name) volatile int name ## Locked
+    #define LOCK(name) \
+	    while (name ## Locked == 1) asm("pause"); \
+	    __sync_synchronize();
+    #define UNLOCK(name) \
+	    __sync_synchronize(); \
+	    name ## Locked = 0;
+
+    class Process
+    {
+    private:
+        /**
+         * How many threads does this application have?
+        */
+        static int numThreads;
+    public:
+        /**
+         * The PID of this process
+        */
+        static int ID;
+        /**
+         * A pointer to a buffer shared with the kernel that contains some systeminfo
+        */
+        static SharedSystemInfo* systemInfo;
+        /**
+         * Start a new process and return its PID, if block is set to true the process will not be started automaticly.
+        */
+        static int Run(const char* path, bool block = false);
+        /**
+         * Create a block of shared memory
+        */
+        static bool CreateSharedMemory(int proc2ID, uint32_t virtStart, uint32_t len);
+        /**
+         * Create a block of shared memory
+        */
+        static bool CreateSharedMemory(int proc2ID, uint32_t virtStart1, uint32_t virtStart2, uint32_t len);
+        /**
+         * Remove a block of shared memory 
+        */
+        static bool DeleteSharedMemory(int proc2ID, uint32_t virtStart, uint32_t len);
+        /**
+         * Remove a block of shared memory
+        */
+        static bool DeleteSharedMemory(int proc2ID, uint32_t virtStart1, uint32_t virtStart2, uint32_t len);
+        /**
+         * Create a new thread for this application
+        */
+        static void CreateThread(void (*entryPoint)(), bool switchTo = false);
+        /**
+         * Force a task switch
+        */
+        static void Yield();
+        /**
+         * Write a byte to this processes standard output stream 
+        */
+        static void WriteStdOut(char byte);
+        /**
+         * Write bytes to this processes standard output stream 
+        */
+        static void WriteStdOut(char* bytes, int length);
+        /**
+         * Read a byte from this processes standard input stream
+        */
+        static char ReadStdIn();
+        /**
+         * How many bytes can be read from the stdin stream? 
+        */
+        static int StdInAvailable();
+        /**
+         * Redirect one process output to another process input 
+        */
+        static void BindSTDIO(int fromID, int toID);
+        /**
+         * Returns if a process with given pid is present and running.
+        */
+        static bool Active(int pid);
+        /**
+         * Unblock a thread of a process
+        */
+        static void Unblock(int procPID, int thread = 0);
+        /**
+         * Dissable or enable kernel scheduler
+        */
+        static void SetScheduler(bool active);
+    };
+}
+
+#endif
\ No newline at end of file
diff --git a/lib/include/random.h b/lib/include/random.h
new file mode 100644
index 0000000..0ca8ebf
--- /dev/null
+++ b/lib/include/random.h
@@ -0,0 +1,17 @@
+#ifndef LIBCACTUSOS__RANDOM_H
+#define LIBCACTUSOS__RANDOM_H
+
+#include <types.h>
+
+namespace LIBCactusOS
+{
+    class Random
+    {
+    public:
+        static int Next(uint32_t max = 32767);
+        static int Next(uint32_t min, uint32_t max);             
+        static void SetSeed(uint32_t seed);
+    };
+}
+
+#endif
\ No newline at end of file
diff --git a/lib/include/shared.h b/lib/include/shared.h
new file mode 100644
index 0000000..9886937
--- /dev/null
+++ b/lib/include/shared.h
@@ -0,0 +1,105 @@
+#ifndef __LIBCACTUSOS__SHARED_H
+#define __LIBCACTUSOS__SHARED_H
+
+/////////////////
+// Data structures shared between userspace and kernel
+/////////////////
+
+namespace LIBCactusOS
+{
+    #define VFS_NAME_LENGTH 255
+
+    // Holds data about a specific process, data is readonly
+    struct ProcessInfo
+    {
+        // PID of process
+        int id;
+        // Which syscall interface does this process use?
+        int syscallID;
+        // The amount of threads of this process
+        int threads;
+        // Virtual memory used by heap
+        unsigned int heapMemory;
+        // Is this a ring 3 process?
+        bool isUserspace;
+        // Is process currently blocked (main thread only)
+        bool blocked;
+        // Filename of process excecutable
+        char fileName[32];
+    };
+
+    // Info about a item represent on the disk
+    struct VFSEntry
+    {
+        uint32_t size;  // Size of the entry in bytes
+        bool isDir;     // Is this item a directory or not?
+        struct
+        {
+            uint8_t sec;
+            uint8_t min;
+            uint8_t hour;
+        } creationTime; // Time file was created
+        struct
+        {
+            uint8_t day;
+            uint8_t month;
+            uint16_t year;
+        } creationDate; // Date time was created
+        char name[VFS_NAME_LENGTH]; // Name of the file 
+        // TODO: Is there a better way for buffering this?
+    };
+
+    #define KEYPACKET_START 0xFF
+    enum KEYPACKET_FLAGS {
+        NoFlags = 0,
+        Pressed = (1<<0),
+        CapsLock = (1<<1),
+        NumLock = (1<<2),
+        LeftShift = (1<<3),
+        RightShift = (1<<4),
+        LeftControl = (1<<5),
+        RightControl = (1<<6),
+        Alt = (1<<7)
+    };
+
+    inline KEYPACKET_FLAGS operator|(KEYPACKET_FLAGS a, KEYPACKET_FLAGS b)
+    {
+        return static_cast<KEYPACKET_FLAGS>(static_cast<int>(a) | static_cast<int>(b));
+    }
+
+    // Keys not present in ascii table but used by CactusOS and applications
+    enum SpecialKeys : uint8_t {
+        EscapeKey = 27,
+
+        // Start of custom
+        CapsLockKey = 128,
+        NumLockKey,
+        LeftShiftKey,
+        RightShiftKey,
+        LeftControlKey,
+        RightControlKey,
+        AltKey,
+
+        F1Key,
+        F2Key,
+        F3Key,
+        F4Key,
+        F5Key,
+        F6Key,
+        F7Key,
+        F8Key,
+        F9Key,
+        F10Key,
+        F11Key,
+        F12Key
+    };
+
+    // Packet containing info on Keypress event
+    struct KeypressPacket
+    {
+        uint8_t startByte; //Start of packet
+        uint8_t keyCode; //keycode in integer format
+        KEYPACKET_FLAGS flags; //Button state flags
+    } __attribute__((packed));
+}
+#endif
\ No newline at end of file
diff --git a/lib/include/string.h b/lib/include/string.h
new file mode 100644
index 0000000..15520f8
--- /dev/null
+++ b/lib/include/string.h
@@ -0,0 +1,27 @@
+#ifndef __CACTUSOSLIB__MEMORYOPERATIONS_H
+#define __CACTUSOSLIB__MEMORYOPERATIONS_H
+
+#include <stddef.h>
+#include <list.h>
+
+extern "C"
+{
+    int memcmp(const void* aptr, const void* bptr, size_t size);
+    void* memcpy(void* __restrict__ dstptr, const void* __restrict__ srcptr, size_t size);
+    void* memmove(void* dstptr, const void* srcptr, size_t size);
+    void* memset(void* bufptr, int value, size_t size);
+    size_t strlen(const char* str);
+    int strcmp(const char *s1, const char *s2);
+   
+    int str_IndexOf(const char* str, char c, int skip = 0);
+    bool str_Contains(const char* str, char c);
+    List<char*> str_Split(const char* str, char d);
+    char* str_Uppercase(char* str);
+    char* str_Lowercase(char* str);
+    char* str_Add(char* str, char c);
+    char* str_Combine(char* part1, char* part2);
+
+    bool isvalid(unsigned char key);
+}
+
+#endif
\ No newline at end of file
diff --git a/lib/include/syscall.h b/lib/include/syscall.h
new file mode 100644
index 0000000..94a4b75
--- /dev/null
+++ b/lib/include/syscall.h
@@ -0,0 +1,113 @@
+#ifndef __CACTUSOSLIB__SYSCALL_H
+#define __CACTUSOSLIB__SYSCALL_H
+
+namespace LIBCactusOS
+{
+    #define SYSCALL_RET_SUCCES 1
+    #define SYSCALL_RET_ERROR 0
+    #define PROC_ARG_LEN_MAX 100
+
+    enum Systemcalls {
+        SYSCALL_EXIT = 0, // Tells kernel that procces is done and can be removed
+
+        /////////////
+        // Logging
+        /////////////
+    
+        SYSCALL_LOG,
+        SYSCALL_PRINT,
+
+        /////////////
+        // VFS
+        /////////////
+
+        SYSCALL_FILE_EXISTS,
+        SYSCALL_DIR_EXISTS,
+        SYSCALL_GET_FILESIZE,
+        SYSCALL_READ_FILE,
+        SYSCALL_WRITE_FILE,
+        SYSCALL_CREATE_FILE,
+        SYSCALL_CREATE_DIRECTORY,
+        SYSCALL_EJECT_DISK,
+
+        //////////////
+        // GUI
+        //////////////
+        
+        SYSCALL_GUI_GETLFB,
+        SYSCALL_GET_SCREEN_PROPERTIES,
+
+        //////////////
+        // Memory
+        //////////////
+
+        SYSCALL_GET_HEAP_START,
+        SYSCALL_GET_HEAP_END,
+        SYSCALL_SET_HEAP_SIZE,
+        SYSCALL_CREATE_SHARED_MEM,
+        SYSCALL_REMOVE_SHARED_MEM,
+        SYSCALL_MAP_SYSINFO,
+
+        //////////////
+        // Scheduler
+        //////////////
+
+        SYSCALL_RUN_PROC,
+        SYSCALL_SLEEP_MS,
+        SYSCALL_START_THREAD,
+        SYSCALL_YIELD,
+        SYSCALL_PROC_EXIST,
+        SYSCALL_UNBLOCK,
+        SYSCALL_SET_SCHEDULER,
+        SYSCALL_GET_ARGUMENTS,
+
+        //////////////
+        // IPC
+        //////////////
+
+        SYSCALL_IPC_SEND,
+        SYSCALL_IPC_RECEIVE,
+        SYSCALL_IPC_AVAILABLE,
+
+        //////////////
+        // Clock
+        //////////////
+
+        SYSCALL_GET_TICKS,
+        SYSCALL_GET_DATETIME,
+
+        //////////////
+        // Power
+        //////////////
+
+        SYSCALL_SHUTDOWN,
+        SYSCALL_REBOOT,
+
+        //////////////
+        // STDIO
+        //////////////
+
+        SYSCALL_READ_STDIO,
+        SYSCALL_WRITE_STDIO,
+        SYSCALL_REDIRECT_STDIO,
+        SYSCALL_STDIO_AVAILABLE,
+
+        //////////////
+        // Listings
+        //////////////
+
+        SYSCALL_BEGIN_LISTING,
+        SYSCALL_LISTING_ENTRY,
+        SYSCALL_END_LISTING,
+        SYSCALL_GET_SYSINFO_VALUE,
+
+        //////////////
+        // Other
+        //////////////
+        SYSCALL_SET_CACTUSOS_LIB = 0xFFFF,
+    };
+
+    int DoSyscall(unsigned int intNum, unsigned int arg1 = 0, unsigned int arg2 = 0, unsigned int arg3 = 0, unsigned int arg4 = 0, unsigned int arg5 = 0);
+}
+
+#endif
\ No newline at end of file
diff --git a/lib/include/systeminfo.h b/lib/include/systeminfo.h
new file mode 100644
index 0000000..1fc9ab9
--- /dev/null
+++ b/lib/include/systeminfo.h
@@ -0,0 +1,85 @@
+#ifndef __LIBCACTUSOS__SYSTEMINFO_H
+#define __LIBCACTUSOS__SYSTEMINFO_H
+
+#ifdef CACTUSOSKERNEL
+#include <common/types.h>
+#else
+#include <types.h>
+#endif
+
+namespace LIBCactusOS
+{
+    #define SYSTEM_INFO_ADDR 0xBFFEE000
+
+    enum SIPropertyIdentifier
+    {
+        String,
+        Index
+    };
+
+    class SIPropertyProvider
+    {
+    public:
+        char* id = 0;
+        int index = 0;
+        SIPropertyIdentifier type = String;
+
+        SIPropertyProvider* parent = 0;
+    public:
+        SIPropertyProvider(char* property);
+        SIPropertyProvider(int index);
+
+        // Collection functions
+
+        // Get Count of items present in this collection
+        int size();
+
+        // Get specific property of collection
+        SIPropertyProvider operator[](const int index);
+        SIPropertyProvider operator[](const char* element);
+
+        template<typename T>
+        T receiveValue(const bool getsize) const;
+
+        template<typename T>
+        T receiveBuffer() const;
+
+        // We are a property ourself
+        operator int() const;       // Receive this property as integer
+        operator bool() const;      // Receive this property as boolean
+        operator double() const;    // Receive this property as double
+        operator char*() const;     // Receive this property as string
+        operator uint64_t() const;  // Receive this property as unsigned long
+        operator uint32_t() const;  // Receive this property as unsigned int
+        operator uint16_t() const;  // Receive this property as unsigned word
+        operator uint8_t() const;  // Receive this property as unsigned char
+    } __attribute__((packed));
+
+    // A class for managing all information known about the current system
+    // With this a application can monitor the system
+    class SystemInfo
+    {
+    public:
+        // All properties of the current system
+        // Things like connected disks and usbdevices
+        static SIPropertyProvider Properties;
+
+        // Request System info to be mapped into address space
+        // Addres is SYSTEM_INFO_ADDR which is 2 pages below user-stack
+        static bool RequestSystemInfo();
+    };
+
+    // This struct can be shared between the kernel and userspace processes
+    struct SharedSystemInfo
+    {
+        unsigned int MouseX;
+        unsigned int MouseY;
+        signed int   MouseZ;
+
+        bool MouseLeftButton;
+        bool MouseRightButton;
+        bool MouseMiddleButton;
+    } __attribute__((packed));
+}
+
+#endif
\ No newline at end of file
diff --git a/lib/include/time.h b/lib/include/time.h
new file mode 100644
index 0000000..13c7170
--- /dev/null
+++ b/lib/include/time.h
@@ -0,0 +1,22 @@
+#ifndef __LIBCACTUSOS__TIME_H
+#define __LIBCACTUSOS__TIME_H
+
+#include <types.h>
+
+namespace LIBCactusOS
+{
+    class Time
+    {
+    public:
+        /**
+         * Make this thread sleep for a specific amount of ms
+        */
+        static void Sleep(uint32_t ms);
+        /**
+         * Get the current amount of ticks from the timer
+        */
+        static uint64_t Ticks();
+    };
+}
+
+#endif
\ No newline at end of file
diff --git a/lib/include/types.h b/lib/include/types.h
new file mode 100644
index 0000000..35fe156
--- /dev/null
+++ b/lib/include/types.h
@@ -0,0 +1,32 @@
+#ifndef __CACTUSOSLIB__TYPES_H
+#define __CACTUSOSLIB__TYPES_H
+
+namespace LIBCactusOS
+{
+    #define STATIC_ASSERT(condition) typedef char p__LINE__[ (condition) ? 1 : -1];
+
+    typedef char                        int8_t;
+    typedef unsigned char               uint8_t;
+    typedef short                       int16_t;
+    typedef unsigned short              uint16_t;
+    typedef int                         int32_t;
+    typedef unsigned int                uint32_t;
+    typedef long long int               int64_t;
+    typedef unsigned long long int      uint64_t;
+    typedef unsigned long long          uintptr_t;
+
+    constexpr uint32_t operator"" _KB(unsigned long long no)
+    {
+        return no * 1024;
+    }
+    constexpr uint32_t operator"" _MB(unsigned long long no)
+    {
+        return no * (1024_KB);
+    }
+    constexpr uint32_t operator"" _GB(unsigned long long no)
+    {
+        return no * (1024_MB);
+    }
+}
+
+#endif
\ No newline at end of file
diff --git a/lib/include/vector.h b/lib/include/vector.h
new file mode 100644
index 0000000..0cac931
--- /dev/null
+++ b/lib/include/vector.h
@@ -0,0 +1,90 @@
+#ifndef __LIBCACTUSOS__VECTOR_H
+#define __LIBCACTUSOS__VECTOR_H
+
+#include <types.h>
+
+namespace LIBCactusOS
+{
+    template<typename T>
+    class Vector
+    {
+    private:
+        uint32_t size = 0;
+        uint32_t capacity = 0;
+        T* buffer = 0;
+
+        void reserve(int capacity)
+        {
+            T* newBuf = new T[capacity];
+            memcpy(newBuf, this->buffer, sizeof(T) * this->size);
+
+            this->capacity = capacity;
+            
+            if(this->buffer)
+                delete this->buffer;
+            this->buffer = newBuf;
+        }
+    public:
+        Vector()
+        {
+            this->size = 0;
+            this->capacity = 0;
+            this->buffer = 0;
+        }
+        ~Vector()
+        { this->clear(); }
+
+        int Size()
+        { return this->size; }
+
+        void push_back(const T& item)
+        {
+            if(this->capacity == 0)
+                reserve(10);
+            else if(this->size == this->capacity)
+                reserve(2 * this->size);
+            
+            this->buffer[this->size] = item;
+            this->size++;
+        }
+
+        void pop_back()
+        { this->size--; }
+
+        void clear()
+        {
+            this->capacity = 0;
+            this->size = 0;
+
+            if(this->buffer)
+                delete this->buffer;
+            this->buffer = 0;
+        }
+
+        T& GetAt(int n)
+        { return this->buffer[n]; }
+
+        T& operator[](int n)
+        { return this->buffer[n]; }
+
+        T* data()
+        { return this->buffer; }
+
+        ///////////////////
+        // Iterators
+        ///////////////////
+
+        typedef T* iterator;
+        iterator begin()
+        {
+            return this->buffer;
+        }
+
+        iterator end()
+        {
+            return this->buffer + this->size;
+        }
+    };
+}
+
+#endif
\ No newline at end of file
diff --git a/lib/include/vfs.h b/lib/include/vfs.h
new file mode 100644
index 0000000..d0abdc9
--- /dev/null
+++ b/lib/include/vfs.h
@@ -0,0 +1,35 @@
+#ifndef __CACTUSOSLIB__VFS_H
+#define __CACTUSOSLIB__VFS_H
+
+#include <types.h>
+#include <list.h>
+#include <shared.h>
+
+namespace LIBCactusOS
+{
+    // Read file contents into buffer
+    int ReadFile(char* filename, uint8_t* buffer, uint32_t offset = 0, uint32_t len = -1);
+    // Write buffer to file, file will be created when create equals true
+    int WriteFile(char* filename, uint8_t* buffer, uint32_t len, bool create = true);
+
+    // Check if file exist
+    bool FileExists(char* filename);
+    // Check if directory exist
+    bool DirectoryExists(char* filename);
+
+    // Create a file at the filepath
+    int CreateFile(char* path);
+    // Create a new directory
+    int CreateDirectory(char* path);
+
+    // Get size of specified file in bytes
+    uint32_t GetFileSize(char* filename);
+
+    // Get list of files/directories in specified path
+    List<VFSEntry> DirectoryListing(char* path);
+
+    // Request to eject a specific disk (only works for CD's at the moment, TODO: usb as well?)
+    bool EjectDisk(char* path);
+}
+
+#endif
\ No newline at end of file
diff --git a/lib/makefile b/lib/makefile
new file mode 100644
index 0000000..0e151b7
--- /dev/null
+++ b/lib/makefile
@@ -0,0 +1,50 @@
+CONFIG = ../makefile.config
+include ${CONFIG}
+
+INCLUDEDIRS := include
+DEBUG := -g
+
+GCCPARAMS := -m32 $(DEBUG) -I $(INCLUDEDIRS) $(OPTIMIZE_FLAGS) -Wall -fno-omit-frame-pointer -fno-use-cxa-atexit -nostdlib -fno-builtin -fno-exceptions -fno-rtti -fno-leading-underscore -Wno-write-strings -fpermissive -Wno-unknown-pragmas
+ASPARAMS := --32
+
+SRCDIR := src
+OBJDIR := obj
+
+SRCFILES := $(shell find $(SRCDIR) -type f \( -name \*.cpp -o -name \*.s -o -name \*.asm \)) #Find all the files that end with .cpp/.s/.asm
+OBJFILES := $(patsubst %.cpp,%.o,$(patsubst %.s,%.o,$(patsubst %.asm,%.o,$(SRCFILES)))) #Replace the .cpp/.s/.asm extension with .o
+OBJFILES := $(subst $(SRCDIR),$(OBJDIR),$(OBJFILES)) #Replace the "src" part with "obj"
+
+
+####################################
+#C++ source files
+####################################
+$(OBJDIR)/%.o: $(SRCDIR)/%.cpp
+	mkdir -p $(@D)
+	i686-elf-g++ $(GCCPARAMS) -c -o $@ $<
+
+####################################
+#GAS assembly files
+####################################
+$(OBJDIR)/%.o: $(SRCDIR)/%.s
+	mkdir -p $(@D)
+	i686-elf-as $(ASPARAMS) -o $@ $<
+
+####################################
+#NASM assembly files
+####################################
+$(OBJDIR)/%.o: $(SRCDIR)/%.asm
+	mkdir -p $(@D)
+	nasm -f elf32 -O0 $< -o $@
+
+libcactusos.a: $(OBJFILES)
+	i686-elf-ar r libcactusos.a $(OBJFILES)
+
+.PHONY: clean filelist
+clean:
+	rm -rf $(OBJDIR) libcactusos.a
+
+filelist:
+	@echo "Source Files:"
+	@echo -$(SRCFILES)
+	@echo "Object Files:"
+	@echo -$(OBJFILES)
diff --git a/lib/src/api.cpp b/lib/src/api.cpp
new file mode 100644
index 0000000..f8846d9
--- /dev/null
+++ b/lib/src/api.cpp
@@ -0,0 +1,15 @@
+#include <api.h>
+
+#include <syscall.h>
+#include <log.h>
+#include <proc.h>
+
+using namespace LIBCactusOS;
+
+void API::Initialize()
+{
+    //Call kernel to set this process as a cactusos process
+    Process::ID = DoSyscall(SYSCALL_SET_CACTUSOS_LIB);
+
+    Log(Info, "CactusOS API Initialized for this process");
+}
\ No newline at end of file
diff --git a/lib/src/convert.cpp b/lib/src/convert.cpp
new file mode 100644
index 0000000..163426b
--- /dev/null
+++ b/lib/src/convert.cpp
@@ -0,0 +1,115 @@
+#include <convert.h>
+#include <string.h>
+
+using namespace LIBCactusOS;
+
+int IsSpace(char c)
+{
+    return c == ' ' || c == '\t' || c == '\n' || c == '\v' || c == '\f' || c == '\r';
+}
+
+char* Convert::IntToString(int n)
+{
+    static char ret[24];
+    int numChars = 0;
+    // Determine if integer is negative
+    bool isNegative = false;
+    if (n < 0)
+    {
+        n = -n;
+        isNegative = true;
+        numChars++;
+    }
+    // Count how much space we will need for the string
+    int temp = n;
+    do
+    {
+        numChars++;
+        temp /= 10;
+    } while (temp);
+
+    ret[numChars] = 0;
+    //Add the negative sign if needed
+    if (isNegative)
+        ret[0] = '-';
+    // Copy digits to string in reverse order
+    int i = numChars - 1;
+    do
+    {
+        ret[i--] = n % 10 + '0';
+        n /= 10;
+    } while (n);
+    return ret;
+}
+
+char* Convert::IntToHexString(uint8_t w)
+{
+    static const char* digits = "0123456789ABCDEF";
+    uint32_t hexSize = sizeof(uint8_t)<<1;
+    char* rc = new char[hexSize + 1]; //Terminate string with 0
+    memset(rc, 0, hexSize + 1);
+
+    for (uint32_t i=0, j=(hexSize-1)*4 ; i<hexSize; ++i,j-=4)
+        rc[i] = digits[(w>>j) & 0x0f];
+    return rc;
+}
+char* Convert::IntToHexString(uint16_t w)
+{
+    static const char* digits = "0123456789ABCDEF";
+    uint32_t hexSize = sizeof(uint16_t)<<1;
+    char* rc = new char[hexSize + 1]; //Terminate string with 0
+    memset(rc, 0, hexSize + 1);
+
+    for (uint32_t i=0, j=(hexSize-1)*4 ; i<hexSize; ++i,j-=4)
+        rc[i] = digits[(w>>j) & 0x0f];
+    return rc;
+}
+char* Convert::IntToHexString(uint32_t w)
+{
+    static const char* digits = "0123456789ABCDEF";
+    uint32_t hexSize = sizeof(uint32_t)<<1;
+    char* rc = new char[hexSize + 1]; //Terminate string with 0
+    memset(rc, 0, hexSize + 1);
+
+    for (uint32_t i=0, j=(hexSize-1)*4 ; i<hexSize; ++i,j-=4)
+        rc[i] = digits[(w>>j) & 0x0f];
+    return rc;
+}
+
+int Convert::StringToInt(char* string)
+{
+    int result = 0;
+    unsigned int digit;
+    int sign;
+
+    while (IsSpace(*string)) {
+        string += 1;
+    }
+
+    /*
+    * Check for a sign.
+    */
+
+    if (*string == '-') {
+        sign = 1;
+        string += 1;
+    } else {
+        sign = 0;
+        if (*string == '+') {
+            string += 1;
+        }
+    }
+
+    for ( ; ; string += 1) {
+        digit = *string - '0';
+        if (digit > 9) {
+            break;
+        }
+        result = (10*result) + digit;
+    }
+
+    if (sign) {
+        return -result;
+    }
+    return result;
+}
\ No newline at end of file
diff --git a/lib/src/crt/crt0.asm b/lib/src/crt/crt0.asm
new file mode 100644
index 0000000..4cfb915
--- /dev/null
+++ b/lib/src/crt/crt0.asm
@@ -0,0 +1,10 @@
+BITS 32
+
+extern libMain
+
+global _start
+_start:
+	call libMain 	; Defined in lib/src/main.cpp
+_wait: 					; enter infinite loop in the case we don't exit for some reason
+	hlt
+	jmp    _wait
\ No newline at end of file
diff --git a/lib/src/datetime.cpp b/lib/src/datetime.cpp
new file mode 100644
index 0000000..920eee6
--- /dev/null
+++ b/lib/src/datetime.cpp
@@ -0,0 +1,68 @@
+#include <datetime.h>
+#include <syscall.h>
+#include <types.h>
+#include <convert.h>
+#include <string.h>
+#include <log.h>
+
+using namespace LIBCactusOS;
+
+DateTime DateTime::Current()
+{
+    DateTime result;
+    DoSyscall(SYSCALL_GET_DATETIME, (uint32_t)&result);
+    return result;
+}
+
+char* DateTime::ToString()
+{
+    char* fakeSecondsPtr = Convert::IntToString(this->Seconds); int fakeSecondsLen = 2; char* SecondsPtr = new char[2]; if(strlen(fakeSecondsPtr) == 1) { SecondsPtr[0] = '0'; SecondsPtr[1] = fakeSecondsPtr[0]; } else { memcpy(SecondsPtr, fakeSecondsPtr, fakeSecondsLen); }
+    char* fakeMinutesPtr = Convert::IntToString(this->Minutes); int fakeMinutesLen = 2; char* MinutesPtr = new char[2]; if(strlen(fakeMinutesPtr) == 1) { MinutesPtr[0] = '0'; MinutesPtr[1] = fakeMinutesPtr[0]; } else { memcpy(MinutesPtr, fakeMinutesPtr, fakeMinutesLen); }
+    char* fakeHoursPtr = Convert::IntToString(this->Hours); int fakeHoursLen = 2; char* HoursPtr = new char[2]; if(strlen(fakeHoursPtr) == 1) { HoursPtr[0] = '0'; HoursPtr[1] = fakeHoursPtr[0]; } else { memcpy(HoursPtr, fakeHoursPtr, fakeHoursLen); }
+
+    char* fakeDayPtr = Convert::IntToString(this->Day); int fakeDayLen = 2; char* DayPtr = new char[2]; if(strlen(fakeDayPtr) == 1) { DayPtr[0] = '0'; DayPtr[1] = fakeDayPtr[0]; } else { memcpy(DayPtr, fakeDayPtr, fakeDayLen); }
+    char* fakeMonthPtr = Convert::IntToString(this->Month); int fakeMonthLen = 2; char* MonthPtr = new char[2]; if(strlen(fakeMonthPtr) == 1) { MonthPtr[0] = '0'; MonthPtr[1] = fakeMonthPtr[0]; } else { memcpy(MonthPtr, fakeMonthPtr, fakeMonthLen); }
+    char* fakeYearPtr = Convert::IntToString(this->Year); int fakeYearLen = strlen(fakeYearPtr); char* YearPtr = new char[fakeYearLen]; memcpy(YearPtr, fakeYearPtr, fakeYearLen);
+
+    //                Day-Month-Year Seconds-Minute-Hour
+    int totalLength = fakeDayLen + 1 + fakeMonthLen + 1 + fakeYearLen + 1 + fakeSecondsLen + 1 + fakeMinutesLen + 1 + fakeHoursLen;
+
+    static char resultBuffer[60];
+    memset(resultBuffer, 0, 60);
+
+    char* resultPointer = resultBuffer;
+    memcpy(resultPointer, YearPtr, fakeYearLen);
+    resultPointer += fakeYearLen;
+    *resultPointer++ = '-';
+
+    memcpy(resultPointer, MonthPtr, fakeMonthLen);
+    resultPointer += fakeMonthLen;
+    *resultPointer++ = '-';
+
+    memcpy(resultPointer, DayPtr, fakeDayLen);
+    resultPointer += fakeDayLen;
+    *resultPointer++ = ' ';
+
+    memcpy(resultPointer, HoursPtr, fakeHoursLen);
+    resultPointer += fakeHoursLen;
+    *resultPointer++ = ':';
+
+    memcpy(resultPointer, MinutesPtr, fakeMinutesLen);
+    resultPointer += fakeMinutesLen;
+    *resultPointer++ = ':';
+
+    memcpy(resultPointer, SecondsPtr, fakeSecondsLen);
+    resultPointer += fakeSecondsLen;
+
+    //CleanUp
+    delete SecondsPtr;
+    delete MinutesPtr;
+    delete HoursPtr;
+    delete DayPtr;
+    delete MonthPtr;
+    delete YearPtr;
+
+    resultBuffer[totalLength] = '\0';
+
+    return resultBuffer;
+}
\ No newline at end of file
diff --git a/lib/src/gui/canvas.cpp b/lib/src/gui/canvas.cpp
new file mode 100644
index 0000000..5afe4fe
--- /dev/null
+++ b/lib/src/gui/canvas.cpp
@@ -0,0 +1,357 @@
+#include <gui/canvas.h>
+#include <string.h>
+#include <math.h>
+#include <gui/colors.h>
+
+using namespace LIBCactusOS;
+
+Canvas::Canvas(void* buffer, int w, int h)
+{
+    this->Width = w;
+    this->Height = h;
+    this->bufferPointer = buffer;
+}
+
+void Canvas::SetPixel(int x, int y, uint32_t color)
+{
+    *(uint32_t*)((uint32_t)bufferPointer + (y * Width * 4 + x * 4)) = color;
+}
+uint32_t Canvas::GetPixel(int x, int y)
+{
+    return *(uint32_t*)((uint32_t)bufferPointer + (y * Width * 4 + x * 4));
+}
+
+void Canvas::Clear()
+{
+    memset((void*)bufferPointer, 0, Width*Height*4);
+}
+void Canvas::Clear(uint32_t color)
+{
+    uint32_t* buf = (uint32_t*)bufferPointer;       
+    for(uint32_t index = 0; index < (uint32_t)(Width*Height); index++)
+        buf[index] = color;
+}
+void Canvas::DrawHorizontalLine(uint32_t color, int dx, int x1, int y1)
+{
+    for (int i = 0; i < dx; i++)
+        SetPixel(x1 + i, y1, color);
+}
+void Canvas::DrawVerticalLine(uint32_t color, int dy, int x1, int y1)
+{
+    for(int i = 0; i < dy; i++)
+        SetPixel(x1, y1 + i, color);
+}
+void Canvas::DrawDiagonalLine(uint32_t color, int dx, int dy, int x1, int y1)
+{
+    int i, sdx, sdy, dxabs, dyabs, x, y, px, py;
+
+    dxabs = Math::Abs(dx);
+    dyabs = Math::Abs(dy);
+    sdx = Math::Sign(dx);
+    sdy = Math::Sign(dy);
+    x = dyabs >> 1;
+    y = dxabs >> 1;
+    px = x1;
+    py = y1;
+
+    if (dxabs >= dyabs) // the line is more horizontal than vertical
+    {
+        for (i = 0; i < dxabs; i++)
+        {
+            y += dyabs;
+            if (y >= dxabs)
+            {
+                y -= dxabs;
+                py += sdy;
+            }
+            px += sdx;
+            SetPixel(px, py, color);
+        }
+    }
+    else // the line is more vertical than horizontal
+    {
+        for (i = 0; i < dyabs; i++)
+        {
+            x += dxabs;
+            if (x >= dyabs)
+            {
+                x -= dyabs;
+                px += sdx;
+            }
+            py += sdy;
+            SetPixel(px, py, color);
+        }
+    }
+}
+void Canvas::DrawLine(uint32_t color, int x1, int y1, int x2, int y2)
+{
+    int dx, dy;
+
+    dx = x2 - x1;      /* the horizontal distance of the line */
+    dy = y2 - y1;      /* the vertical distance of the line */
+
+    if (dy == 0) /* The line is horizontal */
+    {
+        if(dx < 0)
+            DrawHorizontalLine(color, Math::Abs(dx), x2, y1);
+        else
+            DrawHorizontalLine(color, dx, x1, y1);
+
+        return;
+    }
+
+    if (dx == 0) /* the line is vertical */
+    {
+        if(dy < 0)
+            DrawVerticalLine(color, Math::Abs(dy), x1, y2);
+        else
+            DrawVerticalLine(color, dy, x1, y1);
+        
+        return;
+    }
+
+    /* the line is neither horizontal neither vertical, is diagonal then! */
+    DrawDiagonalLine(color, dx, dy, x1, y1);
+}
+void Canvas::DrawRect(uint32_t color, int x, int y, int width, int height)
+{
+    int xa = x;
+    int ya = y;
+
+    /* The vertex B has the same y coordinate of A but x is moved of width pixels */
+    int xb = x + width;
+    int yb = y;
+
+    /* The vertex C has the same x coordiate of A but this time is y that is moved of height pixels */
+    int xc = x;
+    int yc = y + height;
+
+    /* The Vertex D has x moved of width pixels and y moved of height pixels */
+    int xd = x + width;
+    int yd = y + height;
+
+    /* Draw a line betwen A and B */
+    DrawLine(color, xa, ya, xb, yb);
+
+    /* Draw a line between A and C */
+    DrawLine(color, xa, ya, xc, yc);
+
+    /* Draw a line between B and D */
+    DrawLine(color, xb, yb, xd, yd + 1);
+
+    /* Draw a line between C and D */
+    DrawLine(color, xc, yc, xd, yd);
+}
+
+void Canvas::DrawRoundedRect(uint32_t color, int x, int y, int width, int height, int radius)
+{
+    // Draw the four lines
+    DrawHorizontalLine(color, width - 2 * radius, x + radius, y);               // Top
+    DrawHorizontalLine(color, width - 2 * radius, x + radius, y + height - 1);  // Bottom
+    DrawVerticalLine(color, height - 2 * radius, x, y + radius);                // Left
+    DrawVerticalLine(color, height - 2 * radius, x + width - 1, y + radius);    // Right
+ 
+    // Draw the four corners
+    DrawCircleHelper(x + radius, y + radius, radius, 1, color);
+    DrawCircleHelper(x + width - radius - 1, y + radius, radius, 2, color);
+    DrawCircleHelper(x + width - radius - 1, y + height - radius - 1, radius, 4, color);
+    DrawCircleHelper(x + radius, y + height - radius - 1, radius, 8, color);
+}
+
+void Canvas::DrawFillRoundedRect(uint32_t color, int x, int y, int width, int height, int radius)
+{
+    // Draw the body
+    DrawFillRect(color, x + radius, y, width - 2 * radius + 1, height);
+ 
+    // Draw the four corners
+    FillCircleHelper(x + width - radius - 1, y + radius, radius, 1, height - 2 * radius - 1, color);
+    FillCircleHelper(x + radius, y + radius, radius, 2, height - 2 * radius - 1, color);
+}
+
+void Canvas::DrawFillRect(uint32_t color, int x_start, int y_start, int width, int height)
+{
+    for (int y = y_start; y < y_start + height; y++)
+    {
+        DrawLine(color, x_start, y, x_start + width, y);
+    }
+}
+void Canvas::DrawCircle(uint32_t color, int x, int y, int radius)
+{
+    int f = 1 - radius;
+    int ddF_x = 1;
+    int ddF_y = -2 * radius;
+    int i = 0;
+    int j = radius;
+ 
+    SetPixel(x, y + radius, color);
+    SetPixel(x, y - radius, color);
+    SetPixel(x + radius, y, color);
+    SetPixel(x - radius, y, color);
+ 
+    while(i < j) {
+        if(f >= 0) {
+            j--;
+            ddF_y += 2;
+            f += ddF_y;
+        }
+        i++;
+        ddF_x += 2;
+        f += ddF_x;
+        SetPixel(x + i, y + j, color);
+        SetPixel(x - i, y + j, color);
+        SetPixel(x + i, y - j, color);
+        SetPixel(x - i, y - j, color);
+        SetPixel(x + j, y + i, color);
+        SetPixel(x - j, y + i, color);
+        SetPixel(x + j, y - i, color);
+        SetPixel(x - j, y - i, color);
+    }
+}
+void Canvas::DrawFillCircle(uint32_t color, int x, int y, int radius)
+{
+    this->DrawVerticalLine(color, 2 * radius + 1, x, y - radius);
+    this->FillCircleHelper(x, y, radius, 3, 0, color);
+}
+void Canvas::DrawEllipse(uint32_t color, int x_center, int y_center, int x_radius, int y_radius)
+{
+    int a = 2 * x_radius;
+    int b = 2 * y_radius;
+    int b1 = b & 1;
+    int dx = 4 * (1 - a) * b * b;
+    int dy = 4 * (b1 + 1) * a * a;
+    int err = dx + dy + b1 * a * a;
+    int e2;
+    int y = 0;
+    int x = x_radius;
+    a *= 8 * a;
+    b1 = 8 * b * b;
+
+    while (x >= 0)
+    {
+        SetPixel(x_center + x, y_center + y, color);
+        SetPixel(x_center - x, y_center + y, color);
+        SetPixel(x_center - x, y_center - y, color);
+        SetPixel(x_center + x, y_center - y, color);
+        e2 = 2 * err;
+        if (e2 <= dy) { y++; err += dy += a; }
+        if (e2 >= dx || 2 * err > dy) { x--; err += dx += b1; }
+    }
+}
+
+void Canvas::DrawString(Font* font, char* string, int x, int y, uint32_t color)
+{
+    if(font == 0 || string == 0 || color == Colors::Transparent)
+        return;
+    
+    int xOffset = x;
+    int yOffset = y;
+    while(*string)
+    {
+        // Get the character we need to draw for this string
+        char c = *string++;
+
+        // Check for newline
+        if(c == '\n') {
+            xOffset = x;
+
+            // Add the height of the space character. TODO: Update this!
+            yOffset += ((uint8_t*)(font->data + font->offsetTable[0]))[1];
+            continue;
+        }
+
+        // Load data for this char from the font
+        const uint8_t* charData = (uint8_t*)(font->data + font->offsetTable[(int)c - 32]);
+        const uint8_t width = charData[0];
+        const uint8_t height = charData[1];
+
+        // Loop through the complete bitmap and draw the character
+        for(uint8_t px = 0; px < width; px++) {
+            for(uint8_t py = 0; py < height; py++) {
+                // Can be any value between 0 and 255
+                uint8_t d = charData[py * width + px + 2];
+                
+                // This pixel does not need to be drawn
+                if(d == 0)
+                    continue;
+
+                // This is a full color pixel
+                if(d == 255)
+                    this->SetPixel(px + xOffset, py + yOffset, color);
+                // We need to blend this pixel with the background
+                else {
+                    Color4 realColor;
+                    realColor.c = color;
+                    realColor.argb.a = d; // Adjust the alpha component of the color. TODO: Also support full transparent text drawing in the future!
+
+                    this->SetPixel(px + xOffset, py + yOffset, Colors::AlphaBlend(this->GetPixel(px + xOffset, py + yOffset), realColor.c));
+                }  
+            }
+        }
+
+        xOffset += width;
+    }
+}
+void Canvas::DrawCircleHelper(int x, int y, int radius, uint32_t corner, uint32_t color)
+{
+    int f = 1 - radius;
+    int ddF_x = 1;
+    int ddF_y = -2 * radius;
+    int i = 0;
+    int j = radius;
+ 
+    while (i < j) {
+        if (f >= 0) {
+            j--;
+            ddF_y += 2;
+            f += ddF_y;
+        }
+        i++;
+        ddF_x += 2;
+        f += ddF_x;
+        if (corner & 0x4) {
+            SetPixel(x + i, y + j, color);
+            SetPixel(x + j, y + i, color);
+        }
+        if (corner & 0x2) {
+            SetPixel(x + i, y - j, color);
+            SetPixel(x + j, y - i, color);
+        }
+        if (corner & 0x8) {
+            SetPixel(x - j, y + i, color);
+            SetPixel(x - i, y + j, color);
+        }
+        if (corner & 0x1) {
+            SetPixel(x - j, y - i, color);
+            SetPixel(x - i, y - j, color);
+        }
+    }
+}
+ 
+void Canvas::FillCircleHelper(int x, int y, int radius, uint32_t corner, int delta, uint32_t color)
+{
+    int f = 1 - radius;
+    int ddF_x = 1;
+    int ddF_y = -2 * radius;
+    int i = 0;
+    int j = radius;
+ 
+    while (i < j) {
+        if (f >= 0) {
+            j--;
+            ddF_y += 2;
+            f += ddF_y;
+        }
+        i++;
+        ddF_x += 2;
+        f += ddF_x;
+ 
+        if (corner & 0x1) {
+            DrawVerticalLine(color, 2 * j + 1 + delta, x + i, y - j);
+            DrawVerticalLine(color, 2 * i + 1 + delta, x + j, y - i);
+        }
+        if (corner & 0x2) {
+            DrawVerticalLine(color, 2 * j + 1 + delta, x - i, y - j);
+            DrawVerticalLine(color, 2 * i + 1 + delta, x - j, y - i);
+        }
+    }
+}
\ No newline at end of file
diff --git a/lib/src/gui/colors.cpp b/lib/src/gui/colors.cpp
new file mode 100644
index 0000000..af85957
--- /dev/null
+++ b/lib/src/gui/colors.cpp
@@ -0,0 +1,32 @@
+#include <gui/colors.h>
+
+using namespace LIBCactusOS;
+
+static const int AMASK = 0xFF000000;
+static const int RBMASK = 0x00FF00FF;
+static const int GMASK = 0x0000FF00;
+static const int AGMASK = AMASK | GMASK;
+static const int ONEALPHA = 0x01000000;
+
+const uint32_t Colors::AlphaBlend(uint32_t color1, uint32_t color2)
+{
+    uint32_t a = (color2 & AMASK) >> 24;
+
+    if(a == 0)
+        return color1;
+    else if(a == 255)
+        return color2;
+    else
+    {
+        uint32_t na = 255 - a;
+        uint32_t rb = ((na * (color1 & RBMASK)) + (a * (color2 & RBMASK))) >> 8;
+        uint32_t ag = (na * ((color1 & AGMASK) >> 8)) + (a * (ONEALPHA | ((color2 & GMASK) >> 8)));
+
+        return ((rb & RBMASK) | (ag & AGMASK));
+    }
+}
+
+const uint32_t Colors::FromARGB(uint8_t a, uint8_t r, uint8_t g, uint8_t b)
+{
+    return ((uint32_t)a << 24) | ((uint32_t)r << 16) | ((uint32_t)g << 8) | (uint32_t)b;
+}
\ No newline at end of file
diff --git a/lib/src/gui/context.cpp b/lib/src/gui/context.cpp
new file mode 100644
index 0000000..ceab0ee
--- /dev/null
+++ b/lib/src/gui/context.cpp
@@ -0,0 +1,160 @@
+#include <gui/context.h>
+#include <log.h>
+#include <ipc.h>
+#include <syscall.h>
+#include <gui/gui.h>
+#include <gui/contextheap.h>
+#include <heap.h>
+
+using namespace LIBCactusOS;
+
+Context::Context(uint32_t framebufferAddr, int width, int height)
+{
+    this->Window = 0;
+    this->canvas = new Canvas((void*)framebufferAddr, width, height);
+    this->sharedContextInfo = 0;
+}
+
+void Context::DrawGUI()
+{
+    if(this->Window && this->Window->needsRepaint) {
+        this->Window->DrawTo(this->canvas, 0, 0);
+        this->Window->needsRepaint = false;
+        this->sharedContextInfo->AddDirtyArea(0, 0, this->Window->width, this->Window->height);
+    }
+}
+
+void Context::DrawStringAligned(Canvas* target, Font* font, char* string, uint32_t color, Rectangle bounds, Alignment align, int xoff, int yoff)
+{
+    if(target == 0 || font == 0 || string == 0)
+        return;
+    
+    Rectangle textBounds;
+    font->BoundingBox(string, &textBounds.width, &textBounds.height);
+
+    int x = 0;
+    int y = 0;
+    
+    switch(align.x) {
+        case Alignment::Horizontal::Left:
+            x = 0;
+            break;
+        case Alignment::Horizontal::Center:
+            x = bounds.width/2 - textBounds.width/2;
+            break;
+        case Alignment::Horizontal::Right:
+            x = bounds.width - textBounds.width;
+            break;
+    }
+    switch(align.y) {
+        case Alignment::Vertical::Top:
+            y = 0;
+            break;
+        case Alignment::Vertical::Center:
+            y = bounds.height/2 - textBounds.height/2;
+            break;
+        case Alignment::Vertical::Bottom:
+            y = bounds.height - textBounds.height;
+            break;
+    }
+
+    target->DrawString(font, string, x + xoff, y + yoff, color);
+}
+
+void Context::MoveToPosition(int newX, int newY)
+{
+    int oldX = this->sharedContextInfo->x;
+    int oldY = this->sharedContextInfo->y;
+
+    this->sharedContextInfo->x = newX;
+    this->sharedContextInfo->y = newY;
+
+    if(this->Window)
+    {
+        this->Window->x = newX;
+        this->Window->y = newY;
+    }
+
+    IPCSend(GUI::compositorPID, IPCMessageType::GUIRequest, GUICommunction::CONTEXT_MOVED, oldX, oldY, this->sharedContextInfo->width, this->sharedContextInfo->height);
+    this->sharedContextInfo->AddDirtyArea(0, 0, this->sharedContextInfo->width, this->sharedContextInfo->height);
+}
+
+void Context::CloseContext()
+{
+    ContextHeap::FreeArea(this->sharedContextInfo->virtAddrClient - CONTEXT_INFO_SIZE, pageRoundUp(this->sharedContextInfo->bytes) / 0x1000);
+    GUI::contextList->Remove(this);
+    if(this->canvas != 0)
+        delete this->canvas;
+
+    IPCSend(GUI::compositorPID, IPCMessageType::GUIRequest, GUICommunction::REQUEST_CLOSE, this->sharedContextInfo->id);
+    if(ICPReceive(GUI::compositorPID, 0, IPCMessageType::GUIRequest).arg1 != 1)
+        Log(Error, "Did not receive ack from compositor when removing context");
+}
+
+void Context::OnMouseDown(int x_abs, int y_abs, uint8_t button)
+{
+    this->MouseDown.Invoke(this, MouseButtonArgs(x_abs, y_abs, button));
+
+    if(this->Window == 0)
+        return;
+
+    Window->OnMouseDown(x_abs, y_abs, button);
+}
+void Context::OnMouseUp(int x_abs, int y_abs, uint8_t button)
+{    
+    this->MouseUp.Invoke(this, MouseButtonArgs(x_abs, y_abs, button));
+    this->MouseClick.Invoke(this, MouseButtonArgs(x_abs, y_abs, button));
+
+    if(this->Window == 0)
+        return;
+    
+    Window->OnMouseUp(x_abs, y_abs, button);
+}
+void Context::OnMouseMove(int prevX_abs, int prevY_abs, int newX_abs, int newY_abs)
+{
+    if(this->Window == 0)
+        return;
+    
+    Window->OnMouseMove(prevX_abs, prevY_abs, newX_abs, newY_abs);
+}
+void Context::OnKeyDown(uint8_t key, KEYPACKET_FLAGS modifiers)
+{
+    this->KeyDown.Invoke(this, KeypressArgs(key, modifiers));
+    
+    if(this->Window == 0)
+        return;
+    
+    Window->OnKeyDown(key, modifiers);
+}
+void Context::OnKeyUp(uint8_t key, KEYPACKET_FLAGS modifiers)
+{
+    this->KeyUp.Invoke(this, KeypressArgs(key, modifiers));
+    
+    if(this->Window == 0)
+        return;
+    
+    Window->OnKeyUp(key, modifiers);
+}
+void Context::OnResize(Rectangle oldSize)
+{
+    this->canvas->Width = this->sharedContextInfo->width;
+    this->canvas->Height = this->sharedContextInfo->height;
+    
+    if(this->Window == 0 || this->sharedContextInfo == 0)
+        return;
+    
+    Window->x = this->sharedContextInfo->x;
+    Window->y = this->sharedContextInfo->y;
+    Window->width = this->sharedContextInfo->width;
+    Window->height = this->sharedContextInfo->height;
+    Window->OnResize(oldSize);
+}
+void Context::OnScroll(int32_t deltaZ, int x_abs, int y_abs)
+{
+    this->MouseScroll.Invoke(this, MouseScrollArgs(deltaZ, x_abs, y_abs));
+    
+    if(this->Window == 0)
+        return;
+    
+    Window->OnScroll(deltaZ, x_abs, y_abs);
+}
\ No newline at end of file
diff --git a/lib/src/gui/contextheap.cpp b/lib/src/gui/contextheap.cpp
new file mode 100644
index 0000000..6a0f2ca
--- /dev/null
+++ b/lib/src/gui/contextheap.cpp
@@ -0,0 +1,111 @@
+#include <gui/contextheap.h>
+#include <list.h>
+#include <string.h>
+#include <proc.h>
+
+using namespace LIBCactusOS;
+
+#define ENTRIES_PER_BYTE 8
+#define ARRAY_ENTRY_SIZE 4
+#define ARRAY_ENTRIES (blockCount / ENTRIES_PER_BYTE / ARRAY_ENTRY_SIZE)
+
+const int blockSize = 0x1000;
+const uint32_t startAddress = 0xA0000000;
+const uint32_t endAddress = 0xAB000000;
+
+uint32_t* memoryBitmap = 0;
+uint32_t blockCount = 0;
+
+//To create thread safety for memory allocation
+DECLARE_LOCK(bitmapOpperation);
+
+inline void SetBit(uint32_t bit)
+{
+    memoryBitmap[bit / 32] |= (1 << (bit % 32));
+}
+inline void UnsetBit(uint32_t bit)
+{
+    memoryBitmap[bit / 32] &= ~ (1 << (bit % 32));
+}
+inline bool TestBit(uint32_t bit)
+{
+    return memoryBitmap[bit / 32] & (1 << (bit % 32));
+}
+
+
+uint32_t FirstFreeSize(uint32_t size)
+{
+    for (uint32_t i = 0; i < ARRAY_ENTRIES; i++)
+        if (memoryBitmap[i] != 0xFFFFFFFF) //Completely used
+            for (int j = 0; j < (ENTRIES_PER_BYTE * ARRAY_ENTRY_SIZE); j++) {
+                if ((memoryBitmap[i] & (1<<j)) == 0) //Test if bit is unset
+                {
+                    uint32_t startingBit = i * (ENTRIES_PER_BYTE * ARRAY_ENTRY_SIZE);
+                    startingBit += j; //Calculate bit offset in total array
+
+                    uint32_t free = 0; //Loop through each bit to see if its enough space
+                    for (uint32_t count = 0; count <= size; count++)
+                    {
+                        if (!TestBit(startingBit + count))
+                            free++; // this bit is clear (free frame)
+
+                        if (free == size)
+                            return (i * ENTRIES_PER_BYTE * ARRAY_ENTRY_SIZE) + j; //free count==size needed; return index
+                    }
+                }
+            }
+
+    return -1;
+}
+
+void ContextHeap::Init()
+{
+    //Calculate amount of blocks
+    blockCount = (endAddress - startAddress) / blockSize;
+    
+    //Allocate bitmap
+    memoryBitmap = new uint32_t[ARRAY_ENTRIES];
+
+    //All memory is free at the start
+    memset(memoryBitmap, 0x00, ARRAY_ENTRIES * sizeof(uint32_t));
+}
+uint32_t ContextHeap::AllocateArea(uint32_t blocks)
+{
+    LOCK(bitmapOpperation);
+    uint32_t frame = FirstFreeSize(blocks);
+
+    if (frame == (uint32_t)-1) {
+        UNLOCK(bitmapOpperation);
+        return 0; //not enough space
+    }
+
+    for (uint32_t i = 0; i < blocks; i++)
+        SetBit(frame + i);
+
+    UNLOCK(bitmapOpperation);
+    return startAddress + frame * blockSize; 
+}
+void ContextHeap::FreeArea(uint32_t addr, uint32_t blocks)
+{
+    addr -= startAddress;
+    uint32_t frame = addr / blockSize;
+
+    LOCK(bitmapOpperation);
+    for (uint32_t i = 0; i < blocks; i++)
+        UnsetBit(frame + i);
+    UNLOCK(bitmapOpperation);
+}
+double ContextHeap::MemoryUsage()
+{
+    uint32_t usedCount = 0;
+    for (uint32_t i = 0; i < ARRAY_ENTRIES; i++) {
+        if(memoryBitmap[i] == 0xFFFFFFFF)
+            usedCount += 32;
+        else
+            for (int j = 0; j < 32; j++) {
+                if (memoryBitmap[i] & (1<<j))
+                    usedCount++;
+            }
+    }
+    return ((double)usedCount / (double)blockCount);
+}
\ No newline at end of file
diff --git a/lib/src/gui/directgui.cpp b/lib/src/gui/directgui.cpp
new file mode 100644
index 0000000..9293bf1
--- /dev/null
+++ b/lib/src/gui/directgui.cpp
@@ -0,0 +1,116 @@
+#include <gui/directgui.h>
+#include <gui/canvas.h>
+#include <gui/gui.h>
+#include <log.h>
+#include <syscall.h>
+#include <string.h>
+#include <heap.h>
+#include <systeminfo.h>
+#include <math.h>
+
+using namespace LIBCactusOS;
+
+Canvas* base = 0;
+
+uint8_t directGUIFont[] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x24, 0x00, 0x00, 0x00, 0x00, 0x10, 0x08, 0x20, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x24, 0x00, 0x08, 0x00, 0x00, 0x10, 0x10, 0x10, 0x54, 0x00, 0x00, 0x00, 0x00, 0x04, 0x38, 0x08, 0x3c, 0x7e, 0x04, 0x3e, 0x3c, 0x7e, 0x18, 0x3c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x18, 0x70, 0x3c, 0x78, 0x7e, 0x7e, 0x3c, 0x42, 0x7c, 0x7e, 0x44, 0x40, 0x41, 0x42, 0x3c, 0x7c, 0x3c, 0x7c, 0x3c, 0x7f, 0x42, 0x42, 0x41, 0x42, 0x44, 0x7e, 0x1c, 0x40, 0x38, 0x10, 0x00, 0x30, 0x00, 0x40, 0x00, 0x02, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x20, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x08, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x24, 0x12, 0x1c, 0x40, 0x18, 0x10, 0x10, 0x10, 0x38, 0x00, 0x00, 0x00, 0x00, 0x04, 0x4c, 0x18, 0x42, 0x02, 0x0c, 0x20, 0x42, 0x02, 0x24, 0x42, 0x10, 0x00, 0x00, 0x00, 0x00, 0x24, 0x38, 0x24, 0x48, 0x42, 0x44, 0x40, 0x40, 0x42, 0x42, 0x10, 0x04, 0x44, 0x40, 0x63, 0x62, 0x42, 0x42, 0x42, 0x42, 0x42, 0x08, 0x42, 0x42, 0x41, 0x42, 0x44, 0x02, 0x10, 0x40, 0x08, 0x28, 0x00, 0x10, 0x00, 0x40, 0x00, 0x02, 0x00, 0x0c, 0x00, 0x40, 0x00, 0x00, 0x20, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x08, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x48, 0x12, 0x2a, 0xa2, 0x20, 0x10, 0x20, 0x08, 0x28, 0x10, 0x00, 0x00, 0x00, 0x08, 0x4c, 0x28, 0x42, 0x04, 0x14, 0x40, 0x40, 0x04, 0x24, 0x42, 0x10, 0x10, 0x02, 0x00, 0x40, 0x42, 0x44, 0x42, 0x44, 0x40, 0x42, 0x40, 0x40, 0x40, 0x42, 0x10, 0x04, 0x48, 0x40, 0x63, 0x62, 0x42, 0x42, 0x42, 0x42, 0x40, 0x08, 0x42, 0x42, 0x41, 0x24, 0x44, 0x02, 0x10, 0x20, 0x08, 0x44, 0x00, 0x00, 0x00, 0x40, 0x00, 0x02, 0x00, 0x12, 0x00, 0x40, 0x10, 0x04, 0x20, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x08, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x7f, 0x28, 0xa4, 0x10, 0x00, 0x20, 0x08, 0x28, 0x10, 0x00, 0x00, 0x00, 0x08, 0x4c, 0x08, 0x02, 0x18, 0x24, 0x40, 0x40, 0x08, 0x18, 0x42, 0x00, 0x00, 0x0c, 0x7e, 0x30, 0x02, 0x82, 0x42, 0x44, 0x40, 0x42, 0x40, 0x40, 0x40, 0x42, 0x10, 0x04, 0x50, 0x40, 0x55, 0x52, 0x42, 0x42, 0x42, 0x42, 0x20, 0x08, 0x42, 0x42, 0x41, 0x24, 0x44, 0x04, 0x10, 0x20, 0x08, 0x00, 0x00, 0x00, 0x38, 0x40, 0x00, 0x02, 0x00, 0x10, 0x1e, 0x40, 0x00, 0x00, 0x20, 0x10, 0x54, 0x2c, 0x3c, 0x5c, 0x3c, 0x2c, 0x1c, 0x3e, 0x24, 0x22, 0x44, 0x42, 0x24, 0x3e, 0x10, 0x08, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x24, 0x18, 0x48, 0x20, 0x00, 0x20, 0x08, 0x00, 0x7c, 0x00, 0x7e, 0x00, 0x10, 0x54, 0x08, 0x02, 0x04, 0x44, 0x7c, 0x5c, 0x08, 0x24, 0x3e, 0x00, 0x00, 0x30, 0x00, 0x0c, 0x04, 0x92, 0x42, 0x78, 0x40, 0x42, 0x7c, 0x7c, 0x40, 0x42, 0x10, 0x04, 0x60, 0x40, 0x55, 0x52, 0x42, 0x7c, 0x42, 0x7c, 0x18, 0x08, 0x42, 0x42, 0x49, 0x18, 0x28, 0x08, 0x10, 0x10, 0x08, 0x00, 0x00, 0x00, 0x04, 0x5c, 0x3c, 0x3a, 0x3c, 0x10, 0x22, 0x40, 0x00, 0x04, 0x22, 0x10, 0x2a, 0x12, 0x42, 0x22, 0x44, 0x12, 0x22, 0x10, 0x24, 0x22, 0x44, 0x22, 0x24, 0x02, 0x20, 0x08, 0x04, 0x32, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x24, 0x0c, 0x10, 0x52, 0x00, 0x20, 0x08, 0x00, 0x10, 0x00, 0x00, 0x00, 0x10, 0x54, 0x08, 0x04, 0x02, 0x44, 0x02, 0x62, 0x10, 0x42, 0x02, 0x00, 0x00, 0x40, 0x00, 0x02, 0x08, 0xaa, 0x7e, 0x44, 0x40, 0x42, 0x40, 0x40, 0x4e, 0x7e, 0x10, 0x04, 0x50, 0x40, 0x49, 0x4a, 0x42, 0x40, 0x42, 0x50, 0x04, 0x08, 0x42, 0x42, 0x49, 0x18, 0x10, 0x10, 0x10, 0x10, 0x08, 0x00, 0x00, 0x00, 0x3c, 0x62, 0x42, 0x46, 0x42, 0x3c, 0x22, 0x5c, 0x10, 0x04, 0x2c, 0x10, 0x2a, 0x12, 0x42, 0x22, 0x44, 0x10, 0x20, 0x10, 0x24, 0x22, 0x54, 0x24, 0x24, 0x04, 0x10, 0x08, 0x08, 0x4c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0xfe, 0x0a, 0x22, 0x4a, 0x00, 0x20, 0x08, 0x00, 0x10, 0x00, 0x00, 0x00, 0x20, 0x54, 0x08, 0x08, 0x02, 0x7e, 0x02, 0x42, 0x10, 0x42, 0x02, 0x10, 0x10, 0x30, 0x7e, 0x0c, 0x10, 0xaa, 0x42, 0x42, 0x40, 0x42, 0x40, 0x40, 0x42, 0x42, 0x10, 0x44, 0x48, 0x40, 0x49, 0x4a, 0x42, 0x40, 0x42, 0x4c, 0x02, 0x08, 0x42, 0x24, 0x49, 0x24, 0x10, 0x20, 0x10, 0x08, 0x08, 0x00, 0x00, 0x00, 0x44, 0x42, 0x40, 0x42, 0x7e, 0x10, 0x1e, 0x62, 0x10, 0x04, 0x30, 0x10, 0x2a, 0x12, 0x42, 0x32, 0x3c, 0x10, 0x1c, 0x10, 0x24, 0x22, 0x54, 0x18, 0x1c, 0x08, 0x08, 0x08, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x0a, 0x45, 0x44, 0x00, 0x20, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x64, 0x08, 0x10, 0x02, 0x04, 0x42, 0x42, 0x10, 0x42, 0x02, 0x10, 0x10, 0x0c, 0x00, 0x30, 0x10, 0x94, 0x42, 0x42, 0x40, 0x42, 0x40, 0x40, 0x42, 0x42, 0x10, 0x44, 0x44, 0x40, 0x41, 0x46, 0x42, 0x40, 0x4a, 0x42, 0x42, 0x08, 0x42, 0x24, 0x49, 0x24, 0x10, 0x40, 0x10, 0x08, 0x08, 0x00, 0x00, 0x00, 0x44, 0x42, 0x40, 0x42, 0x40, 0x10, 0x02, 0x42, 0x10, 0x04, 0x28, 0x10, 0x2a, 0x12, 0x42, 0x2c, 0x04, 0x10, 0x02, 0x10, 0x24, 0x22, 0x54, 0x24, 0x04, 0x10, 0x08, 0x08, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x2a, 0x05, 0x3a, 0x00, 0x10, 0x10, 0x00, 0x00, 0x20, 0x00, 0x00, 0x40, 0x64, 0x08, 0x20, 0x44, 0x04, 0x42, 0x42, 0x10, 0x42, 0x04, 0x00, 0x20, 0x02, 0x00, 0x40, 0x00, 0x40, 0x42, 0x42, 0x42, 0x44, 0x40, 0x40, 0x42, 0x42, 0x10, 0x44, 0x42, 0x40, 0x41, 0x46, 0x42, 0x40, 0x44, 0x42, 0x42, 0x08, 0x42, 0x24, 0x49, 0x42, 0x10, 0x40, 0x10, 0x04, 0x08, 0x00, 0x00, 0x00, 0x44, 0x62, 0x42, 0x46, 0x42, 0x10, 0x22, 0x42, 0x10, 0x24, 0x24, 0x10, 0x2a, 0x12, 0x42, 0x20, 0x04, 0x10, 0x22, 0x10, 0x24, 0x14, 0x54, 0x44, 0x04, 0x20, 0x08, 0x08, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x1c, 0x02, 0x00, 0x00, 0x10, 0x10, 0x00, 0x00, 0x20, 0x00, 0x00, 0x40, 0x38, 0x08, 0x7e, 0x38, 0x04, 0x3c, 0x3c, 0x10, 0x3c, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x38, 0x42, 0x7c, 0x3c, 0x78, 0x7e, 0x40, 0x3c, 0x42, 0x7c, 0x38, 0x42, 0x7e, 0x41, 0x42, 0x3c, 0x40, 0x3a, 0x42, 0x3c, 0x08, 0x3c, 0x18, 0x36, 0x42, 0x10, 0x7e, 0x1c, 0x04, 0x38, 0x00, 0x7f, 0x00, 0x3a, 0x5c, 0x3c, 0x3a, 0x3c, 0x10, 0x1c, 0x42, 0x08, 0x18, 0x22, 0x08, 0x2a, 0x12, 0x3c, 0x20, 0x02, 0x10, 0x1c, 0x0e, 0x1a, 0x08, 0x2a, 0x42, 0x38, 0x3e, 0x08, 0x08, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x20, 0x00, 0x00, 0x40, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x60, 0x00, 0x00};
+
+bool DirectGUI::RequestFramebuffer()
+{
+    Log(Info, "This process is requesting a direct framebuffer");
+
+    uint32_t addr = SYSTEM_INFO_ADDR /* System Info Area */ - pageRoundUp(GUI::Width * GUI::Height * 4) /* Space needed for FB */ - 4_KB /* 1 page margin */;
+    bool ret = DoSyscall(SYSCALL_GUI_GETLFB, addr);
+    if(ret)
+        base = new Canvas((void*)addr, GUI::Width, GUI::Height);
+    
+    return ret;
+}
+
+Canvas* DirectGUI::GetCanvas()
+{
+    return base;
+}
+
+void DirectGUI::SetPixel(int x, int y, uint32_t color)
+{
+    base->SetPixel(x, y, color);
+}
+uint32_t DirectGUI::GetPixel(int x, int y)
+{
+    return base->GetPixel(x, y);
+}
+
+void DirectGUI::Clear()
+{
+    base->Clear();
+}
+void DirectGUI::Clear(uint32_t color)
+{
+    base->Clear(color);
+}
+void DirectGUI::DrawHorizontalLine(uint32_t color, int dx, int x1, int y1)
+{
+    base->DrawHorizontalLine(color, dx, x1, y1);
+}
+void DirectGUI::DrawVerticalLine(uint32_t color, int dx, int x1, int y1)
+{
+    base->DrawVerticalLine(color, dx, x1, y1);
+}
+void DirectGUI::DrawDiagonalLine(uint32_t color, int dx, int dy, int x1, int y1)
+{
+    base->DrawDiagonalLine(color, dx, dy, x1, y1);
+}
+void DirectGUI::DrawLine(uint32_t color, int x1, int y1, int x2, int y2)
+{
+    base->DrawLine(color, x1, y1, x2, y2);
+}
+void DirectGUI::DrawRect(uint32_t color, int x, int y, int width, int height)
+{
+    base->DrawRect(color, x, y, width, height);
+}
+void DirectGUI::DrawFillRect(uint32_t color, int x_start, int y_start, int width, int height)
+{
+    base->DrawFillRect(color, x_start, y_start, width, height);
+}
+void DirectGUI::DrawCircle(uint32_t color, int x_center, int y_center, int radius)
+{
+    base->DrawCircle(color, x_center, y_center, radius);
+}
+void DirectGUI::DrawFillCircle(uint32_t color, int x_center, int y_center, int radius)
+{
+    base->DrawFillCircle(color, x_center, y_center, radius);
+}
+void DirectGUI::DrawEllipse(uint32_t color, int x_center, int y_center, int x_radius, int y_radius)
+{
+    base->DrawEllipse(color, x_center, y_center, x_radius, y_radius);
+}
+void DirectGUI::DrawChar(char character, int x, int y, uint32_t color)
+{
+    int font_x, font_y;
+    int count_x = 8;
+    int count_y = 12; 
+    uint8_t shift_line;
+
+    character &= 0x7F;
+
+    for(font_y = 0; font_y < count_y; font_y++) {
+        shift_line = directGUIFont[font_y * 128 + character];
+        for(font_x = 0; font_x < count_x; font_x++) {
+            if(shift_line & 0x80)
+                SetPixel(font_x + x, font_y + y, color);
+ 
+            shift_line <<= 1; 
+        }
+    }
+}
+void DirectGUI::DrawString(char* string, int x, int y, uint32_t color)
+{
+    int dx = x;
+    for( ; *string; dx += 8) {
+        if(*(string) == '\n') {
+            dx = x-8; y += 14; string++; 
+        }
+        else
+            DrawChar(*(string++), dx, y, color);
+    }
+}
\ No newline at end of file
diff --git a/lib/src/gui/fonts/font.cpp b/lib/src/gui/fonts/font.cpp
new file mode 100644
index 0000000..aa63fb7
--- /dev/null
+++ b/lib/src/gui/fonts/font.cpp
@@ -0,0 +1,52 @@
+#include <gui/fonts/font.h>
+
+using namespace LIBCactusOS;
+
+void Font::BoundingBox(char* string, int* retW, int* retH)
+{
+    if(string == 0 || retW == 0 || retH == 0)
+        return; // Error with arguments
+
+    if(this->data == 0)
+        return; // Not initialized
+    
+    // Reset variables
+    *retW = 0;
+    *retH = 0;
+    
+
+    int xOffset = 0;
+    int yOffset = 0;
+    while(*string)
+    {
+        // Get the character we need to draw for this string
+        char c = *string++;
+
+        // Set initial values for first character
+        if(xOffset == 0 && yOffset == 0)
+            yOffset = ((uint8_t*)(this->data + this->offsetTable[0]))[1];
+
+        // Check for newline
+        if(c == '\n') {
+            if(xOffset > *retW)
+                *retW = xOffset;
+            
+            xOffset = 0;
+
+            // Add the height of the space character. TODO: Update this!
+            yOffset += ((uint8_t*)(this->data + this->offsetTable[0]))[1] + 1;
+            continue;
+        }
+
+        // Load data for this char from the font
+        const uint8_t* charData = (uint8_t*)(this->data + this->offsetTable[(int)c - 32]);
+        xOffset += charData[0];
+    }
+
+    // Update return values
+    // retW might already be correctly set by another line of text
+    if(xOffset > *retW)
+        *retW = xOffset;
+    
+    *retH = yOffset;
+}
\ No newline at end of file
diff --git a/lib/src/gui/fonts/fontparser.cpp b/lib/src/gui/fonts/fontparser.cpp
new file mode 100644
index 0000000..f4e967f
--- /dev/null
+++ b/lib/src/gui/fonts/fontparser.cpp
@@ -0,0 +1,41 @@
+#include <gui/fonts/fontparser.h>
+#include <vfs.h>
+#include <string.h>
+#include <log.h>
+
+
+using namespace LIBCactusOS;
+
+Font* FontParser::FromFile(char* filename)
+{
+    if(FileExists(filename) == false)
+        return 0;
+
+    uint32_t fileSize = GetFileSize(filename);
+    if((int)fileSize == -1)
+        return 0;
+
+    uint8_t* filebuffer = new uint8_t[fileSize];
+    if(ReadFile(filename, filebuffer) != 0) {
+        delete filebuffer;
+        return 0;
+    }
+
+
+    // Place CFF header over buffer
+    CFFHeader* header = (CFFHeader*)filebuffer;
+    if(header->Magic != 0xCFF || header->Version != 1) {
+        delete filebuffer;
+        return 0;
+    }
+    
+    Print("Parsing font %s, size = %d Points\n", (char*)(filebuffer + header->FontNameOffset), header->FontSize);
+    
+    Font* result = new Font();
+    result->data = filebuffer;
+    result->name = (char*)(filebuffer + header->FontNameOffset);
+    result->offsetTable = header->CharacterOffsets;
+    result->size = header->FontSize;
+
+    return result;
+}
\ No newline at end of file
diff --git a/lib/src/gui/gui.cpp b/lib/src/gui/gui.cpp
new file mode 100644
index 0000000..3688913
--- /dev/null
+++ b/lib/src/gui/gui.cpp
@@ -0,0 +1,230 @@
+#include <gui/gui.h>
+#include <ipc.h>
+#include <heap.h>
+#include <syscall.h>
+#include <log.h>
+#include <proc.h>
+#include <time.h>
+#include <gui/contextinfo.h>
+#include <gui/contextheap.h>
+#include <gui/directgui.h>
+#include <gui/widgets/window.h>
+#include <gui/fonts/fontparser.h>
+
+using namespace LIBCactusOS;
+
+int GUI::Width = 0;
+int GUI::Height = 0;
+
+List<Context*>* GUI::contextList = 0;
+int GUI::compositorPID = 3;
+Font* GUI::defaultFont = 0;
+
+void GUI::Initialize()
+{
+    GUI::defaultFont = 0;
+    GUI::contextList = new List<Context*>();
+    ContextHeap::Init();
+
+    if(DoSyscall(SYSCALL_GET_SCREEN_PROPERTIES, (uint32_t)&GUI::Width, (uint32_t)&GUI::Height) == 0)
+        Log(Error, "Error while requesting screen info");
+}
+
+void GUI::SetDefaultFont(const char* filename)
+{
+    GUI::defaultFont = FontParser::FromFile((char*)filename);
+}
+
+void GUI::CleanUp()
+{
+    if(contextList != 0)
+    {
+        for(Context* c : *contextList)
+        {
+            c->CloseContext();
+            delete c;
+        }
+        contextList->Clear();
+    }
+}
+
+void GUI::ProcessEvents()
+{
+    /*
+    +--------+--------------------+
+    | guiEvent Message           |
+    +--------+--------------------+
+    | type   | IPC_TYPE_GUI_EVENT |
+    | source |   Message source   |
+    | dest   |     That is us     |
+    | arg1   | Type of gui event  |
+    | arg2/6 |  Depends on event  |
+    +--------+--------------------+
+    */
+
+    IPCMessage guiEvent = ICPReceive(compositorPID, 0, IPCMessageType::GUIEvent);
+    //Print("GUI: Got event from compositor type=%d\n", guiEvent.arg1);
+    
+    int guiEventType = guiEvent.arg1;
+    if(guiEventType == GUIEvents::MouseDown)
+    {
+        Context* targetControl = FindTargetContext((int)guiEvent.arg2, (int)guiEvent.arg3);
+        if(targetControl == 0)
+            return;
+
+        //Print("Sending Mousedown to context %x\n", (uint32_t)targetControl);
+        targetControl->OnMouseDown(guiEvent.arg2 - targetControl->sharedContextInfo->x, guiEvent.arg3 - targetControl->sharedContextInfo->y, guiEvent.arg4);
+    }
+    else if(guiEventType == GUIEvents::MouseUp)
+    {
+        Context* targetControl = FindTargetContext((int)guiEvent.arg2, (int)guiEvent.arg3);
+        if(targetControl == 0)
+            return;
+
+        //Print("Sending Mouseup to context %x\n", (uint32_t)targetControl);
+        targetControl->OnMouseUp(guiEvent.arg2 - targetControl->sharedContextInfo->x, guiEvent.arg3 - targetControl->sharedContextInfo->y, guiEvent.arg4);
+    }
+    else if(guiEventType == GUIEvents::MouseMove)
+    {
+        int prevX = guiEvent.arg2;
+        int prevY = guiEvent.arg3;
+        int curX = guiEvent.arg4;
+        int curY = guiEvent.arg5;
+
+        Context* prevTargetControl = FindTargetContext(prevX, prevY);
+        Context* newTargetControl = FindTargetContext(curX, curY);
+        
+        if(prevTargetControl != 0)
+            prevTargetControl->OnMouseMove(prevX - prevTargetControl->sharedContextInfo->x, prevY - prevTargetControl->sharedContextInfo->y, curX - prevTargetControl->sharedContextInfo->x, curY - prevTargetControl->sharedContextInfo->y);
+    
+        if(newTargetControl != 0 && newTargetControl != prevTargetControl)
+            newTargetControl->OnMouseMove(prevX - newTargetControl->sharedContextInfo->x, prevY - newTargetControl->sharedContextInfo->y, curX - newTargetControl->sharedContextInfo->x, curY - newTargetControl->sharedContextInfo->y);
+    }
+    else if(guiEventType == GUIEvents::Keypress)
+    {
+        // Find context that is currently focused and where the key should be send to.
+        // TODO: Find a faster way for this, should be possible.
+        for(int i = 0; i < contextList->size(); i++)
+        {
+            Context* c = contextList->GetAt(i);
+            if(c->sharedContextInfo == 0)
+                continue;
+
+            if(c->sharedContextInfo->id == (int)guiEvent.arg4)
+            {
+                KEYPACKET_FLAGS args = (KEYPACKET_FLAGS)guiEvent.arg3;
+                if(args & Pressed)
+                    c->OnKeyDown((uint8_t)guiEvent.arg2, args);
+                else
+                    c->OnKeyUp((uint8_t)guiEvent.arg2, args);
+                break; // Quit loop
+            }
+        }
+    }
+    else if(guiEventType == GUIEvents::MouseScroll)
+    {
+        for(int i = 0; i < contextList->size(); i++) {
+            Context* c = contextList->GetAt(i);
+            if(c->sharedContextInfo == 0)
+                continue;
+
+            if(c->sharedContextInfo->id == guiEvent.arg2) {
+                c->OnScroll(guiEvent.arg3, guiEvent.arg4 - c->sharedContextInfo->x, guiEvent.arg5 - c->sharedContextInfo->y);
+                break; // Quit loop
+            }
+        }
+    }
+    /*
+    else if(guiEventType == EVENT_TYPE_RESIZE)
+    {
+        for(int i = 0; i < contextList->size(); i++) {
+            Context* c = contextList->GetAt(i);
+            if(c->sharedContextInfo == 0)
+                continue;
+
+            if(c->sharedContextInfo->id == guiEvent.arg2) {
+                c->OnResize(Rectangle(guiEvent.arg3, guiEvent.arg4, guiEvent.arg5, guiEvent.arg6));
+                break; // Quit loop
+            }
+        }
+    }
+    */
+}
+
+void GUI::DrawGUI()
+{
+    for(Context* c : *contextList)
+        c->DrawGUI();
+}
+
+Context* GUI::FindTargetContext(int mouseX, int mouseY)
+{
+    if(contextList == 0)
+        return 0;
+    
+    for(int i = 0; i < contextList->size(); i++)
+    {
+        Context* c = contextList->GetAt(i);
+        if(c->sharedContextInfo == 0)
+            continue;
+
+        if(mouseX >= c->sharedContextInfo->x && mouseX <= c->sharedContextInfo->x + (int32_t)c->sharedContextInfo->width)
+            if(mouseY >= c->sharedContextInfo->y && mouseY <= c->sharedContextInfo->y + (int32_t)c->sharedContextInfo->height)
+                return c;
+    }
+    return 0;
+}
+
+Context* GUI::RequestContext(int width, int height, int x, int y)
+{
+    uint32_t contextAddress = ContextHeap::AllocateArea(pageRoundUp(GUI::Width * GUI::Height * 4 + CONTEXT_INFO_SIZE) / 0x1000);
+    if(IPCSend(compositorPID, IPCMessageType::GUIRequest, GUICommunction::REQUEST_CONTEXT, contextAddress, width, height, x, y) != SYSCALL_RET_SUCCES)
+        return 0;
+
+    // Wait for response from server
+    IPCMessage response = ICPReceive(compositorPID, 0, IPCMessageType::GUIRequest);
+    if(response.arg1 == 1) {
+        // Create context struct
+        Context* ret = new Context(contextAddress + CONTEXT_INFO_SIZE, width, height);
+        ret->sharedContextInfo = (ContextInfo*)contextAddress;
+
+        // Add it to our list
+        contextList->push_front(ret);
+
+        return ret;
+    }
+    
+    return 0;
+}
+
+void AsyncGUILoop()
+{
+    while (1)
+    {
+        GUI::DrawGUI();
+        if(IPCAvailable())
+            GUI::ProcessEvents();
+        else
+            Process::Yield();
+    }
+}
+
+void GUI::MakeAsync()
+{
+    Print("Creating GUI thread\n");
+    Process::CreateThread(AsyncGUILoop, false);
+}
+
+bool GUI::HasItems()
+{
+    return (contextList->size() > 0);
+}
+
+Window* GUI::GetControlWindow(Control* control)
+{
+    Control* tmp = control;
+    while(tmp->parent != 0)
+        tmp = tmp->parent;
+    
+    return (Window*)tmp;
+}
\ No newline at end of file
diff --git a/lib/src/gui/property.cpp b/lib/src/gui/property.cpp
new file mode 100644
index 0000000..9d047e4
--- /dev/null
+++ b/lib/src/gui/property.cpp
@@ -0,0 +1,9 @@
+#include <gui/property.h>
+#include <gui/widgets/control.h>
+
+using namespace LIBCactusOS;
+
+void LIBCactusOS::UpdateGUIPropertyTargetGUI(Control* target)
+{
+    if(target) target->ForcePaint();
+}
\ No newline at end of file
diff --git a/lib/src/gui/rect.cpp b/lib/src/gui/rect.cpp
new file mode 100644
index 0000000..add6686
--- /dev/null
+++ b/lib/src/gui/rect.cpp
@@ -0,0 +1,210 @@
+#include <gui/rect.h>
+#include <math.h>
+#include <log.h>
+#include <heap.h>
+
+using namespace LIBCactusOS;
+
+Rectangle::Rectangle(int w, int h, int x_p, int y_p)
+{
+    this->width = w;
+    this->height = h;
+    this->x = x_p;
+    this->y = y_p;
+}
+Rectangle::Rectangle()
+{
+    this->width = 0;
+    this->height = 0;
+    this->x = 0;
+    this->y = 0;
+}
+int Rectangle::Area()
+{
+    return this->width * this->height;
+}
+bool Rectangle::Intersect(Rectangle other, Rectangle* result)
+{
+    int top = Math::Max(this->y, other.y);
+    int bottom = Math::Min(this->y + this->height, other.y + other.height);
+    int left = Math::Max(this->x, other.x);
+    int right = Math::Min(this->x + this->width, other.x + other.width);
+
+    if(result) {
+        result->x = left;
+        result->y = top;
+        result->width = right - left;
+        result->height = bottom - top;
+    }
+
+    return (top < bottom && left < right);
+}
+
+bool Rectangle::Contains(int x, int y)
+{
+    if(x >= this->x && x <= this->x + this->width)
+        if(y >= this->y && y <= this->y + this->height)
+            return true;
+    return false;
+}
+
+// Makes cutting a lot easier
+typedef struct Rect_struct {
+    int top;
+    int left;
+    int bottom;
+    int right;
+} Rect;
+
+///////////
+// Mostly from http://www.trackze.ro/wsbe-4-get-clippy/
+///////////
+
+List<Rectangle>* Rectangle::Split(Rectangle cutter, List<Rectangle>* output)
+{
+    //Allocate the list of result rectangles
+    List<Rectangle>* output_rects = output != 0 ? output : new List<Rectangle>();
+
+    //We're going to modify the subject rect as we go,
+    //so we'll clone it so as to not upset the object 
+    //we were passed
+    Rect subject_copy;
+    subject_copy.top = this->y;
+    subject_copy.left = this->x;
+    subject_copy.bottom = this->y + this->height;
+    subject_copy.right = this->x + this->width;
+
+    Rect cutting_rect;
+    cutting_rect.top = cutter.y;
+    cutting_rect.left = cutter.x;
+    cutting_rect.bottom = cutter.y + cutter.height;
+    cutting_rect.right = cutter.x + cutter.width;
+
+    //Begin splitting
+    //1 -Split by left edge if that edge is between the subject's left and right edges 
+    if(cutting_rect.left >= subject_copy.left && cutting_rect.left <= subject_copy.right) {
+        Rect temp_rect;
+        temp_rect.top = subject_copy.top;
+        temp_rect.left = subject_copy.left;
+        temp_rect.bottom = subject_copy.bottom;
+        temp_rect.right = cutting_rect.left - 1;
+
+        //Add the new rectangle to the output list
+        output_rects->push_back(Rectangle(temp_rect.right - temp_rect.left, temp_rect.bottom - temp_rect.top, temp_rect.left, temp_rect.top));
+
+        //Shrink the subject rectangle to exclude the split portion
+        subject_copy.left = cutting_rect.left;
+    }
+
+    //2 -Split by top edge if that edge is between the subject's top and bottom edges 
+    if(cutting_rect.top >= subject_copy.top && cutting_rect.top <= subject_copy.bottom) {
+        Rect temp_rect;
+        temp_rect.top = subject_copy.top;
+        temp_rect.left = subject_copy.left;
+        temp_rect.bottom = cutting_rect.top - 1;
+        temp_rect.right = subject_copy.right;
+
+        //Add the new rectangle to the output list
+        output_rects->push_back(Rectangle(temp_rect.right - temp_rect.left, temp_rect.bottom - temp_rect.top, temp_rect.left, temp_rect.top));
+
+        //Shrink the subject rectangle to exclude the split portion
+        subject_copy.top = cutting_rect.top;
+    }
+
+    //3 -Split by right edge if that edge is between the subject's left and right edges 
+    if(cutting_rect.right >= subject_copy.left && cutting_rect.right <= subject_copy.right) {
+        Rect temp_rect;
+        temp_rect.top = subject_copy.top;
+        temp_rect.left = cutting_rect.right + 1;
+        temp_rect.bottom = subject_copy.bottom;
+        temp_rect.right = subject_copy.right;
+
+        //Add the new rectangle to the output list
+        output_rects->push_back(Rectangle(temp_rect.right - temp_rect.left, temp_rect.bottom - temp_rect.top, temp_rect.left, temp_rect.top));
+
+        //Shrink the subject rectangle to exclude the split portion
+        subject_copy.right = cutting_rect.right;
+    }
+
+    //4 -Split by bottom edge if that edge is between the subject's top and bottom edges 
+    if(cutting_rect.bottom >= subject_copy.top && cutting_rect.bottom <= subject_copy.bottom) {
+        Rect temp_rect;
+        temp_rect.top = cutting_rect.bottom + 1;
+        temp_rect.left = subject_copy.left;
+        temp_rect.bottom = subject_copy.bottom;
+        temp_rect.right = subject_copy.right;
+
+        //Add the new rectangle to the output list
+        output_rects->push_back(Rectangle(temp_rect.right - temp_rect.left, temp_rect.bottom - temp_rect.top, temp_rect.left, temp_rect.top));
+
+        //Shrink the subject rectangle to exclude the split portion
+        subject_copy.bottom = cutting_rect.bottom;
+    }
+ 
+    //Finally, after all that, we can return the output rectangles 
+    return output_rects;
+}
+void Rectangle::PushToClipList(List<Rectangle>* targetList)
+{
+    int i;
+    List<Rectangle>* split_rects;
+
+    Rect subject_copy;
+    subject_copy.top = this->y;
+    subject_copy.left = this->x;
+    subject_copy.bottom = this->y + this->height;
+    subject_copy.right = this->x + this->width;
+
+    //Check each item already in the list to see if it overlaps with
+    //the new rectangle
+    for(i = 0; i < targetList->size(); ) {
+        Rectangle rect = targetList->GetAt(i);
+        Rect cur_rect;
+        cur_rect.top = rect.y;
+        cur_rect.left = rect.x;
+        cur_rect.bottom = rect.y + rect.height;
+        cur_rect.right = rect.x + rect.width;
+
+        //Standard rect intersect test
+        //see here for an example of why this works:
+        //http://stackoverflow.com/questions/306316/determine-if-two-rectangles-overlap-each-other#tab-top
+        if(!(cur_rect.left <= subject_copy.right &&
+		   cur_rect.right >= subject_copy.left &&
+		   cur_rect.top <= subject_copy.bottom &&
+		   cur_rect.bottom >= subject_copy.top)) {
+
+            //If this rect doesn't intersect with the added_rect
+            //then we can just move on to the next one
+            i++;
+            continue;
+        }
+
+        //If this rectangle *does* intersect with the new rectangle, 
+        //we need to split it
+        targetList->Remove(i);
+        split_rects = rect.Split(*this); //Do the split
+
+        //Copy the split, non-overlapping result rectangles into the list 
+        while(split_rects->size()) {
+            rect = split_rects->GetAt(0);
+            split_rects->Remove(0);
+            targetList->push_back(rect); //Push to B
+        }
+
+        //Free the split_rect list that we just emptied
+        delete split_rects;
+
+        //Since we removed an item from the list, we need to start counting over again 
+        //In this way, we'll only exit this loop once nothing in the list overlaps 
+        i = 0;    
+    }
+
+    //Now that we have made sure none of the existing rectangles overlap
+    //with the new rectangle, we can finally insert it into the hole
+    //we just created
+    targetList->push_back(*this);
+}
+Rectangle Rectangle::Zero()
+{
+    return Rectangle(0, 0, 0, 0);
+}
\ No newline at end of file
diff --git a/lib/src/gui/widgets/button.cpp b/lib/src/gui/widgets/button.cpp
new file mode 100644
index 0000000..a14ecb0
--- /dev/null
+++ b/lib/src/gui/widgets/button.cpp
@@ -0,0 +1,51 @@
+#include <gui/widgets/button.h>
+#include <log.h>
+
+using namespace LIBCactusOS;
+
+Button::Button(char* text)
+: Control(80, 40)
+{
+    this->label = text;
+    this->backColor = 0xFF190A39;
+    this->borderColor = 0xFF479BFF;
+    this->textAlignment = { Alignment::Horizontal::Center, Alignment::Vertical::Center };
+    this->textColor = 0xFF479BFF;
+    this->cornerRadius = 10;
+    this->cornerStyle = CornerStyle::Rounded;
+}
+void Button::DrawTo(Canvas* context, int x_abs, int y_abs)
+{
+    Rectangle visual = Control::GetParentsBounds(x_abs, y_abs);
+    if(visual.Area() == 0)
+        return; // No need to draw something if it isn't going to be visible anyway
+    
+    if(this->cornerStyle == CornerStyle::Rounded) {
+        context->DrawFillRoundedRect(this->backColor, visual.x, visual.y, visual.width, visual.height, this->cornerRadius);
+        context->DrawRoundedRect(this->borderColor, visual.x, visual.y, visual.width, visual.height, this->cornerRadius);
+    }
+    else if(this->cornerStyle == CornerStyle::Sharp) {
+        context->DrawFillRect(this->backColor, visual.x, visual.y, visual.width, visual.height);
+        context->DrawRect(this->borderColor, visual.x, visual.y, visual.width, visual.height);
+    }
+
+    if(this->label != 0)
+        Context::DrawStringAligned(context, this->font, this->label, this->textColor, *this, this->textAlignment, x_abs, y_abs - 2);
+
+    for(Control* c : this->childs)
+        c->DrawTo(context, x_abs + c->x, y_abs + c->y);
+}
+void Button::OnMouseDown(int x_abs, int y_abs, uint8_t button)
+{
+    this->backColor = 0xFF606060;
+    Control::OnMouseDown(x_abs, y_abs, button);
+}
+void Button::OnMouseUp(int x_abs, int y_abs, uint8_t button)
+{
+    this->backColor = 0xFF190A39;
+    Control::OnMouseUp(x_abs, y_abs, button);
+}
+void Button::OnMouseEnter(int prevX_abs, int prevY_abs, int newX_abs, int newY_abs)
+{ }
+void Button::OnMouseLeave(int prevX_abs, int prevY_abs, int newX_abs, int newY_abs)
+{ }
\ No newline at end of file
diff --git a/lib/src/gui/widgets/control.cpp b/lib/src/gui/widgets/control.cpp
new file mode 100644
index 0000000..53a8ad1
--- /dev/null
+++ b/lib/src/gui/widgets/control.cpp
@@ -0,0 +1,204 @@
+#include <gui/widgets/control.h>
+#include <gui/gui.h>
+#include <log.h>
+
+using namespace LIBCactusOS;
+
+Control::Control(int w, int h, int x, int y)
+: EventObject(), Rectangle(w, h, x, y)
+{
+    this->childs.Clear();
+    this->focusedChild = 0;
+    this->parent = 0;
+    this->anchor = Direction::Top | Direction::Left;
+    this->font = GUI::defaultFont;
+}
+
+Control::~Control()
+{
+    for(Control* c : this->childs)
+        delete c;
+    
+    this->childs.Clear();
+}
+
+void Control::DrawTo(Canvas* context, int x_abs, int y_abs)
+{
+    Rectangle visual = Control::GetParentsBounds(x_abs, y_abs);
+    if(this->cornerStyle == CornerStyle::Rounded) {
+        context->DrawFillRoundedRect(this->backColor, visual.x, visual.y, visual.width, visual.height, this->cornerRadius);
+        context->DrawRoundedRect(this->borderColor, visual.x, visual.y, visual.width, visual.height, this->cornerRadius);
+    }
+    else if(this->cornerStyle == CornerStyle::Sharp) {
+        context->DrawFillRect(this->backColor, visual.x, visual.y, visual.width, visual.height);
+        context->DrawRect(this->borderColor, visual.x, visual.y, visual.width, visual.height);
+    }
+
+    for(Control* c : this->childs)
+        c->DrawTo(context, x_abs + c->x, y_abs + c->y);
+}
+
+void Control::AddChild(Control* child, bool focus)
+{
+    this->childs += child;
+    if(focus)
+        this->focusedChild = child;
+    
+    child->parent = this;
+}
+
+void Control::RemoveChild(Control* child)
+{
+    this->childs -= child;
+    if(this->focusedChild == child && this->childs.size() > 0)
+        this->focusedChild = this->childs[this->childs.size() - 1]; //Last entry in child list
+    
+    child->parent = 0;
+}
+
+bool Control::Focused()
+{
+    return (this->parent != 0 && this->parent->focusedChild == this);
+}
+
+Rectangle Control::GetParentsBounds(int xOffset, int yOffset)
+{
+    if(this->parent == 0)
+        return Rectangle::Zero();
+    
+    Rectangle result;
+    Rectangle source = *this;
+    source.x = xOffset;
+    source.y = yOffset;
+
+    // Get the dimensions of the parent window/control
+    Rectangle parentRect = *this->parent;
+    parentRect.x = 0;
+    parentRect.y = 0;
+    
+    // Check if the parent is a window, if so we need to take in account the title bar
+    // TODO: Make title bar a control itself??
+    if(this->parent == GUI::GetControlWindow(this)) {
+        parentRect.y += ((Window*)this->parent)->titleBarHeight;
+        parentRect.height -= ((Window*)this->parent)->titleBarHeight + 1;
+    }
+    
+    // Calculate intersection
+    if(parentRect.Intersect(source, &result))
+        return result;
+    
+    return Rectangle::Zero();
+}
+
+void Control::OnMouseDown(int x_abs, int y_abs, uint8_t button)
+{
+    this->MouseDown.Invoke(this, MouseButtonArgs(x_abs, y_abs, button));
+
+    // Send event to children
+    for(Control* c : this->childs) {
+        if(c->Contains(x_abs, y_abs)) {
+            this->focusedChild = c;
+            
+            c->OnMouseDown(x_abs - c->x, y_abs - c->y, button);
+        }
+    }
+}
+void Control::OnMouseUp(int x_abs, int y_abs, uint8_t button)
+{
+    this->MouseUp.Invoke(this, MouseButtonArgs(x_abs, y_abs, button));
+    this->MouseClick.Invoke(this, MouseButtonArgs(x_abs, y_abs, button));
+
+    // Send event to children
+    for(Control* c : this->childs) {
+        if(c->Contains(x_abs, y_abs)) {
+            c->OnMouseUp(x_abs - c->x, y_abs - c->y, button);
+        }
+    }
+}
+
+void Control::OnMouseMove(int prevX_abs, int prevY_abs, int newX_abs, int newY_abs)
+{
+    for(Control* c : this->childs) {
+        bool inNewArea = c->Contains(newX_abs, newY_abs);
+        bool inOldArea = c->Contains(prevX_abs, prevY_abs);
+
+        if(inNewArea || inOldArea)
+            c->OnMouseMove(prevX_abs - c->x, prevY_abs - c->y, newX_abs - c->x, newY_abs - c->y);
+
+        if(inNewArea && !inOldArea)
+            c->OnMouseEnter(prevX_abs - c->x, prevY_abs - c->y, newX_abs - c->x, newY_abs - c->y);
+        
+        if(!inNewArea && inOldArea)
+            c->OnMouseLeave(prevX_abs - c->x, prevY_abs - c->y, newX_abs - c->x, newY_abs - c->y);
+    }
+}
+
+void Control::OnMouseEnter(int prevX_abs, int prevY_abs, int newX_abs, int newY_abs)
+{ }
+
+void Control::OnMouseLeave(int prevX_abs, int prevY_abs, int newX_abs, int newY_abs)
+{ }
+
+void Control::OnKeyDown(uint8_t key, KEYPACKET_FLAGS modifiers)
+{
+    this->KeyDown.Invoke(this, KeypressArgs(key, modifiers));
+
+    if(this->focusedChild != 0)
+        this->focusedChild->OnKeyDown(key, modifiers);
+}
+void Control::OnKeyUp(uint8_t key, KEYPACKET_FLAGS modifiers)
+{
+    this->KeyUp.Invoke(this, KeypressArgs(key, modifiers));
+
+    if(this->focusedChild != 0)
+        this->focusedChild->OnKeyUp(key, modifiers);
+}
+
+void Control::OnResize(Rectangle old)
+{
+    int dWidth = this->width - old.width;
+    int dHeight = this->height - old.height;
+
+    // Loop through childs and update their position
+    for(Control* child : this->childs) {
+        bool resized = false;
+        Rectangle oldSize(child->width, child->height, child->x, child->y);
+        if(child->anchor & Top) {
+            if(child->anchor & Bottom) {
+                child->height += dHeight;
+                resized = true;
+            }
+        }
+        if(child->anchor & Right) {
+            if(child->anchor & Left) {
+                child->width += dWidth;
+                resized = true;
+            }
+            else { 
+                child->x += dWidth;
+            }
+        }
+        if(child->anchor & Bottom && !(child->anchor & Top)) {
+            child->y += dHeight;
+        }
+        
+        if(resized)
+            child->OnResize(oldSize);
+
+    }    
+}
+void Control::ForcePaint()
+{    
+    Control* win = GUI::GetControlWindow(this);
+    if(win)
+        win->needsRepaint = true;
+}
+void Control::OnScroll(int32_t deltaZ, int x_abs, int y_abs)
+{
+    this->MouseScroll.Invoke(this, MouseScrollArgs(deltaZ, x_abs, y_abs));
+
+    // Send event to children if they are in bounds
+    for(Control* c : this->childs)
+        if(c->Contains(x_abs, y_abs))
+            c->OnScroll(deltaZ, x_abs - c->x, y_abs - c->y);
+}
\ No newline at end of file
diff --git a/lib/src/gui/widgets/label.cpp b/lib/src/gui/widgets/label.cpp
new file mode 100644
index 0000000..ddce42f
--- /dev/null
+++ b/lib/src/gui/widgets/label.cpp
@@ -0,0 +1,18 @@
+#include <gui/widgets/label.h>
+
+using namespace LIBCactusOS;
+
+Label::Label(char* text)
+: Control(80, 20)
+{
+    this->text = text;
+}
+
+void Label::DrawTo(Canvas* context, int x_abs, int y_abs)
+{
+    if(this->text)
+        context->DrawString(this->font, this->text, x_abs + 2, y_abs + 2, this->textColor);
+
+    for(Control* c : this->childs)
+        c->DrawTo(context, x_abs + c->x, y_abs + c->y);
+}
\ No newline at end of file
diff --git a/lib/src/gui/widgets/scrollbar.cpp b/lib/src/gui/widgets/scrollbar.cpp
new file mode 100644
index 0000000..ebb774b
--- /dev/null
+++ b/lib/src/gui/widgets/scrollbar.cpp
@@ -0,0 +1,47 @@
+#include <gui/widgets/scrollbar.h>
+#include <math.h>
+
+using namespace LIBCactusOS;
+
+ScrollBar::ScrollBar(ScrollBarType type, int min, int max, int dragSize)
+: Control(type == Horizontal ? SCROLLBAR_DEFAULT_WIDTH : SCROLLBAR_DEFAULT_HEIGHT, type == Vertical ? SCROLLBAR_DEFAULT_WIDTH : SCROLLBAR_DEFAULT_HEIGHT)
+{ }
+
+void ScrollBar::DrawTo(Canvas* context, int x_abs, int y_abs)
+{
+    Rectangle visual = Control::GetParentsBounds(x_abs, y_abs);
+    if(visual.Area() == 0)
+        return; // No need to draw something if it isn't going to be visible anyway
+
+    // Calculate percentage of completion
+    double factor = (double)Math::Constrain(this->value, this->minValue, this->maxValue) / (double)(this->maxValue - this->minValue);
+
+    context->DrawFillRect(this->backColor, visual.x, visual.y, visual.width, visual.height);
+    if(this->type == Horizontal)
+        context->DrawFillRect(this->dragColor, visual.x + (double)(this->width - this->dragSize) * factor, visual.y, this->dragSize, this->height);
+    else
+        context->DrawFillRect(this->dragColor, visual.x, visual.y + (double)(this->height - this->dragSize) * factor, this->width, this->dragSize);
+
+    context->DrawRect(this->borderColor, visual.x, visual.y, visual.width, visual.height);
+}
+
+void ScrollBar::OnScroll(int32_t deltaZ, int x_abs, int y_abs)
+{
+    this->value = Math::Constrain(this->value + ((double)deltaZ * this->scrollFactor), this->minValue, this->maxValue);
+}
+
+
+void ScrollBar::OnMouseDown(int x_abs, int y_abs, uint8_t button)
+{
+    
+}
+
+void ScrollBar::OnMouseUp(int x_abs, int y_abs, uint8_t button)
+{
+
+}
+
+void ScrollBar::OnMouseMove(int prevX_abs, int prevY_abs, int newX_abs, int newY_abs)
+{
+
+}
\ No newline at end of file
diff --git a/lib/src/gui/widgets/slider.cpp b/lib/src/gui/widgets/slider.cpp
new file mode 100644
index 0000000..e6014ad
--- /dev/null
+++ b/lib/src/gui/widgets/slider.cpp
@@ -0,0 +1,58 @@
+#include <gui/widgets/slider.h>
+#include <gui/widgets/window.h>
+#include <log.h>
+#include <math.h>
+
+using namespace LIBCactusOS;
+
+Slider::Slider(int min, int max, int current)
+: Control(200, 15)
+{
+    this->minValue = min;
+    this->maxValue = max;
+    this->position = current;
+}
+
+void Slider::DrawTo(Canvas* context, int x_abs, int y_abs)
+{
+    Rectangle visual = Control::GetParentsBounds(x_abs, y_abs);
+    if(visual.Area() == 0)
+        return; // No need to draw something if it isn't going to be visible anyway
+    
+    context->DrawFillRect(this->backColor, visual.x, visual.y, visual.width, visual.height);
+    context->DrawRect(this->borderColor, visual.x, visual.y, visual.width, visual.height);
+    
+    double percent = (double)position / (double)(this->maxValue - this->minValue);
+    context->DrawFillCircle(this->knobColor, x_abs + (int)((double)this->width * percent), y_abs + this->height/2, this->knobSize);
+
+    for(Control* c : this->childs)
+        c->DrawTo(context, x_abs + c->x, y_abs + c->y);
+}
+
+void Slider::OnMouseDown(int x_abs, int y_abs, uint8_t button)
+{
+    this->knobColor -= 0x00333333;
+    this->mouseDown = true;
+}
+void Slider::OnMouseUp(int x_abs, int y_abs, uint8_t button)
+{
+    this->knobColor += 0x00333333;
+    this->mouseDown = false;
+}
+void Slider::OnMouseMove(int prevX_abs, int prevY_abs, int newX_abs, int newY_abs)
+{
+    if(mouseDown) {
+        this->position += ((double)(newX_abs - prevX_abs) / (double)this->width) * (this->maxValue - this->minValue);
+        this->position = Math::Max(this->minValue, Math::Min(this->maxValue, this->position));
+        this->OnValueChanged.Invoke(this, this->position);
+    }
+}
+void Slider::OnMouseEnter(int prevX_abs, int prevY_abs, int newX_abs, int newY_abs)
+{
+    this->knobColor -= 0x00111111;
+}
+
+void Slider::OnMouseLeave(int prevX_abs, int prevY_abs, int newX_abs, int newY_abs)
+{
+    this->knobColor += 0x00111111;
+}
\ No newline at end of file
diff --git a/lib/src/gui/widgets/window.cpp b/lib/src/gui/widgets/window.cpp
new file mode 100644
index 0000000..e4ac304
--- /dev/null
+++ b/lib/src/gui/widgets/window.cpp
@@ -0,0 +1,135 @@
+#include <gui/widgets/window.h>
+#include <gui/gui.h>
+#include <log.h>
+#include <gui/colors.h>
+
+using namespace LIBCactusOS;
+
+Window::Window(Context* base)
+: Control(base->sharedContextInfo->width, base->sharedContextInfo->height, base->sharedContextInfo->x, base->sharedContextInfo->y)
+{
+    // Set this to true since we support dirty rectangles when the context is managed by us
+    base->sharedContextInfo->supportsDirtyRects = true;
+
+    base->Window = this;
+    this->contextBase = base;
+    this->CreateButtons();
+    this->needsRepaint = true;
+}
+
+Window::Window(int width, int height, int x, int y)
+: Control(width, height, x, y)
+{
+    Context* screen = GUI::RequestContext(width, height, x, y);
+    if(screen == 0) {
+        Log(Error, "Could not create a context for this window");
+        return;
+    }
+
+    // Set this to true since we support dirty rectangles when the context is managed by us
+    screen->sharedContextInfo->supportsDirtyRects = true;
+
+    this->contextBase = screen;
+    screen->Window = this;
+    this->CreateButtons();
+}
+
+void Window::CreateButtons()
+{
+    Button* b1 = new Button("X");
+    b1->backColor = 0xFFF56642;
+    b1->textColor = Colors::White;
+    b1->borderColor = this->titleBarColor;
+    b1->width = b1->height = this->titleBarHeight - 10;
+    b1->y = 5;
+    b1->x = width - this->titleBarHeight + 5;
+    b1->MouseClick += new MethodCallback<Window, MouseButtonArgs>(this, &Window::Close);
+    this->closeButton = b1;
+}
+
+void Window::DrawTo(Canvas* context, int x_abs, int y_abs)
+{
+    context->DrawFillRect(this->backColor, x_abs, y_abs + titleBarHeight, this->width, this->height - titleBarHeight - 1);
+    context->DrawRect(this->borderColor, x_abs, y_abs, this->width - 1, this->height - 1);
+
+    //Draw title bar
+    context->DrawFillRect(this->titleBarColor, x_abs + 1, y_abs + 1, this->width - 1, this->titleBarHeight);
+    //context->DrawLine(this->borderColor, x_abs + 1, y_abs + this->titleBarHeight, x_abs + this->width, y_abs + titleBarHeight);
+
+    if(this->titleString)
+        context->DrawString(this->font, this->titleString, x_abs + 3, y_abs + 6, this->textColor);
+
+    for(Control* c : this->childs)
+        c->DrawTo(context, x_abs + c->x, y_abs + c->y + titleBarHeight);
+    
+    if(this->closeButton)
+        this->closeButton->DrawTo(context, x_abs + closeButton->x, y_abs + closeButton->y);
+}
+
+void Window::OnMouseDown(int x_abs, int y_abs, uint8_t button)
+{
+    if(y_abs < this->titleBarHeight) {
+        
+        if(this->closeButton != 0 && this->closeButton->Contains(x_abs, y_abs))
+            this->closeButton->OnMouseDown(x_abs - closeButton->x, y_abs - closeButton->y, button);
+        
+        else {
+            titleBarMouseDown = true;
+            mouseDownX = x_abs;
+            mouseDownY = y_abs;
+            this->titleBarColor = 0xFF1773BF;
+        }
+    }
+
+    Control::OnMouseDown(x_abs, y_abs - this->titleBarHeight, button);
+}
+void Window::OnMouseUp(int x_abs, int y_abs, uint8_t button)
+{
+    if(y_abs < this->titleBarHeight) {
+        
+        if(this->closeButton != 0 && this->closeButton->Contains(x_abs, y_abs))
+            this->closeButton->OnMouseUp(x_abs - closeButton->x, y_abs - closeButton->y, button);
+        
+        else {
+            titleBarMouseDown = false;
+            this->titleBarColor = 0xFF1E9AFF;
+        }
+    }
+
+    Control::OnMouseUp(x_abs, y_abs - this->titleBarHeight, button);
+}
+void Window::OnMouseMove(int prevX_abs, int prevY_abs, int newX_abs, int newY_abs)
+{
+    if(this->titleBarMouseDown) {
+        this->contextBase->MoveToPosition(this->x + newX_abs - mouseDownX, this->y + newY_abs - mouseDownY);
+    }
+    Control::OnMouseMove(prevX_abs, prevY_abs - this->titleBarHeight, newX_abs, newY_abs - this->titleBarHeight);
+}
+void Window::Close(void* sender, MouseButtonArgs arg)
+{
+    Print("Closing window %x\n", (uint32_t)this);
+    this->contextBase->CloseContext();
+}
+void Window::Close()
+{
+    Print("Closing window %x\n", (uint32_t)this);
+    this->contextBase->CloseContext();
+}
+void Window::OnResize(Rectangle old)
+{
+    this->closeButton->x = width - this->titleBarHeight + 5;
+    Control::OnResize(old);
+}
+void Window::OnKeyDown(uint8_t key, KEYPACKET_FLAGS modifiers)
+{
+    Control::OnKeyDown(key, modifiers);
+
+    if((key == 'W' || key == 'w') && (modifiers & LeftControl))
+        this->Close();
+}
+void Window::OnScroll(int32_t deltaZ, int x_abs, int y_abs)
+{
+    // TODO: Create window fold event?
+
+    Control::OnScroll(deltaZ, x_abs, y_abs - this->titleBarHeight);
+}
\ No newline at end of file
diff --git a/lib/src/heap.cpp b/lib/src/heap.cpp
new file mode 100644
index 0000000..66b0e8a
--- /dev/null
+++ b/lib/src/heap.cpp
@@ -0,0 +1,152 @@
+#include <heap.h>
+#include <syscall.h>
+#include <log.h>
+
+using namespace LIBCactusOS;
+
+uint32_t UserHeap::startAddress = 0;
+uint32_t UserHeap::endAddress = 0;
+uint32_t UserHeap::maxAddress = 3_GB - 1_MB; //1 MB Below the kernel
+MemoryHeader* UserHeap::firstHeader = 0;
+
+uint32_t LIBCactusOS::pageRoundUp(uint32_t address)
+{
+    if((address & 0xFFFFF000) != address)
+    {
+        address &= 0xFFFFF000;
+        address += 0x1000;
+    }
+    return address;
+}
+uint32_t LIBCactusOS::pageRoundDown(uint32_t address)
+{
+    return address & 0xFFFFF000;
+}
+
+void* UserHeap::Malloc(uint32_t size)
+{
+    MemoryHeader* freeBlock = 0;
+
+    for(MemoryHeader* hdr = firstHeader; hdr != 0 && freeBlock == 0; hdr = hdr->next)
+        if(hdr->size > size && !hdr->allocated)
+            freeBlock = hdr;
+    
+    if(freeBlock == 0)
+    {
+        //We need to expand the heap
+        Log(Warning, "Heap needs to be expanded for this process");
+        
+        //Call Kernel
+        if(DoSyscall(SYSCALL_SET_HEAP_SIZE, pageRoundUp(endAddress + size + HEAP_INCREASE_SIZE)) == SYSCALL_RET_SUCCES) {
+            MemoryHeader* lastHeader = 0;
+            
+            //Find last block
+            for(MemoryHeader* hdr = firstHeader; hdr != 0 && freeBlock == 0; hdr = hdr->next)
+                if(hdr->allocated == false)
+                    lastHeader = hdr;
+            
+            lastHeader->size += size + HEAP_INCREASE_SIZE;
+
+            endAddress = DoSyscall(SYSCALL_GET_HEAP_END);
+            
+            return Malloc(size);
+        }
+        else
+            Log(Error, "Could not expand heap");
+    }
+
+    if(freeBlock->size >= size + sizeof(MemoryHeader))
+    {
+        MemoryHeader* temp = (MemoryHeader*)((uint32_t)freeBlock + sizeof(MemoryHeader) + size);
+
+        temp->allocated = false;
+        temp->size = freeBlock->size - size - sizeof(MemoryHeader);
+        temp->prev = freeBlock;
+        temp->next = freeBlock->next;
+        if(temp->next != 0)
+            temp->next->prev = temp;
+
+        freeBlock->size = size;
+        freeBlock->next = temp;
+    }
+
+    freeBlock->allocated = true;
+    return (void*)(((uint32_t)freeBlock) + sizeof(MemoryHeader));
+}
+void UserHeap::Free(void* ptr)
+{
+    MemoryHeader* chunk = (MemoryHeader*)((uint32_t)ptr - sizeof(MemoryHeader));
+    
+    chunk -> allocated = false;
+    
+    if(chunk->prev != 0 && !chunk->prev->allocated)
+    {
+        chunk->prev->next = chunk->next;
+        chunk->prev->size += chunk->size + sizeof(MemoryHeader);
+        if(chunk->next != 0)
+            chunk->next->prev = chunk->prev;
+        
+        chunk = chunk->prev;
+    }
+    
+    if(chunk->next != 0 && !chunk->next->allocated)
+    {
+        chunk->size += chunk->next->size + sizeof(MemoryHeader);
+        chunk->next = chunk->next->next;
+        if(chunk->next != 0)
+            chunk->next->prev = chunk;
+    }
+}
+void UserHeap::Initialize()
+{
+    startAddress = DoSyscall(SYSCALL_GET_HEAP_START);
+    endAddress = DoSyscall(SYSCALL_GET_HEAP_END);
+
+    firstHeader = (MemoryHeader*)startAddress;
+    firstHeader->allocated = false;
+    firstHeader->prev = 0;
+    firstHeader->next = 0;
+    firstHeader->size = endAddress - startAddress - sizeof(MemoryHeader);
+}
+void UserHeap::PrintMemoryLayout()
+{
+    int i = 0;
+    for(MemoryHeader* hdr = firstHeader; hdr != 0; hdr = hdr->next)
+    {
+        Print("## (%d) ##### (%x) #########\n", i++, (uint32_t)hdr);
+        Print("## Size: %d Allocated: %s\n", hdr->size, hdr->allocated ? "True" : "False");
+    }
+}
+void* UserHeap::alignedMalloc(uint32_t size, uint32_t align)
+{
+    void* ptr = 0;
+
+    if(!(align & (align - 1)) == 0)
+        return 0;
+
+    if(align && size)
+    {
+        uint32_t hdr_size = sizeof(uint16_t) + (align - 1);
+
+        void* p = Malloc(size + hdr_size);
+
+        if(p)
+        {
+            ptr = (void *) align_up(((uintptr_t)p + sizeof(uint16_t)), align);
+
+            *((uint16_t*)ptr - 1) = (uint16_t)((uintptr_t)ptr - (uintptr_t)p);
+        }
+    }
+    return ptr;
+}
+void UserHeap::allignedFree(void* ptr)
+{
+    if(ptr == 0)
+        return;
+
+    uint16_t offset = *((uint16_t*)ptr - 1);
+
+    void* p = (void*)((uint8_t*)ptr - offset);
+
+    Free(p);
+}
\ No newline at end of file
diff --git a/lib/src/imaging/bmpformat.cpp b/lib/src/imaging/bmpformat.cpp
new file mode 100644
index 0000000..2be699d
--- /dev/null
+++ b/lib/src/imaging/bmpformat.cpp
@@ -0,0 +1,75 @@
+#include <imaging/bmpformat.h>
+#include <log.h>
+#include <string.h>
+#include <math.h>
+#include <vfs.h>
+
+using namespace LIBCactusOS;
+using namespace LIBCactusOS::Imaging;
+
+Image* Imaging::ConvertBMP(const char* filepath)
+{
+    Print("[BMP] Converting image file %s\n", filepath);
+
+    if(FileExists((char*)filepath))
+    {
+        uint32_t fileSize = GetFileSize((char*)filepath);
+        if(fileSize != (uint32_t)-1)
+        {
+            uint8_t* fileBuf = new uint8_t[fileSize];
+            ReadFile((char*)filepath, fileBuf);
+            
+            Image* result = ConvertBMPRaw(fileBuf);
+            delete fileBuf;
+            return result;
+        }
+    }
+
+    Print("[BMP] Error processing file %s\n", filepath);
+    return 0;
+}
+
+Image* Imaging::ConvertBMPRaw(const uint8_t* rawData)
+{
+    const uint8_t* realBuffPtr = rawData;
+
+    BMPFileHeader* fileHeader = (BMPFileHeader*)rawData;
+    if(fileHeader->fileType != 0x4D42)
+        return 0;
+    
+    rawData += sizeof(BMPFileHeader);
+    BMPInfoHeader* infoHeader = (BMPInfoHeader*)rawData;
+
+    if(infoHeader->BitCount != 24 || infoHeader->Compression != 0) {
+        Log(Error, "[BMP] Image not supported");
+        return 0;
+    }
+
+    // Jump to begin of pixel data
+    rawData = (realBuffPtr + fileHeader->dataOffset);
+
+    // Create result image
+    Image* result = new Image(infoHeader->Width, infoHeader->Height);
+    uint32_t* resultBuffer = result->GetBufferPtr();
+
+    // Copy data to result image
+    int align = (infoHeader->Width * 3) % 4;
+    if (align != 0)
+        align = 4 - align; 
+
+    int offset, rowOffset;
+    for (int y = 0; y < infoHeader->Height; y++) {
+        rowOffset = (infoHeader->Height - y - 1) * (infoHeader->Width * 3 + align);
+        for (int x = 0; x < infoHeader->Width; x++) {
+            offset = rowOffset + x * 3;
+            
+            uint32_t b = rawData[offset + 0];
+            uint32_t g = rawData[offset + 1];
+            uint32_t r = rawData[offset + 2];
+
+            resultBuffer[y * infoHeader->Width + x] = 0xFF000000 | r << 16 | g << 8  | b;
+        }
+    }
+
+    return result;
+}
\ No newline at end of file
diff --git a/lib/src/imaging/image.cpp b/lib/src/imaging/image.cpp
new file mode 100644
index 0000000..ec4f9a9
--- /dev/null
+++ b/lib/src/imaging/image.cpp
@@ -0,0 +1,244 @@
+#include <imaging/image.h>
+#include <log.h>
+#include <string.h>
+#include <math.h>
+#include <vfs.h>
+#include <heap.h>
+
+#include <imaging/bmpformat.h>
+#include <imaging/jpeg_decoder.h>
+#include <imaging/pngformat.h>
+
+using namespace LIBCactusOS;
+using namespace LIBCactusOS::Imaging;
+
+Image::Image(const int width, const int height)
+{
+    this->width = width;
+    this->height = height;
+    if(width > 0 && height > 0)
+        this->buffer = new uint32_t[width * height];
+}
+Image::~Image()
+{
+    if(this->canvas)
+        delete this->canvas;
+    
+    if(this->buffer)
+        delete this->buffer;
+}
+
+//////////////////////
+// General Functions
+//////////////////////
+
+Canvas* Image::GetCanvas()
+{
+    if(this->canvas == 0)
+        this->canvas = new Canvas(this->buffer, this->width, this->height);
+    
+    return this->canvas;
+}
+
+int Image::GetWidth()
+{
+    return this->width;
+}
+
+int Image::GetHeight()
+{
+    return this->height;
+}
+
+uint32_t* Image::GetBufferPtr()
+{
+    return this->buffer;
+}
+
+void Image::DrawTo(Canvas* target, int x, int y)
+{
+    if(target == 0)
+        return;
+    
+    uint8_t* targetBuffer = (uint8_t*)target->bufferPointer;
+    for(int row = 0; row < this->height; row++)
+        memcpy((void*)(targetBuffer + (row+y)*target->Width*4 + x*4), (void*)(this->buffer + row*this->width), this->width * 4);
+}
+
+
+//////////////////
+// Static Functions
+//////////////////
+
+Image* Image::CreateFromFile(const char* filepath, const char* ext)
+{
+    const char* extension = 0;
+
+    if(ext == 0) { // We need to determine type by extension
+        int i = str_IndexOf(filepath, '.');
+        if(i == -1) {
+            Print("Image path %s not valid\n", filepath);
+            return 0;
+        }
+
+        // Create extension from filepath
+        extension = (char*)(filepath + i + 1);
+    }
+    else
+        extension = ext; // Extension is given
+
+
+
+    if(strcmp(extension, "bmp") == 1)
+        return ConvertBMP(filepath);
+    else if(strcmp(extension, "jpg") == 1 || strcmp(extension, "jpeg") == 1) {
+        Print("[JPEG] Converting image file %s\n", filepath);
+
+        if(FileExists((char*)filepath))
+        {
+            uint32_t fileSize = GetFileSize((char*)filepath);
+            if(fileSize != (uint32_t)-1)
+            {
+                uint8_t* fileBuf = new uint8_t[fileSize];
+                ReadFile((char*)filepath, fileBuf);
+                
+                // Convert JPEG
+                Jpeg::Decoder* decoder = new Jpeg::Decoder(fileBuf, fileSize, UserHeap::Malloc, UserHeap::Free);
+                if (decoder->GetResult() != Jpeg::Decoder::OK)
+                {
+                    Print("[JPEG] Error decoding the input file\n");
+                    return 0;
+                }
+                Image* result = new Image(decoder->GetWidth(), decoder->GetHeight());
+                const uint8_t* data = decoder->GetImage();
+                Print("[JPEG] Conversion Succes! (%dx%d)\n", result->width, result->height);
+
+                // Move pixels to result image
+                for(uint32_t pixel = 0; pixel < (uint32_t)(result->width * result->height); pixel++) {
+                    const uint8_t r = data[pixel * 3];
+                    const uint8_t g = data[pixel * 3 + 1];
+                    const uint8_t b = data[pixel * 3 + 2];
+                    result->buffer[pixel] = 0xFF000000 | (r << 16) | (g << 8) | b;
+                }
+                
+                delete fileBuf;
+                delete decoder;
+                return result;
+            }
+        }
+    }
+    else if(strcmp(extension, "png") == 1) {
+        return PNGDecoder::Convert(filepath);
+    }
+    else
+        Print("Could not found a image converter for extension %s\n", extension);
+    
+    return 0;
+}
+
+Image* Image::Resize(Image* source, int newWidth, int newHeight, ResizeMethod method)
+{
+    if(source == 0) return 0;
+
+    if(source->width == newWidth && source->height == newHeight) // No change in resolution
+        return source;
+    
+    switch(method)
+    {
+        case NearestNeighbor:
+            return ResizeNearestNeighbor(source, newWidth, newHeight);
+        case Bilinear:
+            return ResizeBilinear(source, newWidth, newHeight);
+    }
+    return source;
+}
+
+///////////
+// Resize Implementations
+///////////
+// http://jankristanto.com/info/nearest-neighbor-interpolation-for-resize-image/
+Image* Image::ResizeNearestNeighbor(Image* source, int newWidth, int newHeight)
+{
+    Image* result = new Image(newWidth, newHeight);
+    uint32_t* src = (uint32_t*)source->GetBufferPtr();
+    uint32_t* dest = (uint32_t*)result->GetBufferPtr();
+
+    double x_ratio = source->width / (double)newWidth;
+	double y_ratio = source->height / (double)newHeight;
+	double px, py;
+	for (int y = 0; y < newHeight; y++) {
+		for (int x = 0; x < newWidth; x++) {
+			px = Math::floor((double)x * x_ratio);
+			py = Math::floor((double)y * y_ratio);
+			dest[(y*newWidth) + x] = src[(uint32_t)((py*source->width) + px)];
+		}
+	}
+    
+    return result;
+}
+// http://tech-algorithm.com/articles/bilinear-image-scaling/
+Image* Image::ResizeBilinear(Image* source, int newWidth, int newHeight)
+{
+    Image* result = new Image(newWidth, newHeight);
+    uint8_t* src = (uint8_t*)source->GetBufferPtr();
+    uint8_t* dest = (uint8_t*)result->GetBufferPtr();
+    int a, b, c, d, x, y, index;
+
+    float x_ratio = ((float)(source->width-1))/newWidth;
+    float y_ratio = ((float)(source->height-1))/newHeight;
+
+    float x_diff, y_diff, blue, red, green;
+    #if BILINEAR_ALPHA
+    float alpha;
+    #endif
+    
+    int offset = 0;
+    for (int i = 0; i < newHeight; i++) {
+        for (int j = 0; j < newWidth; j++) {
+            x = (int)(x_ratio * j);
+            y = (int)(y_ratio * i);
+            x_diff = (x_ratio * j) - x;
+            y_diff = (y_ratio * i) - y;
+            index = (y*source->width+x);   
+
+            a = src[index];
+            b = src[index+1];
+            c = src[index+source->width];
+            d = src[index+source->width+1];
+
+            // blue element
+            // Yb = Ab(1-w)(1-h) + Bb(w)(1-h) + Cb(h)(1-w) + Db(wh)
+            blue = (a&0xff)*(1-x_diff)*(1-y_diff) + (b&0xff)*(x_diff)*(1-y_diff) +
+                   (c&0xff)*(y_diff)*(1-x_diff)   + (d&0xff)*(x_diff*y_diff);
+
+            // green element
+            // Yg = Ag(1-w)(1-h) + Bg(w)(1-h) + Cg(h)(1-w) + Dg(wh)
+            green = ((a>>8)&0xff)*(1-x_diff)*(1-y_diff) + ((b>>8)&0xff)*(x_diff)*(1-y_diff) +
+                    ((c>>8)&0xff)*(y_diff)*(1-x_diff)   + ((d>>8)&0xff)*(x_diff*y_diff);
+
+            // red element
+            // Yr = Ar(1-w)(1-h) + Br(w)(1-h) + Cr(h)(1-w) + Dr(wh)
+            red = ((a>>16)&0xff)*(1-x_diff)*(1-y_diff) + ((b>>16)&0xff)*(x_diff)*(1-y_diff) +
+                  ((c>>16)&0xff)*(y_diff)*(1-x_diff)   + ((d>>16)&0xff)*(x_diff*y_diff);
+
+            #if BILINEAR_ALPHA
+            alpha = ((a>>24)&0xff)*(1-x_diff)*(1-y_diff) + ((b>>24)&0xff)*(x_diff)*(1-y_diff) +
+                    ((c>>24)&0xff)*(y_diff)*(1-x_diff)   + ((d>>24)&0xff)*(x_diff*y_diff);
+
+            dest[offset++] = 
+                    ((((int)alpha)<<24)&0xff000000) |
+                    ((((int)red)<<16)&0xff0000) |
+                    ((((int)green)<<8)&0xff00) |
+                    ((int)blue);
+            #else
+            dest[offset++] = 
+                    0xff000000 | // hardcode alpha
+                    ((((int)red)<<16)&0xff0000) |
+                    ((((int)green)<<8)&0xff00) |
+                    ((int)blue);
+            #endif
+        }
+    }
+
+	return result;
+}
\ No newline at end of file
diff --git a/lib/src/imaging/pngformat.cpp b/lib/src/imaging/pngformat.cpp
new file mode 100644
index 0000000..493ab21
--- /dev/null
+++ b/lib/src/imaging/pngformat.cpp
@@ -0,0 +1,575 @@
+#include <imaging/pngformat.h>
+#include <bitreader.h>
+#include <log.h>
+#include <string.h>
+#include <math.h>
+#include <vfs.h>
+#include <heap.h>
+
+using namespace LIBCactusOS;
+using namespace LIBCactusOS::Imaging;
+
+#define BYTES_PER_PIXEL 4
+
+static const uint32_t lengthExtraBits[] = {
+	0, 0, 0, 0, 0, 0, 0, 0, //257 - 264
+	1, 1, 1, 1,             //265 - 268
+	2, 2, 2, 2,             //269 - 273
+	3, 3, 3, 3,             //274 - 276
+	4, 4, 4, 4,             //278 - 280
+	5, 5, 5, 5,             //281 - 284
+	0                       //285
+};
+
+static const uint32_t lengthBase[] = {
+	3, 4, 5, 6, 7, 8, 9, 10, //257 - 264
+	11, 13, 15, 17,          //265 - 268
+	19, 23, 27, 31,          //269 - 273
+	35, 43, 51, 59,          //274 - 276
+	67, 83, 99, 115,         //278 - 280
+	131, 163, 195, 227,      //281 - 284
+	258                      //285
+};
+
+static const uint32_t distanceBase[] = {
+	1, 2, 3, 4,    //0-3
+	5, 7,          //4-5
+	9, 13,         //6-7
+	17, 25,        //8-9
+	33, 49,        //10-11
+	65, 97,        //12-13
+	129, 193,      //14-15
+	257, 385,      //16-17
+	513, 769,      //18-19
+	1025, 1537,    //20-21
+	2049, 3073,    //22-23
+	4097, 6145,    //24-25
+	8193, 12289,   //26-27
+	16385, 24577,  //28-29
+	0   , 0        //30-31, error, shouldn't occur
+};
+
+static const uint32_t distanceExtraBits[] = {
+	0, 0, 0, 0, //0-3
+	1, 1,       //4-5
+	2, 2,       //6-7
+	3, 3,       //8-9
+	4, 4,       //10-11
+	5, 5,       //12-13
+	6, 6,       //14-15
+	7, 7,       //16-17
+	8, 8,       //18-19
+	9, 9,       //20-21
+	10, 10,     //22-23
+	11, 11,     //24-25
+	12, 12,     //26-27
+	13, 13,     //28-29
+	0 , 0       //30-31 error, they shouldn't occur
+};
+
+static const uint32_t codeLengthCodesOrder[] = {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};
+
+
+void printBT(const char* prefix, const HuffmanNode* node, bool isLeft)
+{
+    if( node != nullptr )
+    {
+        Print("%s%s%d\n", prefix, (isLeft ? "├──" : "└──" ), node->symbol);
+
+        // enter the next tree level - left and right branch
+        printBT(str_Combine((char*)prefix, isLeft ? (char*)"│   " : (char*)"    "), node->left, true);
+        printBT(str_Combine((char*)prefix, isLeft ? (char*)"│   " : (char*)"    "), node->right, false);
+    }
+}
+
+void printBT(const HuffmanNode* node)
+{
+    printBT("", node, false);    
+}
+
+Image* PNGDecoder::Convert(const char* filepath)
+{
+    Print("[PNG] Converting image file %s\n", filepath);
+
+    if(FileExists((char*)filepath))
+    {
+        uint32_t fileSize = GetFileSize((char*)filepath);
+        if(fileSize != (uint32_t)-1)
+        {
+            uint8_t* fileBuf = new uint8_t[fileSize];
+            ReadFile((char*)filepath, fileBuf);
+            
+            Image* result = ConvertRAW(fileBuf);
+            delete fileBuf;
+            return result;
+        }
+    }
+
+    Print("[PNG] Error processing file %s\n", filepath);
+    return 0;
+}
+
+Image* PNGDecoder::ConvertRAW(const uint8_t* rawData)
+{
+    const uint8_t signature[8] = { 137, 80, 78, 71, 13, 10, 26, 10 };
+
+    IHDRChunk* ihdr = 0;
+    List<uint8_t*> imgDataPtrs;
+    List<uint32_t> imgDataLens;
+    uint8_t* dataPtr = (uint8_t*)rawData;
+
+    if(memcmp(dataPtr, signature, 8) != 0)
+        return 0;
+
+    // Move past the signature
+    dataPtr += 8;
+
+    // Start reading chunks
+    while(1) {
+        PNGChunk* chunk = (PNGChunk*)dataPtr;
+        uint32_t dataLength = __builtin_bswap32(chunk->length);
+
+        // Check for chunk type
+        if(memcmp(chunk->type, "IHDR", 4) == 0) {
+            // Put pointer to the right data
+            ihdr = (IHDRChunk*)(dataPtr + sizeof(PNGChunk));
+            
+            // Perform byteswap for width and height values
+            ihdr->width = __builtin_bswap32(ihdr->width);
+            ihdr->height = __builtin_bswap32(ihdr->height);
+            
+            // Perform some sanity checking
+            if(ihdr->compression != 0) {
+                Log(Error, "[PNG] Compression method is not 0, can not parse this image");
+                return 0;
+            }
+            if(ihdr->filter != 0) {
+                Log(Error, "[PNG] Filter method is not 0, can not parse this image");
+                return 0;
+            }
+
+            // Check if we can read this type of image file
+            if(ihdr->colorType != 6) {
+                Log(Error, "[PNG] Color type is not 6, can not parse this image");
+                return 0;
+            }
+            if(ihdr->bits != 8) {
+                Log(Error, "[PNG] Bits is not 8, can not parse this image");
+                return 0;
+            }
+            if(ihdr->interlace != 0) {
+                Log(Error, "[PNG] Interlace method is not 0, can not parse this image");
+                return 0;
+            }
+        }
+        else if(memcmp(chunk->type, "IDAT", 4) == 0) {
+            // Add a pointer to this chunk of data in the list
+            imgDataPtrs.push_back(dataPtr + sizeof(PNGChunk));
+            imgDataLens.push_back(dataLength);
+        }
+        // Check for end of chunks
+        else if(memcmp(chunk->type, "IEND", 4) == 0)
+            break;
+        
+        // Go to next chunk
+        dataPtr += sizeof(uint32_t) * 3 + dataLength; 
+    }
+
+    // Now we need to create one chuck of data for the decompressor to use
+    // First calculate the total lenght of data
+    uint32_t IDATLength = 0;
+    for(uint32_t len : imgDataLens)
+        IDATLength += len;
+
+    // Now allocate a buffer for this complete datablock
+    uint8_t* IDAT = new uint8_t[IDATLength];
+
+    // And copy all the blocks to this buffer
+    uint32_t offset = 0;
+    for(int i = 0; i < imgDataPtrs.size(); i++) {
+        memcpy(IDAT + offset, imgDataPtrs[i], imgDataLens[i]);
+        offset += imgDataLens[i];
+    }
+
+    // Decompress image data
+    Vector<uint8_t>* imageData = ZLIBDecompressor::Decompress(IDAT);
+    uint8_t* imageDataRaw = imageData->data();
+
+    // We don't need this anymore
+    delete IDAT;
+
+    // Create resulting image
+    Image* result = new Image(ihdr->width, ihdr->height);
+    uint8_t* recon = (uint8_t*)result->GetBufferPtr();
+    uint32_t reconIndex = 0;
+    uint32_t stride = ihdr->width * BYTES_PER_PIXEL;
+
+    uint32_t index = 0;
+    for(uint32_t r = 0; r < ihdr->height; r++)
+    {
+        uint8_t filterType = imageDataRaw[index++];
+        uint8_t reconX = 0;
+        for(uint32_t c = 0; c < stride; c++)
+        {
+            uint8_t filtX = imageDataRaw[index++];
+            if(filterType == 0)
+                reconX = filtX;
+            else if(filterType == 1)
+                reconX = filtX + Recon_a(recon, stride, r, c);
+            else if(filterType == 2)
+                reconX = filtX + Recon_b(recon, stride, r, c);
+            else if(filterType == 3)
+                reconX = filtX + ((Recon_a(recon, stride, r, c) + Recon_b(recon, stride, r, c)) / 2);
+            else if(filterType == 4)
+                reconX = filtX + PaethPredictor(recon, Recon_a(recon, stride, r, c), Recon_b(recon, stride, r, c), Recon_c(recon, stride, r, c));
+            else {
+                Print("[PNGDecoder] invalid filter type %d\n", filterType);
+            }
+            
+            recon[reconIndex] = reconX & 0xFF;
+            reconIndex++;
+        } 
+    }
+
+    // Convert to right pixel format
+    for(uint32_t i = 0; i < (result->GetHeight() * stride); i += 4)
+    {
+        const uint8_t a = recon[i + 3];
+        const uint8_t b = recon[i + 2];
+        const uint8_t g = recon[i + 1];
+        const uint8_t r = recon[i + 0];
+
+        recon[i + 3] = a;
+        recon[i + 2] = r;
+        recon[i + 1] = g;
+        recon[i + 0] = b;
+    }    
+
+    delete imageData;
+    return result;
+}
+
+uint8_t PNGDecoder::PaethPredictor(uint8_t* recon, uint8_t a, uint8_t b, uint8_t c)
+{
+    int p = a + b - c;
+    int pa = Math::Abs(p - a);
+    int pb = Math::Abs(p - b);
+    int pc = Math::Abs(p - c);
+    uint8_t pr = 0;
+    
+    if((pa <= pb) && (pa <= pc))
+        pr = a;
+    else if(pb <= pc)
+        pr = b;
+    else
+        pr = c;
+    
+    return pr;
+}
+uint8_t PNGDecoder::Recon_a(uint8_t* recon, uint32_t stride, uint32_t r, uint32_t c)
+{
+    if(c >= BYTES_PER_PIXEL)
+        return recon[r * stride + c - BYTES_PER_PIXEL];
+    return 0;
+}
+uint8_t PNGDecoder::Recon_b(uint8_t* recon, uint32_t stride, uint32_t r, uint32_t c)
+{
+    if(r > 0)
+        return recon[(r-1) * stride + c];
+    return 0;
+}
+uint8_t PNGDecoder::Recon_c(uint8_t* recon, uint32_t stride, uint32_t r, uint32_t c)
+{
+    if((r > 0) && (c >= BYTES_PER_PIXEL))
+        return recon[(r - 1) * stride + c - BYTES_PER_PIXEL];
+    return 0;
+}
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+Vector<uint8_t>* ZLIBDecompressor::Decompress(uint8_t* input)
+{
+    /*
+        Manely checking that this buffer is supported and valid, main function is the inflate method
+    */
+
+    BitReader* reader = new BitReader(input);
+
+    uint8_t CMF = reader->ReadByte();
+    uint8_t method = CMF & 0xF;
+    if(method != 8) return 0; // Only CM=8 is supported
+
+    uint8_t CINFO = (CMF >> 4) & 0xF;
+    if(CINFO > 7) return 0; // CINFO must be smaller that 8
+
+    uint8_t FLG = reader->ReadByte();
+    if(((CMF * 256 + FLG) % 31) != 0) return 0; // CMF+FLG checksum not correct
+
+    uint8_t FDICT = (FLG >> 5) & 1;
+    if(FDICT != 0) return 0; // FDICT is not supported
+
+    // Perform actual decompression
+    Vector<uint8_t>* result = ZLIBDecompressor::Inflate(reader);
+    
+    // Ignored for now
+    uint32_t adler32 = reader->ReadBytes<uint32_t>(4);
+
+    delete reader;
+    return result;
+}
+Vector<uint8_t>* ZLIBDecompressor::Inflate(BitReader* reader)
+{
+    uint8_t endOfBlocks = 0;
+    Vector<uint8_t>* buffer = new Vector<uint8_t>();
+    while (!endOfBlocks) 
+    {
+        endOfBlocks = reader->ReadBit();
+        uint8_t blockType = reader->ReadBits<uint8_t>(2);
+
+        //Print("[ZLIBDecompressor] Blocktype %d\n", blockType);
+        if(blockType == 0) {
+            ZLIBDecompressor::InflateBlockNoCompression(reader, buffer);
+        }
+        else if(blockType == 1) {
+            ZLIBDecompressor::InflateBlockStatic(reader, buffer);
+        }
+        else if(blockType == 2) {
+            ZLIBDecompressor::InflateBlockDynamic(reader, buffer);
+        }
+        else {
+            Print("[ZLIBDecompressor] Invalid blocktype %d\n", blockType);
+            return 0;
+        }
+    }
+
+    return buffer;
+}
+void ZLIBDecompressor::InflateBlockNoCompression(BitReader* reader, Vector<uint8_t>* target)
+{
+    uint16_t len = reader->ReadBytes<uint16_t>(2);
+    uint16_t nlen = reader->ReadBytes<uint16_t>(2);
+
+    for(uint16_t i = 0; i < len; i++)
+        target->push_back(reader->ReadByte());
+}
+uint32_t ZLIBDecompressor::DecodeSymbol(BitReader* reader, HuffmanTree* tree)
+{
+    HuffmanNode* node = tree->root;
+
+    while(node->left || node->right) {
+        uint8_t b = reader->ReadBit();
+        if(b) node = node->right;
+        else node = node->left;
+    }
+    return node->symbol;
+}
+void ZLIBDecompressor::InflateBlockData(BitReader* reader, HuffmanTree* literalLengthTree, HuffmanTree* distanceTree, Vector<uint8_t>* target)
+{
+    while(true)
+    {
+        uint32_t sym = DecodeSymbol(reader, literalLengthTree);
+        if (sym <= 255) { // Literal byte
+            target->push_back(sym & 0xFF);
+        }
+        else if(sym == 256) { // End of block
+            return;
+        }
+        else { // <length, backward distance> pair
+            sym -= 257;
+            uint32_t length = reader->ReadBits<uint32_t>(lengthExtraBits[sym]) + lengthBase[sym];
+            uint32_t distSym = DecodeSymbol(reader, distanceTree);
+            uint32_t dist = reader->ReadBits<uint32_t>(distanceExtraBits[distSym]) + distanceBase[distSym];
+            
+            dist = target->Size() - dist;
+            for(uint32_t i = 0; i < length; i++, dist++) {
+                target->push_back(target->GetAt(dist));
+            }
+        }
+    }
+}
+HuffmanTree* ZLIBDecompressor::BitListToTree(Vector<uint32_t>* bitList, Vector<uint8_t>* alphabet)
+{
+    uint32_t maxBits = 0;
+    for(uint32_t d : *bitList)
+        if(d > maxBits)
+            maxBits = d;
+    
+    uint32_t* blCount = new uint32_t[(maxBits+1)];
+    memset(blCount, 0, (maxBits + 1) * sizeof(uint32_t));
+    for(uint32_t i = 0; i < (maxBits+1); i++) {
+        // Count occurencies in bitList
+        for(uint32_t item : *bitList)
+            if(i == item && item != 0)
+                blCount[i] += 1;
+    }
+
+    uint32_t* nextCode = new uint32_t[(maxBits+1)];
+    memset(nextCode, 0, (maxBits + 1) * sizeof(uint32_t));
+    nextCode[0] = 0;
+    nextCode[1] = 0;
+    for(uint32_t bits = 2; bits < (maxBits+1); bits++) {
+        nextCode[bits] = ((nextCode[bits-1] + blCount[bits-1]) << 1);
+    }
+    
+    HuffmanTree* result = new HuffmanTree();
+    for(int i = 0; i < alphabet->Size(); i++) {
+        uint32_t c = i;
+        uint32_t bitLen = (i < bitList->Size()) ? bitList->GetAt(i) : 0;
+        if(bitLen) {
+            result->Insert(nextCode[bitLen], bitLen, c);
+            nextCode[bitLen] += 1;
+        }
+    }
+    delete blCount;
+    delete nextCode;
+    return result;
+}
+DecodeTreesResult ZLIBDecompressor::DecodeTrees(BitReader* reader)
+{
+    // The number of literal/length codes
+    uint32_t HLIT = reader->ReadBits<uint8_t>(5) + 257;
+
+    // The number of distance codes
+    uint32_t HDIST = reader->ReadBits<uint8_t>(5) + 1;
+
+    // The number of code length codes
+    uint32_t HCLEN = reader->ReadBits<uint8_t>(4) + 4;
+
+    // Create result container
+    DecodeTreesResult result;
+
+    // Read code lengths for the code length alphabet
+    uint32_t codeLengthTreeBitList[19];
+    for(int i = 0; i < 19; i++)
+        codeLengthTreeBitList[i] = 0;
+    
+    for(uint32_t i = 0; i < HCLEN; i++)
+        codeLengthTreeBitList[codeLengthCodesOrder[i]] = reader->ReadBits<uint8_t>(3);
+
+    Vector<uint32_t> codeLengthBitList;
+    Vector<uint8_t> codeLengthAlphaList;
+    for(int i = 0; i < 19; i++) {
+        codeLengthBitList.push_back(codeLengthTreeBitList[i]);
+        codeLengthAlphaList.push_back(i);
+    }
+
+    // Construct code length tree
+    HuffmanTree* codeLengthTree = BitListToTree(&codeLengthBitList, &codeLengthAlphaList);
+
+    // Read literal/length + distance code length list
+    Vector<uint32_t> bl;
+    while (bl.Size() < HLIT + HDIST)
+    {
+        uint32_t sym = DecodeSymbol(reader, codeLengthTree);
+        if((sym >= 0) && (sym <= 15)) { // literal value
+            bl.push_back(sym);
+        }
+        else if(sym == 16) {
+            // copy the previous code length 3..6 times.
+            // the next 2 bits indicate repeat length ( 0 = 3, ..., 3 = 6 )
+            uint32_t prev_code_length = bl.GetAt(bl.Size() - 1);
+            uint32_t repeat_length = reader->ReadBits<uint8_t>(2) + 3;
+            for(uint32_t i = 0; i < repeat_length; i++)
+                bl.push_back(prev_code_length);
+        }
+        else if(sym == 17) {
+            // repeat code length 0 for 3..10 times. (3 bits of length)
+            uint32_t repeat_length = reader->ReadBits<uint8_t>(3) + 3;
+            for(uint32_t i = 0; i < repeat_length; i++)
+                bl.push_back(0);
+        }
+        else if(sym == 18) {
+            // repeat code length 0 for 11..138 times. (7 bits of length)
+            uint32_t repeat_length = reader->ReadBits<uint8_t>(7) + 11;
+            for(uint32_t i = 0; i < repeat_length; i++)
+                bl.push_back(0);
+        }
+        else
+            Log(Error, "[ZLIBDecompressor] Invalid symbol");
+    }
+    delete codeLengthTree;
+
+    // Construct trees
+    Vector<uint32_t> blTemp;
+    Vector<uint8_t> alphaTemp;
+    for(uint32_t i = 0; i < HLIT; i++)
+        blTemp.push_back(bl[i]);
+    
+    for(int i = 0; i < 286; i++)
+        alphaTemp.push_back(i);
+    
+    // Create first tree for the literal lengths
+    result.literalLengthTree = BitListToTree(&blTemp, &alphaTemp);
+
+    // Reset lists for re-use
+    blTemp.clear();
+    alphaTemp.clear();
+
+    for(int i = HLIT; i < bl.Size(); i++)
+        blTemp.push_back(bl[i]);
+    
+    for(int i = 0; i < 30; i++)
+        alphaTemp.push_back(i);
+
+    // Create second list
+    result.distanceTree = BitListToTree(&blTemp, &alphaTemp);
+
+    // And exit function
+    return result;
+}
+void ZLIBDecompressor::InflateBlockDynamic(BitReader* reader, Vector<uint8_t>* target)
+{
+    DecodeTreesResult ret = ZLIBDecompressor::DecodeTrees(reader);
+
+    InflateBlockData(reader, ret.literalLengthTree, ret.distanceTree, target);
+    delete ret.literalLengthTree;
+    delete ret.distanceTree;
+}
+
+void ZLIBDecompressor::InflateBlockStatic(BitReader* reader, Vector<uint8_t>* target)
+{
+    static HuffmanTree* literalLengthTree = 0;
+    static HuffmanTree* distanceTree = 0;
+
+    if(literalLengthTree == 0) {
+        Vector<uint32_t> bl1;
+        
+        Vector<uint8_t> alphaTemp;
+        for(int i = 0; i < 286; i++)
+            alphaTemp.push_back(i);
+
+        for(int i = 0; i < 144; i++)
+            bl1.push_back(8);
+        for(int i = 144; i < 256; i++)
+            bl1.push_back(9);
+        for(int i = 256; i < 280; i++)
+            bl1.push_back(7);
+        for(int i = 280; i < 288; i++)
+            bl1.push_back(8);
+        
+        literalLengthTree = BitListToTree(&bl1, &alphaTemp);
+
+        bl1.clear();
+        alphaTemp.clear();
+        for(int i = 0; i < 30; i++) {
+            bl1.push_back(5);
+            alphaTemp.push_back(i);
+        }
+
+        distanceTree = BitListToTree(&bl1, &alphaTemp);
+    }
+
+    ZLIBDecompressor::InflateBlockData(reader, literalLengthTree, distanceTree, target);
+}
\ No newline at end of file
diff --git a/lib/src/ipc.cpp b/lib/src/ipc.cpp
new file mode 100644
index 0000000..a05ad55
--- /dev/null
+++ b/lib/src/ipc.cpp
@@ -0,0 +1,41 @@
+#include <ipc.h>
+#include <proc.h>
+#include <string.h>
+
+using namespace LIBCactusOS;
+
+int LIBCactusOS::IPCSend(int dest, int type, unsigned int arg1, unsigned int arg2, unsigned int arg3, unsigned int arg4, unsigned int arg5, unsigned int arg6)
+{
+    //Create IPCMessage
+    IPCMessage message;
+    message.dest = dest;
+    message.type = type;
+    message.source = Process::ID;
+    
+    //Copy args
+    message.arg1 = arg1;
+    message.arg2 = arg2;
+    message.arg3 = arg3;
+    message.arg4 = arg4;
+    message.arg5 = arg5;
+    message.arg6 = arg6;
+    
+    return IPCSend(message);
+}
+
+int LIBCactusOS::IPCSend(IPCMessage message)
+{
+    return DoSyscall(SYSCALL_IPC_SEND, (uint32_t)&message);
+}
+
+int LIBCactusOS::IPCAvailable()
+{
+    return DoSyscall(SYSCALL_IPC_AVAILABLE);
+}
+
+IPCMessage LIBCactusOS::ICPReceive(int fromID, int* errOut, int type)
+{
+    IPCMessage result;
+    DoSyscall(SYSCALL_IPC_RECEIVE, (uint32_t)&result, fromID, (uint32_t)errOut, type);
+    return result;
+}
\ No newline at end of file
diff --git a/lib/src/log.cpp b/lib/src/log.cpp
new file mode 100644
index 0000000..d252384
--- /dev/null
+++ b/lib/src/log.cpp
@@ -0,0 +1,131 @@
+#include <log.h>
+#include <syscall.h>
+#include <stdarg.h>
+#include <types.h>
+#include <string.h>
+#include <convert.h>
+#include <proc.h>
+
+using namespace LIBCactusOS;
+
+void LIBCactusOS::Log(LogLevel level, char* msg)
+{
+    DoSyscall(SYSCALL_LOG, level, (int)msg);
+}
+
+void printLen(const char* data, uint32_t length)
+{
+    Process::WriteStdOut((char*)data, (int)length);
+}
+
+void LIBCactusOS::Print(const char* __restrict__ format, ...)
+{
+    va_list parameters;
+	va_start(parameters, format);
+ 
+	while (*format != '\0') { 
+		if (format[0] != '%' || format[1] == '%') {
+			if (format[0] == '%')
+				format++;
+			uint32_t amount = 1;
+			while (format[amount] && format[amount] != '%')
+				amount++;
+			printLen(format, amount);
+			format += amount;
+			continue;
+		}
+ 
+		const char* format_begun_at = format++;
+ 
+		if (*format == 'c') {
+			format++;
+			char c = (char) va_arg(parameters, int /* char promotes to int */);
+			printLen(&c, sizeof(c));
+		} else if (*format == 's') {
+			format++;
+			const char* str = va_arg(parameters, const char*);
+			uint32_t len = strlen(str);
+			printLen(str, len);
+         } else if(*format == 'd') {
+            format++;
+            int n = va_arg(parameters, int);
+            int numChars = 0;
+            if (n < 0) { n = -n; numChars++; printLen("-", 1); }
+
+            int temp = n;
+            do
+            {
+                numChars++;
+                temp /= 10;
+            } while (temp);
+
+            printLen(Convert::IntToString(n), numChars);
+        } else if(*format == 'b') {
+            format++;
+            uint8_t n = va_arg(parameters, int);
+            char* str = Convert::IntToHexString(n);
+            printLen("0x", 2); printLen(str, sizeof(uint8_t)<<1);
+            delete str;
+        } else if(*format == 'w') {
+            format++;
+            uint16_t n = va_arg(parameters, int);
+            char* str = Convert::IntToHexString(n);
+            printLen("0x", 2); printLen(str, sizeof(uint16_t)<<1);
+            delete str;
+        } else if(*format == 'x') {
+            format++;
+            uint32_t n = va_arg(parameters, int);
+            char* str = Convert::IntToHexString(n);
+            printLen("0x", 2); printLen(str, sizeof(uint32_t)<<1);
+            delete str;
+        } else if(*format == 'f') {
+            format++;
+            double n = va_arg(parameters, double);
+            if(n < 0.0)
+            {
+                printLen("-", 1);
+                n = -n;
+            }
+            if(n != n) {//Not a number
+                printLen("NaN", 3);
+                return;   
+            }
+
+            //Print integer part
+            Print("%d", (int)n);
+        
+            // remove the integer part
+            n -= (double)((int)n);
+
+            if(n != 0.0)
+                // now on to the decimal potion
+                printLen(".", 1);
+
+            /* on every iteration, make sure there are still decimal places left that are non-zero,
+            and make sure we're still within the user-defined precision range. */
+            int cur_prec = 1;
+            while(n > (double)((int)n) && cur_prec++ < 8)
+            {
+                // move the next decimal into the integer portion and print it
+                n *= 10;
+                Print("%d", (int)n);
+            
+                /* if the nue is == the floored nue (integer portion),
+                then there are no more decimal places that are non-zero. */
+                if(n == (double)((int)n))
+                    break;
+            
+                // subtract the integer portion
+                n -= (double)((int)n);
+            }
+
+        } else {
+			format = format_begun_at;
+			uint32_t len = strlen(format);
+			printLen(format, len);
+			format += len;
+		}
+	}
+ 
+	va_end(parameters);
+}
\ No newline at end of file
diff --git a/lib/src/main.cpp b/lib/src/main.cpp
new file mode 100644
index 0000000..4eadac9
--- /dev/null
+++ b/lib/src/main.cpp
@@ -0,0 +1,105 @@
+#include <syscall.h>
+#include <api.h>
+#include <heap.h>
+#include <gui/gui.h>
+#include <log.h>
+#include <math.h>
+#include <string.h>
+
+using namespace LIBCactusOS;
+
+// External pointer to main function, will be linked later by the compiler
+// This is the part of the program where the user has control, this is more in the background
+extern int main(int argc, char** argv);
+
+// Create a easy usable type for constructors
+typedef void (*constructor)();
+
+// Defined in linker.ld
+extern "C" constructor start_ctors;
+extern "C" constructor end_ctors;
+
+// Needs to be callable from assembly, hence the extern "C"
+extern "C" void callConstructors()
+{
+    for(constructor* i = &start_ctors; i != &end_ctors; i++) {
+        (*i)();
+    }
+}
+
+// TODO: Is this right? It does not seem to be defined anywhere
+extern "C" constructor start_dtors;
+extern "C" constructor end_dtors;
+
+// Needs to be callable from assembly, hence the extern "C"
+extern "C" void callDestructors()
+{
+    for(constructor* i = &start_dtors; i != &end_dtors; i++) {
+        (*i)();
+    }
+}
+
+// A function that takes a arguments string and parses it to the format that GCC and all normal programs accept
+// For example:
+// Input -> -a all -b extra ./hello
+// Output -> argc = 5 argv = {"-a", "all", "-b", "extra", "./hello" }
+char** ArgumentParser(char* arguments, int* argcPtr)
+{
+    List<char*> splitList = str_Split(arguments, ' ');
+    *argcPtr = splitList.size();
+
+    char** output = new char*[splitList.size()];
+    for(int i = 0; i < splitList.size(); i++) {
+        char* src = splitList[i];
+        int srcLen = strlen(src);
+
+        output[i] = new char[srcLen + 1];
+        char* dst = output[i];
+        memcpy(dst, src, srcLen);
+        dst[srcLen] = '\0';
+    }
+    return output;
+}
+
+// Called by the initializing assembly (crt0.asm)
+extern "C" void libMain()
+{
+    // First tell the systemcalls subsystem that we want to use CactusOS syscalls and not linux
+    API::Initialize();
+
+    // Enable the FPU device for mathematical calculations
+    Math::EnableFPU();
+
+    // We also need memory to work, this will make sure that new and delete actually can be used
+    UserHeap::Initialize();
+
+    // Prepare some stuff for the GUI. Yes this is also called for console applications since it is so common.
+    GUI::Initialize();
+
+    // Call all initializing constructors
+    callConstructors();
+
+    // Create a buffer for receiving the arguments from the kernel
+    char* argBuffer = new char[PROC_ARG_LEN_MAX];
+    memset(argBuffer, 0, PROC_ARG_LEN_MAX);
+
+    // Request arguments from kernel
+    DoSyscall(SYSCALL_GET_ARGUMENTS, (uint32_t)argBuffer);
+
+    // Parse arguments into common format
+    int argc = 0;
+    char** argv = ArgumentParser(argBuffer, &argc);
+
+    // Now we can call the user function main, this is where the program seems to start for the user
+    int ret = main(argc, argv);
+
+    // Perform some cleanups
+    callDestructors();
+    GUI::CleanUp();
+
+    // And make sure this program actually quits
+    DoSyscall(SYSCALL_EXIT, ret);
+
+    // This is real bad, this means the scheduler is broken
+    while(1) Log(Error, "CRITICAL: Program does not appear to be stopped!");
+}
\ No newline at end of file
diff --git a/lib/src/math.cpp b/lib/src/math.cpp
new file mode 100644
index 0000000..17b76bc
--- /dev/null
+++ b/lib/src/math.cpp
@@ -0,0 +1,136 @@
+#include <math.h>
+#include <types.h>
+#include <log.h>
+
+using namespace LIBCactusOS;
+
+uint32_t getMXCSR (void)
+{
+  uint32_t temp;
+  asm volatile("stmxcsr %0" : "=m" (temp));
+  return temp;
+}
+
+void setMXCSR (uint32_t val)
+{
+  asm volatile ("ldmxcsr %0" : : "m" (val));
+}
+
+void Math::EnableFPU()
+{
+    asm volatile("fninit"); //First initialize the fpu and set to default state
+
+    uint32_t v = getMXCSR();
+
+    MXCSR_StatusRegister* mxcsr = (MXCSR_StatusRegister*)&v;
+
+    mxcsr->FlushToZero = 1;
+    mxcsr->PrecisionMask = 1;
+
+    setMXCSR(v);
+}
+
+long Math::Abs(long v)
+{
+    if(v == 0)
+        return 0;
+    if(v < 0)
+        return -v;
+    if(v > 0)
+        return v;
+    return v;
+}
+double Math::fAbs(double x)
+{
+    if(x == 0.0)
+        return 0;
+    if(x < 0.0)
+        return -x;
+    if(x > 0.0)
+        return x;
+    return x;
+}
+long Math::Sign(long v)
+{
+    if(v < 0)
+        return -1;
+    if(v == 0)
+        return 0;
+    if(v > 1)
+        return 1;
+    return 0;
+}
+double Math::sin(double x)
+{
+    int i = 1;
+    double cur = x;
+    double acc = 1;
+    double fact= 1;
+    double pow = x;
+    while (fAbs(acc) > .00000001 && i < 100){
+        fact *= ((2*i)*(2*i+1));
+        pow *= -1 * x*x; 
+        acc =  pow / fact;
+        cur += acc;
+        i++;
+    }
+    return cur;
+}
+double Math::cos(double x) {
+    return sin(x + MATH_PI / 2.0);
+}
+long Math::Max (long a, long b) {
+  return (a < b) ? b : a;
+}
+long Math::Min(long a, long b) {
+  return !(b < a) ? a : b;
+}
+long Math::Constrain(long x, long a, long b)
+{
+    if(x < a)
+        return a;
+    else if(b < x)
+        return b;
+    else
+        return x;
+}
+long Math::Map(long x, long in_min, long in_max, long out_min, long out_max)
+{
+    return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
+}
+float Math::fMod(float a, float b)
+{
+    return (a - b * floor(a / b));
+}
+double Math::floor(double x) {
+    if (x >= __LONG_LONG_MAX__ || x <= (-__LONG_LONG_MAX__-1) || x != x) {
+        /* handle large values, infinities and nan */
+        return x;
+    }
+    long long n = (long long)x;
+    double d = (double)n;
+    if (d == x || x >= 0)
+        return d;
+    else
+        return d - 1;
+}
+double Math::sqrt(double n)
+{
+    double lo = 0, hi = n, mid;
+    for(int i = 0 ; i < 1000 ; i++){
+        mid = (lo+hi)/2;
+        if(mid*mid == n) return mid;
+        if(mid*mid > n) hi = mid;
+        else lo = mid;
+    }
+    return mid;
+}
+double Math::Round(double x, uint32_t digits)
+{
+    if (digits > 0) {
+        return Round(x*10.0, digits-1)/10.0;
+    }
+    else {
+        return (double)(int)(x);
+    }
+}
\ No newline at end of file
diff --git a/lib/src/proc.cpp b/lib/src/proc.cpp
new file mode 100644
index 0000000..e5de252
--- /dev/null
+++ b/lib/src/proc.cpp
@@ -0,0 +1,72 @@
+#include <proc.h>
+#include <listing.h>
+
+using namespace LIBCactusOS;
+
+int Process::ID = -1;
+int Process::numThreads = 1;
+SharedSystemInfo* Process::systemInfo = 0;
+
+int Process::Run(const char* path, bool block)
+{
+    return DoSyscall(SYSCALL_RUN_PROC, (uint32_t)path, (uint32_t)block);
+}
+bool Process::CreateSharedMemory(int proc2ID, uint32_t virtStart1, uint32_t virtStart2, uint32_t len)
+{
+    return DoSyscall(SYSCALL_CREATE_SHARED_MEM, proc2ID, virtStart1, virtStart2, len);
+}
+bool Process::CreateSharedMemory(int proc2ID, uint32_t virtStart, uint32_t len)
+{
+    return CreateSharedMemory(proc2ID, virtStart, virtStart, len);
+}
+bool Process::DeleteSharedMemory(int proc2ID, uint32_t virtStart, uint32_t len)
+{
+    return DeleteSharedMemory(proc2ID, virtStart, virtStart, len);
+}
+bool Process::DeleteSharedMemory(int proc2ID, uint32_t virtStart1, uint32_t virtStart2, uint32_t len)
+{
+    return DoSyscall(SYSCALL_REMOVE_SHARED_MEM, proc2ID, virtStart1, virtStart2, len);
+}
+void Process::CreateThread(void (*entryPoint)(), bool switchTo)
+{
+    DoSyscall(SYSCALL_START_THREAD, (uint32_t)entryPoint, switchTo);
+    Process::numThreads++;
+}
+void Process::Yield()
+{
+    DoSyscall(SYSCALL_YIELD);
+}
+void Process::SetScheduler(bool active)
+{
+    DoSyscall(SYSCALL_SET_SCHEDULER, active);
+}
+void Process::WriteStdOut(char byte)
+{
+    char bytes[1];
+    bytes[0] = byte;
+    DoSyscall(SYSCALL_WRITE_STDIO, (uint32_t)bytes, 1);
+}
+void Process::WriteStdOut(char* bytes, int length)
+{
+    DoSyscall(SYSCALL_WRITE_STDIO, (uint32_t)bytes, length);
+}
+char Process::ReadStdIn()
+{
+    return DoSyscall(SYSCALL_READ_STDIO);
+}
+void Process::BindSTDIO(int fromID, int toID)
+{
+    DoSyscall(SYSCALL_REDIRECT_STDIO, fromID, toID);
+}
+int Process::StdInAvailable()
+{
+    return DoSyscall(SYSCALL_STDIO_AVAILABLE);
+}
+bool Process::Active(int pid)
+{
+    return DoSyscall(SYSCALL_PROC_EXIST, pid);
+}
+void Process::Unblock(int procPID, int thread)
+{
+    DoSyscall(SYSCALL_UNBLOCK, procPID, thread);
+}
\ No newline at end of file
diff --git a/lib/src/random.cpp b/lib/src/random.cpp
new file mode 100644
index 0000000..2733b67
--- /dev/null
+++ b/lib/src/random.cpp
@@ -0,0 +1,21 @@
+#include <random.h>
+
+using namespace LIBCactusOS;
+
+uint32_t next = 12;
+
+int Random::Next(uint32_t max)
+{
+    next = next * 1103515245 + 12345;
+    return (unsigned int)(next / 65536) % (max+1);
+}
+
+int Random::Next(uint32_t min, uint32_t max)
+{
+    return Next(max-min) + min;
+}
+
+void Random::SetSeed(uint32_t seed)
+{
+    next = seed;
+}
\ No newline at end of file
diff --git a/lib/src/string.cpp b/lib/src/string.cpp
new file mode 100644
index 0000000..4b210b2
--- /dev/null
+++ b/lib/src/string.cpp
@@ -0,0 +1,166 @@
+#include <string.h>
+
+void* memmove(void* dstptr, const void* srcptr, size_t size) {
+	unsigned char* dst = (unsigned char*) dstptr;
+	const unsigned char* src = (const unsigned char*) srcptr;
+	if (dst < src) {
+		for (size_t i = 0; i < size; i++)
+			dst[i] = src[i];
+	} else {
+		for (size_t i = size; i != 0; i--)
+			dst[i-1] = src[i-1];
+	}
+	return dstptr;
+}
+
+size_t strlen(const char* str) {
+	size_t len = 0;
+	while (str[len])
+		len++;
+	return len;
+}
+
+int memcmp(const void* aptr, const void* bptr, size_t size) {
+	const unsigned char* a = (const unsigned char*) aptr;
+	const unsigned char* b = (const unsigned char*) bptr;
+	for (size_t i = 0; i < size; i++) {
+		if (a[i] < b[i])
+			return -1;
+		else if (b[i] < a[i])
+			return 1;
+	}
+	return 0;
+}
+
+void* memset(void* bufptr, int value, size_t size) {
+	unsigned char* buf = (unsigned char*) bufptr;
+	for (size_t i = 0; i < size; i++)
+		buf[i] = (unsigned char) value;
+	return bufptr;
+}
+
+void* memcpy(void* __restrict__ dstptr, const void* __restrict__ srcptr, size_t size) {
+	unsigned char* dst = (unsigned char*) dstptr;
+	const unsigned char* src = (const unsigned char*) srcptr;
+	for (size_t i = 0; i < size; i++)
+		dst[i] = src[i];
+	return dstptr;
+}
+
+int strcmp(const char *s1, const char *s2)
+{
+    while ((*s1 == *s2) && *s1) { ++s1; ++s2; }
+    return (((int) (unsigned char) *s1) - ((int) (unsigned char) *s2) == 0) ? 1 : 0;
+}
+
+int str_IndexOf(const char* str, char c, int skip)
+{
+    int hits = 0;
+    int i = 0;
+    while(str[i])
+    {
+        if(str[i] == c && hits++ == skip)
+            return i;
+        i++;
+    }
+    return -1;
+}
+
+bool str_Contains(const char* str, char c)
+{
+    int i = 0;
+	while (str[i])
+    {
+        if(str[i] == c)
+            return true;
+		i++;
+    }
+    return false;
+}
+
+char* str_Uppercase(char* str)
+{ 
+    int len = strlen(str);
+    int i = 0;
+	while (i < len)
+	{
+		if ((short)str[i] >= 97 && (short)str[i] <= 122)
+			str[i] -= 32;
+		i++;
+	}
+    return str;
+}
+char* str_Lowercase(char* str)
+{
+    int len = strlen(str);
+    int i = 0;
+	while (i < len)
+	{
+		if ((short)str[i] >= 65 && (short)str[i] <= 90)
+			str[i] += 32;
+		i++;
+	}
+    return str;
+}
+List<char*> str_Split(const char* str, char d)
+{
+    List<char*> Result;
+
+    int amountOfDelims = 0;
+    while(str_IndexOf(str, d, amountOfDelims) != -1)
+        amountOfDelims++;
+    
+    if(amountOfDelims == 0)
+        return Result;
+    
+    int* delimOffsets = new int[amountOfDelims];
+    for(int i = 0; i < amountOfDelims; i++)
+        delimOffsets[i] = str_IndexOf(str, d, i);
+
+    for(int i = 0; i < amountOfDelims; i++)
+    {
+        int len = i >= 1 ? (delimOffsets[i] - delimOffsets[i - 1] - 1) : delimOffsets[i];
+
+        char* partStr = new char[len + 1];
+        memcpy(partStr, str + (i >= 1 ? delimOffsets[i - 1] + 1 : 0), len);
+        partStr[len] = '\0';
+
+        Result.push_back(partStr);
+    }
+
+    //Don't forget to add the remaining part of the string
+    int stringRemainder = strlen(str) - delimOffsets[amountOfDelims - 1];
+    char* lastStr = new char[stringRemainder];
+    memcpy(lastStr, str + delimOffsets[amountOfDelims - 1] + 1, stringRemainder);
+    lastStr[stringRemainder] = '\0';
+
+    Result.push_back(lastStr);
+
+    return Result;
+}
+char* str_Add(char* str, char c)
+{
+	int oldLen = strlen(str);
+    char* newStr = new char[oldLen + 1];
+    memcpy(newStr, str, oldLen);
+    newStr[oldLen] = c;
+    newStr[oldLen + 1] = '\0';
+	
+	delete str;
+	return newStr;
+}
+char* str_Combine(char* part1, char* part2)
+{
+    int len1 = strlen(part1);
+    int len2 = strlen(part2);
+
+    char* res = new char[len1 + len2 + 1];
+    memcpy(res, part1, len1);
+    memcpy(res + len1, part2, len2);
+    res[len1 + len2] = '\0';
+    return res;
+}
+bool isvalid(unsigned char key)
+{
+    return ((int)key > 31 && (int)key < 127) || key == '\n' || key == '\b' || key == '\t';
+}
\ No newline at end of file
diff --git a/lib/src/syscall.cpp b/lib/src/syscall.cpp
new file mode 100644
index 0000000..83a6e11
--- /dev/null
+++ b/lib/src/syscall.cpp
@@ -0,0 +1,21 @@
+#include <syscall.h>
+
+/*
++---+--------------------+
+| r |    Register(s)     |
++---+--------------------+
+| a |   %eax, %ax, %al   |
+| b |   %ebx, %bx, %bl   |
+| c |   %ecx, %cx, %cl   |
+| d |   %edx, %dx, %dl   |
+| S |   %esi, %si        |
+| D |   %edi, %di        |
++---+--------------------+
+*/
+
+int LIBCactusOS::DoSyscall(unsigned int intNum, unsigned int arg1, unsigned int arg2, unsigned int arg3, unsigned int arg4, unsigned int arg5)
+{
+    int a;
+    asm volatile("int $0x80" : "=a" (a) : "0" (intNum), "b" ((int)arg1), "c" ((int)arg2), "d" ((int)arg3), "S" ((int)arg4), "D" ((int)arg5));
+    return a;
+}
\ No newline at end of file
diff --git a/lib/src/systeminfo.cpp b/lib/src/systeminfo.cpp
new file mode 100644
index 0000000..15e59a1
--- /dev/null
+++ b/lib/src/systeminfo.cpp
@@ -0,0 +1,142 @@
+#include <systeminfo.h>
+#include <syscall.h>
+#include <proc.h>
+#include <heap.h>
+#include <string.h>
+#include <types.h>
+#include <log.h>
+
+using namespace LIBCactusOS;
+
+SIPropertyProvider SystemInfo::Properties = SIPropertyProvider("properties");
+
+bool SystemInfo::RequestSystemInfo()
+{
+    bool ret = DoSyscall(SYSCALL_MAP_SYSINFO, SYSTEM_INFO_ADDR);
+    if(ret)
+        Process::systemInfo = (SharedSystemInfo*)SYSTEM_INFO_ADDR;
+    
+    return ret;
+}
+
+
+
+SIPropertyProvider::SIPropertyProvider(char* identifier)
+{
+    this->id = identifier;
+    this->parent = 0;
+}
+SIPropertyProvider::SIPropertyProvider(int index)
+{
+    this->index = index;
+    this->parent = 0;
+}
+
+int SIPropertyProvider::size()
+{
+    return this->receiveValue<int>(true);
+}
+
+SIPropertyProvider SIPropertyProvider::operator[](const int index)
+{
+    SIPropertyProvider ret = SIPropertyProvider(index);
+    ret.parent = this;
+    ret.type = Index;
+    return ret;
+}
+SIPropertyProvider SIPropertyProvider::operator[](const char* element)
+{
+    SIPropertyProvider ret = SIPropertyProvider((char*)element);
+    ret.parent = this;
+    ret.type = String;
+    return ret;
+}
+
+
+template<typename T>
+T SIPropertyProvider::receiveValue(const bool getSize) const
+{
+    int count = 0;
+    SIPropertyProvider* item = (SIPropertyProvider*)this;
+    while(item) {
+        count++;
+        item = item->parent;
+    }
+
+    SIPropertyProvider* pathArray = (SIPropertyProvider*)UserHeap::Malloc(sizeof(SIPropertyProvider) * count);
+    memset(pathArray, 0, sizeof(SIPropertyProvider) * count);
+
+    item = (SIPropertyProvider*)this;
+    for(int i = (count-1); i >= 0; i--) {
+        pathArray[i] = *item;
+        item = item->parent;
+    }
+
+    T returnValue = (T)0;
+    if(DoSyscall(SYSCALL_GET_SYSINFO_VALUE, (uint32_t)pathArray, (uint32_t)&returnValue, count, (uint32_t)getSize) != SYSCALL_RET_SUCCES)
+        Log(Error, "Could not get system property");
+
+    UserHeap::Free(pathArray);
+    return returnValue;
+}
+
+template<typename T>
+T SIPropertyProvider::receiveBuffer() const
+{
+    int count = 0;
+    SIPropertyProvider* item = (SIPropertyProvider*)this;
+    while(item) {
+        count++;
+        item = item->parent;
+    }
+
+    SIPropertyProvider* pathArray = (SIPropertyProvider*)UserHeap::Malloc(sizeof(SIPropertyProvider) * count);
+    memset(pathArray, 0, sizeof(SIPropertyProvider) * count);
+
+    item = (SIPropertyProvider*)this;
+    for(int i = (count-1); i >= 0; i--) {
+        pathArray[i] = *item;
+        item = item->parent;
+    }
+
+    T returnValue = (T)(new uint8_t[1_KB]);
+    memset(returnValue, 0, 1_KB);
+    if(DoSyscall(SYSCALL_GET_SYSINFO_VALUE, (uint32_t)pathArray, (uint32_t)returnValue, count) != SYSCALL_RET_SUCCES)
+        Log(Error, "Could not get system property");
+
+    UserHeap::Free(pathArray);
+    return returnValue;
+}
+
+SIPropertyProvider::operator int() const
+{    
+    return this->receiveValue<int>(false);
+}
+SIPropertyProvider::operator bool() const
+{
+    return this->receiveValue<bool>(false);
+}
+SIPropertyProvider::operator double() const
+{
+    return this->receiveValue<double>(false);
+}
+SIPropertyProvider::operator char*() const
+{
+    return this->receiveBuffer<char*>();
+}
+SIPropertyProvider::operator uint64_t() const
+{
+    return this->receiveValue<uint64_t>(false);
+}
+SIPropertyProvider::operator uint32_t() const
+{
+    return this->receiveValue<uint32_t>(false);
+}
+SIPropertyProvider::operator uint16_t() const
+{
+    return this->receiveValue<uint16_t>(false);
+}
+SIPropertyProvider::operator uint8_t() const
+{
+    return this->receiveValue<uint8_t>(false);
+}
\ No newline at end of file
diff --git a/lib/src/time.cpp b/lib/src/time.cpp
new file mode 100644
index 0000000..cdf3b0d
--- /dev/null
+++ b/lib/src/time.cpp
@@ -0,0 +1,17 @@
+#include <time.h>
+
+#include <syscall.h>
+
+using namespace LIBCactusOS;
+
+void Time::Sleep(uint32_t ms)
+{
+    DoSyscall(SYSCALL_SLEEP_MS, ms);
+}
+
+uint64_t Time::Ticks()
+{
+    uint64_t r = 0;
+    DoSyscall(SYSCALL_GET_TICKS, (uint32_t)&r);
+    return r;
+}
\ No newline at end of file
diff --git a/lib/src/vfs.cpp b/lib/src/vfs.cpp
new file mode 100644
index 0000000..20f87b6
--- /dev/null
+++ b/lib/src/vfs.cpp
@@ -0,0 +1,58 @@
+#include <vfs.h>
+
+#include <syscall.h>
+#include <listing.h>
+
+using namespace LIBCactusOS;
+
+bool LIBCactusOS::FileExists(char* path)
+{
+    return (bool)DoSyscall(SYSCALL_FILE_EXISTS, (uint32_t)path);
+}
+uint32_t LIBCactusOS::GetFileSize(char* path)
+{
+    return (uint32_t)DoSyscall(SYSCALL_GET_FILESIZE, (uint32_t)path);
+}
+int LIBCactusOS::ReadFile(char* path, uint8_t* buffer, uint32_t offset, uint32_t len)
+{
+    return (int)DoSyscall(SYSCALL_READ_FILE, (uint32_t)path, (uint32_t)buffer, offset, len);
+}
+int LIBCactusOS::WriteFile(char* path, uint8_t* buffer, uint32_t len, bool create)
+{
+    return (int)DoSyscall(SYSCALL_WRITE_FILE, (uint32_t)path, (uint32_t)buffer, len, (uint32_t)create);
+}
+int LIBCactusOS::CreateFile(char* path)
+{
+    return (int)DoSyscall(SYSCALL_CREATE_FILE, (uint32_t)path);
+}
+int LIBCactusOS::CreateDirectory(char* path)
+{
+    return (int)DoSyscall(SYSCALL_CREATE_DIRECTORY, (uint32_t)path);
+}
+bool LIBCactusOS::DirectoryExists(char* path)
+{
+    return (bool)DoSyscall(SYSCALL_DIR_EXISTS, (uint32_t)path);
+}
+bool LIBCactusOS::EjectDisk(char* path)
+{
+    return (bool)DoSyscall(SYSCALL_EJECT_DISK, (uint32_t)path);
+}
+List<VFSEntry> LIBCactusOS::DirectoryListing(char* path)
+{
+    List<VFSEntry> result;
+
+    int items = DoSyscall(SYSCALL_BEGIN_LISTING, DIRECTORY_LISTING, (uint32_t)path);
+    if(items == -1)
+        return result;
+    
+    for(int i = 0; i < items; i++) {
+        VFSEntry entry;
+        int strLen = DoSyscall(SYSCALL_LISTING_ENTRY, DIRECTORY_LISTING, (uint32_t)i, (uint32_t)&entry);
+        if(strLen == 0)
+            return result; // End of items
+
+        result += entry;
+    }
+    DoSyscall(SYSCALL_END_LISTING, DIRECTORY_LISTING);
+    return result;
+}
\ No newline at end of file
diff --git a/lib/abi/arm/call.c b/libz/abi/arm/call.c
similarity index 100%
rename from lib/abi/arm/call.c
rename to libz/abi/arm/call.c
diff --git a/lib/abi/arm/crt0.s b/libz/abi/arm/crt0.s
similarity index 100%
rename from lib/abi/arm/crt0.s
rename to libz/abi/arm/crt0.s
diff --git a/lib/abi/arm/qrules.mk b/libz/abi/arm/qrules.mk
similarity index 100%
rename from lib/abi/arm/qrules.mk
rename to libz/abi/arm/qrules.mk
diff --git a/lib/abi/arm/rules.mk b/libz/abi/arm/rules.mk
similarity index 100%
rename from lib/abi/arm/rules.mk
rename to libz/abi/arm/rules.mk
diff --git a/lib/abi/call.c b/libz/abi/call.c
similarity index 100%
rename from lib/abi/call.c
rename to libz/abi/call.c
diff --git a/lib/abi/call.h b/libz/abi/call.h
similarity index 100%
rename from lib/abi/call.h
rename to libz/abi/call.h
diff --git a/lib/abi/channel.c b/libz/abi/channel.c
similarity index 100%
rename from lib/abi/channel.c
rename to libz/abi/channel.c
diff --git a/lib/abi/channel.h b/libz/abi/channel.h
similarity index 100%
rename from lib/abi/channel.h
rename to libz/abi/channel.h
diff --git a/lib/abi/crt0.c b/libz/abi/crt0.c
similarity index 100%
rename from lib/abi/crt0.c
rename to libz/abi/crt0.c
diff --git a/lib/abi/crt0.h b/libz/abi/crt0.h
similarity index 100%
rename from lib/abi/crt0.h
rename to libz/abi/crt0.h
diff --git a/lib/abi/job.c b/libz/abi/job.c
similarity index 100%
rename from lib/abi/job.c
rename to libz/abi/job.c
diff --git a/lib/abi/job.h b/libz/abi/job.h
similarity index 100%
rename from lib/abi/job.h
rename to libz/abi/job.h
diff --git a/lib/abi/option.c b/libz/abi/option.c
similarity index 100%
rename from lib/abi/option.c
rename to libz/abi/option.c
diff --git a/lib/abi/option.h b/libz/abi/option.h
similarity index 100%
rename from lib/abi/option.h
rename to libz/abi/option.h
diff --git a/lib/abi/riscv/call.c b/libz/abi/riscv/call.c
similarity index 100%
rename from lib/abi/riscv/call.c
rename to libz/abi/riscv/call.c
diff --git a/lib/abi/riscv/crt0.s b/libz/abi/riscv/crt0.s
similarity index 100%
rename from lib/abi/riscv/crt0.s
rename to libz/abi/riscv/crt0.s
diff --git a/lib/abi/riscv/qrules.mk b/libz/abi/riscv/qrules.mk
similarity index 100%
rename from lib/abi/riscv/qrules.mk
rename to libz/abi/riscv/qrules.mk
diff --git a/lib/abi/riscv/rules.mk b/libz/abi/riscv/rules.mk
similarity index 100%
rename from lib/abi/riscv/rules.mk
rename to libz/abi/riscv/rules.mk
diff --git a/lib/abi/rules.mk b/libz/abi/rules.mk
similarity index 100%
rename from lib/abi/rules.mk
rename to libz/abi/rules.mk
diff --git a/lib/abi/x86/call.s b/libz/abi/x86/call.s
similarity index 100%
rename from lib/abi/x86/call.s
rename to libz/abi/x86/call.s
diff --git a/lib/abi/x86/crt0.s b/libz/abi/x86/crt0.s
similarity index 100%
rename from lib/abi/x86/crt0.s
rename to libz/abi/x86/crt0.s
diff --git a/lib/abi/x86/qcall.s b/libz/abi/x86/qcall.s
similarity index 100%
rename from lib/abi/x86/qcall.s
rename to libz/abi/x86/qcall.s
diff --git a/lib/abi/x86/qrules.mk b/libz/abi/x86/qrules.mk
similarity index 100%
rename from lib/abi/x86/qrules.mk
rename to libz/abi/x86/qrules.mk
diff --git a/lib/abi/x86/rules.mk b/libz/abi/x86/rules.mk
similarity index 100%
rename from lib/abi/x86/rules.mk
rename to libz/abi/x86/rules.mk
diff --git a/lib/fudge/arm/__aeabi_idiv.c b/libz/fudge/arm/__aeabi_idiv.c
similarity index 100%
rename from lib/fudge/arm/__aeabi_idiv.c
rename to libz/fudge/arm/__aeabi_idiv.c
diff --git a/lib/fudge/arm/__aeabi_idivmod.s b/libz/fudge/arm/__aeabi_idivmod.s
similarity index 100%
rename from lib/fudge/arm/__aeabi_idivmod.s
rename to libz/fudge/arm/__aeabi_idivmod.s
diff --git a/lib/fudge/arm/__aeabi_uidiv.c b/libz/fudge/arm/__aeabi_uidiv.c
similarity index 100%
rename from lib/fudge/arm/__aeabi_uidiv.c
rename to libz/fudge/arm/__aeabi_uidiv.c
diff --git a/lib/fudge/arm/__aeabi_uidivmod.s b/libz/fudge/arm/__aeabi_uidivmod.s
similarity index 100%
rename from lib/fudge/arm/__aeabi_uidivmod.s
rename to libz/fudge/arm/__aeabi_uidivmod.s
diff --git a/lib/fudge/arm/__clzsi2.c b/libz/fudge/arm/__clzsi2.c
similarity index 100%
rename from lib/fudge/arm/__clzsi2.c
rename to libz/fudge/arm/__clzsi2.c
diff --git a/lib/fudge/arm/__divsi3.c b/libz/fudge/arm/__divsi3.c
similarity index 100%
rename from lib/fudge/arm/__divsi3.c
rename to libz/fudge/arm/__divsi3.c
diff --git a/lib/fudge/arm/__modsi3.c b/libz/fudge/arm/__modsi3.c
similarity index 100%
rename from lib/fudge/arm/__modsi3.c
rename to libz/fudge/arm/__modsi3.c
diff --git a/lib/fudge/arm/__udivmodsi4.c b/libz/fudge/arm/__udivmodsi4.c
similarity index 100%
rename from lib/fudge/arm/__udivmodsi4.c
rename to libz/fudge/arm/__udivmodsi4.c
diff --git a/lib/fudge/arm/__udivsi3.c b/libz/fudge/arm/__udivsi3.c
similarity index 100%
rename from lib/fudge/arm/__udivsi3.c
rename to libz/fudge/arm/__udivsi3.c
diff --git a/lib/fudge/arm/__umodsi3.c b/libz/fudge/arm/__umodsi3.c
similarity index 100%
rename from lib/fudge/arm/__umodsi3.c
rename to libz/fudge/arm/__umodsi3.c
diff --git a/lib/fudge/arm/atomic.c b/libz/fudge/arm/atomic.c
similarity index 100%
rename from lib/fudge/arm/atomic.c
rename to libz/fudge/arm/atomic.c
diff --git a/lib/fudge/arm/rules.mk b/libz/fudge/arm/rules.mk
similarity index 100%
rename from lib/fudge/arm/rules.mk
rename to libz/fudge/arm/rules.mk
diff --git a/lib/fudge/atomic.h b/libz/fudge/atomic.h
similarity index 100%
rename from lib/fudge/atomic.h
rename to libz/fudge/atomic.h
diff --git a/lib/fudge/base64.c b/libz/fudge/base64.c
similarity index 100%
rename from lib/fudge/base64.c
rename to libz/fudge/base64.c
diff --git a/lib/fudge/base64.h b/libz/fudge/base64.h
similarity index 100%
rename from lib/fudge/base64.h
rename to libz/fudge/base64.h
diff --git a/lib/fudge/buffer.c b/libz/fudge/buffer.c
similarity index 100%
rename from lib/fudge/buffer.c
rename to libz/fudge/buffer.c
diff --git a/lib/fudge/buffer.h b/libz/fudge/buffer.h
similarity index 100%
rename from lib/fudge/buffer.h
rename to libz/fudge/buffer.h
diff --git a/lib/fudge/cpio.c b/libz/fudge/cpio.c
similarity index 100%
rename from lib/fudge/cpio.c
rename to libz/fudge/cpio.c
diff --git a/lib/fudge/cpio.h b/libz/fudge/cpio.h
similarity index 100%
rename from lib/fudge/cpio.h
rename to libz/fudge/cpio.h
diff --git a/lib/fudge/cstring.c b/libz/fudge/cstring.c
similarity index 100%
rename from lib/fudge/cstring.c
rename to libz/fudge/cstring.c
diff --git a/lib/fudge/cstring.h b/libz/fudge/cstring.h
similarity index 100%
rename from lib/fudge/cstring.h
rename to libz/fudge/cstring.h
diff --git a/lib/fudge/ctrl.h b/libz/fudge/ctrl.h
similarity index 100%
rename from lib/fudge/ctrl.h
rename to libz/fudge/ctrl.h
diff --git a/lib/fudge/elf.c b/libz/fudge/elf.c
similarity index 100%
rename from lib/fudge/elf.c
rename to libz/fudge/elf.c
diff --git a/lib/fudge/elf.h b/libz/fudge/elf.h
similarity index 100%
rename from lib/fudge/elf.h
rename to libz/fudge/elf.h
diff --git a/lib/fudge/event.h b/libz/fudge/event.h
similarity index 100%
rename from lib/fudge/event.h
rename to libz/fudge/event.h
diff --git a/lib/fudge/file.h b/libz/fudge/file.h
similarity index 100%
rename from lib/fudge/file.h
rename to libz/fudge/file.h
diff --git a/lib/fudge/keys.c b/libz/fudge/keys.c
similarity index 100%
rename from lib/fudge/keys.c
rename to libz/fudge/keys.c
diff --git a/lib/fudge/keys.h b/libz/fudge/keys.h
similarity index 100%
rename from lib/fudge/keys.h
rename to libz/fudge/keys.h
diff --git a/lib/fudge/list.c b/libz/fudge/list.c
similarity index 100%
rename from lib/fudge/list.c
rename to libz/fudge/list.c
diff --git a/lib/fudge/list.h b/libz/fudge/list.h
similarity index 100%
rename from lib/fudge/list.h
rename to libz/fudge/list.h
diff --git a/lib/fudge/message.c b/libz/fudge/message.c
similarity index 100%
rename from lib/fudge/message.c
rename to libz/fudge/message.c
diff --git a/lib/fudge/message.h b/libz/fudge/message.h
similarity index 100%
rename from lib/fudge/message.h
rename to libz/fudge/message.h
diff --git a/lib/fudge/mtwist.c b/libz/fudge/mtwist.c
similarity index 100%
rename from lib/fudge/mtwist.c
rename to libz/fudge/mtwist.c
diff --git a/lib/fudge/mtwist.h b/libz/fudge/mtwist.h
similarity index 100%
rename from lib/fudge/mtwist.h
rename to libz/fudge/mtwist.h
diff --git a/lib/fudge/p9p.c b/libz/fudge/p9p.c
similarity index 100%
rename from lib/fudge/p9p.c
rename to libz/fudge/p9p.c
diff --git a/lib/fudge/p9p.h b/libz/fudge/p9p.h
similarity index 100%
rename from lib/fudge/p9p.h
rename to libz/fudge/p9p.h
diff --git a/lib/fudge/pcf.c b/libz/fudge/pcf.c
similarity index 100%
rename from lib/fudge/pcf.c
rename to libz/fudge/pcf.c
diff --git a/lib/fudge/pcf.h b/libz/fudge/pcf.h
similarity index 100%
rename from lib/fudge/pcf.h
rename to libz/fudge/pcf.h
diff --git a/lib/fudge/record.h b/libz/fudge/record.h
similarity index 100%
rename from lib/fudge/record.h
rename to libz/fudge/record.h
diff --git a/lib/fudge/regexp.c b/libz/fudge/regexp.c
similarity index 100%
rename from lib/fudge/regexp.c
rename to libz/fudge/regexp.c
diff --git a/lib/fudge/regexp.h b/libz/fudge/regexp.h
similarity index 100%
rename from lib/fudge/regexp.h
rename to libz/fudge/regexp.h
diff --git a/lib/fudge/ring.c b/libz/fudge/ring.c
similarity index 100%
rename from lib/fudge/ring.c
rename to libz/fudge/ring.c
diff --git a/lib/fudge/ring.h b/libz/fudge/ring.h
similarity index 100%
rename from lib/fudge/ring.h
rename to libz/fudge/ring.h
diff --git a/lib/fudge/riscv/atomic.c b/libz/fudge/riscv/atomic.c
similarity index 100%
rename from lib/fudge/riscv/atomic.c
rename to libz/fudge/riscv/atomic.c
diff --git a/lib/fudge/riscv/rules.mk b/libz/fudge/riscv/rules.mk
similarity index 100%
rename from lib/fudge/riscv/rules.mk
rename to libz/fudge/riscv/rules.mk
diff --git a/lib/fudge/rules.mk b/libz/fudge/rules.mk
similarity index 100%
rename from lib/fudge/rules.mk
rename to libz/fudge/rules.mk
diff --git a/lib/fudge/spinlock.c b/libz/fudge/spinlock.c
similarity index 100%
rename from lib/fudge/spinlock.c
rename to libz/fudge/spinlock.c
diff --git a/lib/fudge/spinlock.h b/libz/fudge/spinlock.h
similarity index 100%
rename from lib/fudge/spinlock.h
rename to libz/fudge/spinlock.h
diff --git a/lib/fudge/tar.c b/libz/fudge/tar.c
similarity index 100%
rename from lib/fudge/tar.c
rename to libz/fudge/tar.c
diff --git a/lib/fudge/tar.h b/libz/fudge/tar.h
similarity index 100%
rename from lib/fudge/tar.h
rename to libz/fudge/tar.h
diff --git a/lib/fudge/time.c b/libz/fudge/time.c
similarity index 100%
rename from lib/fudge/time.c
rename to libz/fudge/time.c
diff --git a/lib/fudge/time.h b/libz/fudge/time.h
similarity index 100%
rename from lib/fudge/time.h
rename to libz/fudge/time.h
diff --git a/lib/fudge/url.c b/libz/fudge/url.c
similarity index 100%
rename from lib/fudge/url.c
rename to libz/fudge/url.c
diff --git a/lib/fudge/url.h b/libz/fudge/url.h
similarity index 100%
rename from lib/fudge/url.h
rename to libz/fudge/url.h
diff --git a/lib/fudge/utf8.c b/libz/fudge/utf8.c
similarity index 100%
rename from lib/fudge/utf8.c
rename to libz/fudge/utf8.c
diff --git a/lib/fudge/utf8.h b/libz/fudge/utf8.h
similarity index 100%
rename from lib/fudge/utf8.h
rename to libz/fudge/utf8.h
diff --git a/lib/fudge/x86/atomic.s b/libz/fudge/x86/atomic.s
similarity index 100%
rename from lib/fudge/x86/atomic.s
rename to libz/fudge/x86/atomic.s
diff --git a/lib/fudge/x86/rules.mk b/libz/fudge/x86/rules.mk
similarity index 100%
rename from lib/fudge/x86/rules.mk
rename to libz/fudge/x86/rules.mk
diff --git a/lib/hash/crc.c b/libz/hash/crc.c
similarity index 100%
rename from lib/hash/crc.c
rename to libz/hash/crc.c
diff --git a/lib/hash/crc.h b/libz/hash/crc.h
similarity index 100%
rename from lib/hash/crc.h
rename to libz/hash/crc.h
diff --git a/lib/hash/md5.c b/libz/hash/md5.c
similarity index 100%
rename from lib/hash/md5.c
rename to libz/hash/md5.c
diff --git a/lib/hash/md5.h b/libz/hash/md5.h
similarity index 100%
rename from lib/hash/md5.h
rename to libz/hash/md5.h
diff --git a/lib/hash/rules.mk b/libz/hash/rules.mk
similarity index 100%
rename from lib/hash/rules.mk
rename to libz/hash/rules.mk
diff --git a/lib/hash/sha1.c b/libz/hash/sha1.c
similarity index 100%
rename from lib/hash/sha1.c
rename to libz/hash/sha1.c
diff --git a/lib/hash/sha1.h b/libz/hash/sha1.h
similarity index 100%
rename from lib/hash/sha1.h
rename to libz/hash/sha1.h
diff --git a/lib/image/pcx.c b/libz/image/pcx.c
similarity index 100%
rename from lib/image/pcx.c
rename to libz/image/pcx.c
diff --git a/lib/image/pcx.h b/libz/image/pcx.h
similarity index 100%
rename from lib/image/pcx.h
rename to libz/image/pcx.h
diff --git a/lib/image/rules.mk b/libz/image/rules.mk
similarity index 100%
rename from lib/image/rules.mk
rename to libz/image/rules.mk
diff --git a/lib/math/math.c b/libz/math/math.c
similarity index 100%
rename from lib/math/math.c
rename to libz/math/math.c
diff --git a/lib/math/math.h b/libz/math/math.h
similarity index 100%
rename from lib/math/math.h
rename to libz/math/math.h
diff --git a/lib/math/rules.mk b/libz/math/rules.mk
similarity index 100%
rename from lib/math/rules.mk
rename to libz/math/rules.mk
diff --git a/lib/net/arp.c b/libz/net/arp.c
similarity index 100%
rename from lib/net/arp.c
rename to libz/net/arp.c
diff --git a/lib/net/arp.h b/libz/net/arp.h
similarity index 100%
rename from lib/net/arp.h
rename to libz/net/arp.h
diff --git a/lib/net/dns.c b/libz/net/dns.c
similarity index 100%
rename from lib/net/dns.c
rename to libz/net/dns.c
diff --git a/lib/net/dns.h b/libz/net/dns.h
similarity index 100%
rename from lib/net/dns.h
rename to libz/net/dns.h
diff --git a/lib/net/ethernet.c b/libz/net/ethernet.c
similarity index 100%
rename from lib/net/ethernet.c
rename to libz/net/ethernet.c
diff --git a/lib/net/ethernet.h b/libz/net/ethernet.h
similarity index 100%
rename from lib/net/ethernet.h
rename to libz/net/ethernet.h
diff --git a/lib/net/icmp.c b/libz/net/icmp.c
similarity index 100%
rename from lib/net/icmp.c
rename to libz/net/icmp.c
diff --git a/lib/net/icmp.h b/libz/net/icmp.h
similarity index 100%
rename from lib/net/icmp.h
rename to libz/net/icmp.h
diff --git a/lib/net/ipv4.c b/libz/net/ipv4.c
similarity index 100%
rename from lib/net/ipv4.c
rename to libz/net/ipv4.c
diff --git a/lib/net/ipv4.h b/libz/net/ipv4.h
similarity index 100%
rename from lib/net/ipv4.h
rename to libz/net/ipv4.h
diff --git a/lib/net/ipv6.h b/libz/net/ipv6.h
similarity index 100%
rename from lib/net/ipv6.h
rename to libz/net/ipv6.h
diff --git a/lib/net/net.c b/libz/net/net.c
similarity index 100%
rename from lib/net/net.c
rename to libz/net/net.c
diff --git a/lib/net/net.h b/libz/net/net.h
similarity index 100%
rename from lib/net/net.h
rename to libz/net/net.h
diff --git a/lib/net/rules.mk b/libz/net/rules.mk
similarity index 100%
rename from lib/net/rules.mk
rename to libz/net/rules.mk
diff --git a/lib/net/tcp.c b/libz/net/tcp.c
similarity index 100%
rename from lib/net/tcp.c
rename to libz/net/tcp.c
diff --git a/lib/net/tcp.h b/libz/net/tcp.h
similarity index 100%
rename from lib/net/tcp.h
rename to libz/net/tcp.h
diff --git a/lib/net/udp.c b/libz/net/udp.c
similarity index 100%
rename from lib/net/udp.c
rename to libz/net/udp.c
diff --git a/lib/net/udp.h b/libz/net/udp.h
similarity index 100%
rename from lib/net/udp.h
rename to libz/net/udp.h
diff --git a/lib/rules.mk b/libz/rules.mk
similarity index 100%
rename from lib/rules.mk
rename to libz/rules.mk
diff --git a/lib/socket/rules.mk b/libz/socket/rules.mk
similarity index 100%
rename from lib/socket/rules.mk
rename to libz/socket/rules.mk
diff --git a/lib/socket/socket.c b/libz/socket/socket.c
similarity index 100%
rename from lib/socket/socket.c
rename to libz/socket/socket.c
diff --git a/lib/socket/socket.h b/libz/socket/socket.h
similarity index 100%
rename from lib/socket/socket.h
rename to libz/socket/socket.h
diff --git a/lib/tcc/rules.mk b/libz/tcc/rules.mk
similarity index 100%
rename from lib/tcc/rules.mk
rename to libz/tcc/rules.mk
diff --git a/lib/tcc/tcc.c b/libz/tcc/tcc.c
similarity index 100%
rename from lib/tcc/tcc.c
rename to libz/tcc/tcc.c
diff --git a/lib/tcc/tcc.h b/libz/tcc/tcc.h
similarity index 100%
rename from lib/tcc/tcc.h
rename to libz/tcc/tcc.h
-- 
2.43.0

