From 95b3935fbccf77dba4be898c13bc08dc8220294c Mon Sep 17 00:00:00 2001
From: Heisenberg <alimirmohammad.1386@gmail.com>
Date: Mon, 8 Apr 2024 23:02:59 -0400
Subject: [PATCH 435/493] Minor patch

---
 drivers/usb3/core.c             |   2 +-
 drivers/usb3/driver_cdc.c       |  19 +-
 drivers/usb3/io.c               |   2 +-
 lib/include/list.h              | 899 ++++++++++++++++----------------
 lib/include/machine/endian.h    |   2 +-
 lib/include/stdio.h             | 439 ++++++++++++++++
 lib/include/string.h            |   2 +-
 lib/include/sys/_types.h        |   4 +-
 lib/include/sys/types.h         |   2 +-
 lib/include/types.h             |  19 +-
 libdrive/include/libusbserial.h |   2 +-
 libdrive/include/libusbtypes.h  |   6 +-
 12 files changed, 927 insertions(+), 471 deletions(-)
 create mode 100644 lib/include/stdio.h

diff --git a/drivers/usb3/core.c b/drivers/usb3/core.c
index 5ad0037..bdb92ad 100644
--- a/drivers/usb3/core.c
+++ b/drivers/usb3/core.c
@@ -58,7 +58,7 @@ static const struct usbserial_driver* find_driver_for_usb_device(uint16_t vid,ui
 
 }
 
-int usbserial_is_device_supported(uint8_t vid,uint16_t pid,uint8_t class,uint8_t subclass){
+int usbserial_is_device_supported(uint16_t vid, uint16_t pid, uint8_t class, uint8_t subclass){
     return !!find_driver_for_usb_device(vid, pid, class, subclass);
 }
 
diff --git a/drivers/usb3/driver_cdc.c b/drivers/usb3/driver_cdc.c
index 6f0f2ca..de98997 100644
--- a/drivers/usb3/driver_cdc.c
+++ b/drivers/usb3/driver_cdc.c
@@ -21,10 +21,13 @@
 #include <assert.h>
 #include <stdlib.h>
 #include <string.h>
-#include <sys/_endian.h>
+// #include <sys/_endian.h>
 
 #include <config.h>
 
+#include <libusbserial.h>
+
+
 
 /**
  * @brief Let's define some useful macros for the  CDC driver.
@@ -144,7 +147,7 @@ static int cdc_port_set_config(struct usbserial_port *port, const struct usbseri
     unsigned char stop_bits_byte, parity_byte, data_bits_byte;
     uint32_t baud_le = htole32((uint32_t)config->baud);
 
-    switch (config->stop_bits)
+    switch (config->stopbits)
     {
     case USBSERIAL_STOPBITS_1: stop_bits_byte = 0; break;
     case USBSERIAL_STOPBITS_1_5: stop_bits_byte = 1; break;
@@ -155,16 +158,16 @@ static int cdc_port_set_config(struct usbserial_port *port, const struct usbseri
 
     switch (config->parity)
     {
-    case USBSERIAL_PARITY_NONE: parity_byte = 0; break;
-    case USBSERIAL_PARITY_ODD: parity_byte = 1; break;
-    case USBSERIAL_PARITY_EVEN: parity_byte = 2; break;
-    case USBSERIAL_PARITY_MARK: parity_byte = 3; break;
-    case USBSERIAL_PARITY_SPACE: parity_byte = 4; break;
+    case USB_SERIAL_PARITY_NONE: parity_byte = 0; break;
+    case USB_PARITY_ODD: parity_byte = 1; break;
+    case USB_PARITY_EVEN: parity_byte = 2; break;
+    case USB_PARITY_MARK: parity_byte = 3; break;
+    case USB_PARITY_SPACE: parity_byte = 4; break;
 
     default: return USBSERIAL_ERROR_INVALID_PARAMETER;
     }
 
-    data_bits_byte = (unsigned char) config->data_bits;
+    data_bits_byte = (unsigned char) config->databits;
 
     memcpy(data, &baud_le, sizeof(baud_le));
     data[4] = stop_bits_byte;
diff --git a/drivers/usb3/io.c b/drivers/usb3/io.c
index 17156b5..8cbdcb5 100644
--- a/drivers/usb3/io.c
+++ b/drivers/usb3/io.c
@@ -20,7 +20,7 @@
 #include <driver.h>
 
 #include <assert.h>
-#include <stdio.h>
+// #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 
diff --git a/lib/include/list.h b/lib/include/list.h
index 5206d7c..09374bf 100644
--- a/lib/include/list.h
+++ b/lib/include/list.h
@@ -1,7 +1,6 @@
 #ifndef __HEISEN_KERNEL_COMMON_FILES__COMMON__LIST_H
 #define __HEISEN_KERNEL_COMMON_FILES__COMMON__LIST_H
 
-#if  defined(__cplusplus)
 namespace LIBHeisenKernel
 {
     template <typename T>
@@ -202,454 +201,454 @@ void List<T>::operator-=(const T &e)
     Remove(e);
 }
 
-#else 
-#define __GLIBC_INTERNAL_STARTING_HEADER_IMPLEMENTATION
-#include <bits/libc-header-start.h>
-__BEGIN_DECLS
-/* Get size_t and NULL from <stddef.h>.  */
-#define        __need_size_t
-#define        __need_NULL
-#include <stddef.h>
-/* Tell the caller that we provide correct C++ prototypes.  */
-#if defined __cplusplus && (__GNUC_PREREQ (4, 4) \
-                            || __glibc_clang_prereq (3, 5))
-# define __CORRECT_ISO_CPP_STRING_H_PROTO
-#endif
-/* Copy N bytes of SRC to DEST.  */
-extern void *memcpy (void *__restrict __dest, const void *__restrict __src,
-                     size_t __n) __THROW __nonnull ((1, 2));
-/* Copy N bytes of SRC to DEST, guaranteeing
-   correct behavior for overlapping strings.  */
-extern void *memmove (void *__dest, const void *__src, size_t __n)
-     __THROW __nonnull ((1, 2));
-/* Copy no more than N bytes of SRC to DEST, stopping when C is found.
-   Return the position in DEST one byte past where C was copied,
-   or NULL if C was not found in the first N bytes of SRC.  */
-#if defined __USE_MISC || defined __USE_XOPEN || __GLIBC_USE (ISOC2X)
-extern void *memccpy (void *__restrict __dest, const void *__restrict __src,
-                      int __c, size_t __n)
-    __THROW __nonnull ((1, 2)) __attr_access ((__write_only__, 1, 4));
-#endif /* Misc || X/Open.  */
-/* Set N bytes of S to C.  */
-extern void *memset (void *__s, int __c, size_t __n) __THROW __nonnull ((1));
-/* Compare N bytes of S1 and S2.  */
-extern int memcmp (const void *__s1, const void *__s2, size_t __n)
-     __THROW __attribute_pure__ __nonnull ((1, 2));
-/* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
-   Return some non-zero value otherwise.
-   Essentially __memcmpeq has the exact same semantics as memcmp
-   except the return value is less constrained.  memcmp is always a
-   correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
-   or bcmp are correct implementations.
-   __memcmpeq is meant to be used by compilers when memcmp return is
-   only used for its bolean value.
-   __memcmpeq is declared only for use by compilers.  Programs should
-   continue to use memcmp.  */
-extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
-     __THROW __attribute_pure__ __nonnull ((1, 2));
-/* Search N bytes of S for C.  */
-#ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
-extern "C++"
-{
-extern void *memchr (void *__s, int __c, size_t __n)
-      __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
-extern const void *memchr (const void *__s, int __c, size_t __n)
-      __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
-# ifdef __OPTIMIZE__
-__extern_always_inline void *
-memchr (void *__s, int __c, size_t __n) __THROW
-{
-  return __builtin_memchr (__s, __c, __n);
-}
-__extern_always_inline const void *
-memchr (const void *__s, int __c, size_t __n) __THROW
-{
-  return __builtin_memchr (__s, __c, __n);
-}
-# endif
-}
-#else
-extern void *memchr (const void *__s, int __c, size_t __n)
-      __THROW __attribute_pure__ __nonnull ((1));
-#endif
-#ifdef __USE_GNU
-/* Search in S for C.  This is similar to `memchr' but there is no
-   length limit.  */
-# ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
-extern "C++" void *rawmemchr (void *__s, int __c)
-     __THROW __asm ("rawmemchr") __attribute_pure__ __nonnull ((1));
-extern "C++" const void *rawmemchr (const void *__s, int __c)
-     __THROW __asm ("rawmemchr") __attribute_pure__ __nonnull ((1));
-# else
-extern void *rawmemchr (const void *__s, int __c)
-     __THROW __attribute_pure__ __nonnull ((1));
-# endif
-/* Search N bytes of S for the final occurrence of C.  */
-# ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
-extern "C++" void *memrchr (void *__s, int __c, size_t __n)
-      __THROW __asm ("memrchr") __attribute_pure__ __nonnull ((1))
-      __attr_access ((__read_only__, 1, 3));
-extern "C++" const void *memrchr (const void *__s, int __c, size_t __n)
-      __THROW __asm ("memrchr") __attribute_pure__ __nonnull ((1))
-      __attr_access ((__read_only__, 1, 3));
-# else
-extern void *memrchr (const void *__s, int __c, size_t __n)
-      __THROW __attribute_pure__ __nonnull ((1))
-      __attr_access ((__read_only__, 1, 3));
-# endif
-#endif
-/* Copy SRC to DEST.  */
-extern char *strcpy (char *__restrict __dest, const char *__restrict __src)
-     __THROW __nonnull ((1, 2));
-/* Copy no more than N characters of SRC to DEST.  */
-extern char *strncpy (char *__restrict __dest,
-                      const char *__restrict __src, size_t __n)
-     __THROW __nonnull ((1, 2));
-/* Append SRC onto DEST.  */
-extern char *strcat (char *__restrict __dest, const char *__restrict __src)
-     __THROW __nonnull ((1, 2));
-/* Append no more than N characters from SRC onto DEST.  */
-extern char *strncat (char *__restrict __dest, const char *__restrict __src,
-                      size_t __n) __THROW __nonnull ((1, 2));
-/* Compare S1 and S2.  */
-extern int strcmp (const char *__s1, const char *__s2)
-     __THROW __attribute_pure__ __nonnull ((1, 2));
-/* Compare N characters of S1 and S2.  */
-extern int strncmp (const char *__s1, const char *__s2, size_t __n)
-     __THROW __attribute_pure__ __nonnull ((1, 2));
-/* Compare the collated forms of S1 and S2.  */
-extern int strcoll (const char *__s1, const char *__s2)
-     __THROW __attribute_pure__ __nonnull ((1, 2));
-/* Put a transformation of SRC into no more than N bytes of DEST.  */
-extern size_t strxfrm (char *__restrict __dest,
-                       const char *__restrict __src, size_t __n)
-    __THROW __nonnull ((2)) __attr_access ((__write_only__, 1, 3));
-#ifdef __USE_XOPEN2K8
-/* POSIX.1-2008 extended locale interface (see locale.h).  */
-// # include <bits/types/locale_t.h>
-/* Compare the collated forms of S1 and S2, using sorting rules from L.  */
-extern int strcoll_l (const char *__s1, const char *__s2, locale_t __l)
-     __THROW __attribute_pure__ __nonnull ((1, 2, 3));
-/* Put a transformation of SRC into no more than N bytes of DEST,
-   using sorting rules from L.  */
-extern size_t strxfrm_l (char *__dest, const char *__src, size_t __n,
-                         locale_t __l) __THROW __nonnull ((2, 4))
-     __attr_access ((__write_only__, 1, 3));
-#endif
-#if (defined __USE_XOPEN_EXTENDED || defined __USE_XOPEN2K8        \
-     || __GLIBC_USE (LIB_EXT2) || __GLIBC_USE (ISOC2X))
-/* Duplicate S, returning an identical malloc'd string.  */
-extern char *strdup (const char *__s)
-     __THROW __attribute_malloc__ __nonnull ((1));
-#endif
-/* Return a malloc'd copy of at most N bytes of STRING.  The
-   resultant string is terminated even if no null terminator
-   appears before STRING[N].  */
-#if defined __USE_XOPEN2K8 || __GLIBC_USE (LIB_EXT2) || __GLIBC_USE (ISOC2X)
-extern char *strndup (const char *__string, size_t __n)
-     __THROW __attribute_malloc__ __nonnull ((1));
-#endif
-#if defined __USE_GNU && defined __GNUC__
-/* Duplicate S, returning an identical alloca'd string.  */
-# define strdupa(s)                                                              \
-  (__extension__                                                              \
-    ({                                                                              \
-      const char *__old = (s);                                                      \
-      size_t __len = strlen (__old) + 1;                                      \
-      char *__new = (char *) __builtin_alloca (__len);                              \
-      (char *) memcpy (__new, __old, __len);                                      \
-    }))
-/* Return an alloca'd copy of at most N bytes of string.  */
-# define strndupa(s, n)                                                              \
-  (__extension__                                                              \
-    ({                                                                              \
-      const char *__old = (s);                                                      \
-      size_t __len = strnlen (__old, (n));                                      \
-      char *__new = (char *) __builtin_alloca (__len + 1);                      \
-      __new[__len] = '\0';                                                      \
-      (char *) memcpy (__new, __old, __len);                                      \
-    }))
-#endif
-/* Find the first occurrence of C in S.  */
-#ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
-extern "C++"
-{
-extern char *strchr (char *__s, int __c)
-     __THROW __asm ("strchr") __attribute_pure__ __nonnull ((1));
-extern const char *strchr (const char *__s, int __c)
-     __THROW __asm ("strchr") __attribute_pure__ __nonnull ((1));
-# ifdef __OPTIMIZE__
-__extern_always_inline char *
-strchr (char *__s, int __c) __THROW
-{
-  return __builtin_strchr (__s, __c);
-}
-__extern_always_inline const char *
-strchr (const char *__s, int __c) __THROW
-{
-  return __builtin_strchr (__s, __c);
-}
-# endif
-}
-#else
-extern char *strchr (const char *__s, int __c)
-     __THROW __attribute_pure__ __nonnull ((1));
-#endif
-/* Find the last occurrence of C in S.  */
-#ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
-extern "C++"
-{
-extern char *strrchr (char *__s, int __c)
-     __THROW __asm ("strrchr") __attribute_pure__ __nonnull ((1));
-extern const char *strrchr (const char *__s, int __c)
-     __THROW __asm ("strrchr") __attribute_pure__ __nonnull ((1));
-# ifdef __OPTIMIZE__
-__extern_always_inline char *
-strrchr (char *__s, int __c) __THROW
-{
-  return __builtin_strrchr (__s, __c);
-}
-__extern_always_inline const char *
-strrchr (const char *__s, int __c) __THROW
-{
-  return __builtin_strrchr (__s, __c);
-}
-# endif
-}
-#else
-extern char *strrchr (const char *__s, int __c)
-     __THROW __attribute_pure__ __nonnull ((1));
-#endif
-#ifdef __USE_GNU
-/* This function is similar to `strchr'.  But it returns a pointer to
-   the closing NUL byte in case C is not found in S.  */
-# ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
-extern "C++" char *strchrnul (char *__s, int __c)
-     __THROW __asm ("strchrnul") __attribute_pure__ __nonnull ((1));
-extern "C++" const char *strchrnul (const char *__s, int __c)
-     __THROW __asm ("strchrnul") __attribute_pure__ __nonnull ((1));
-# else
-extern char *strchrnul (const char *__s, int __c)
-     __THROW __attribute_pure__ __nonnull ((1));
-# endif
-#endif
-/* Return the length of the initial segment of S which
-   consists entirely of characters not in REJECT.  */
-extern size_t strcspn (const char *__s, const char *__reject)
-     __THROW __attribute_pure__ __nonnull ((1, 2));
-/* Return the length of the initial segment of S which
-   consists entirely of characters in ACCEPT.  */
-extern size_t strspn (const char *__s, const char *__accept)
-     __THROW __attribute_pure__ __nonnull ((1, 2));
-/* Find the first occurrence in S of any character in ACCEPT.  */
-#ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
-extern "C++"
-{
-extern char *strpbrk (char *__s, const char *__accept)
-     __THROW __asm ("strpbrk") __attribute_pure__ __nonnull ((1, 2));
-extern const char *strpbrk (const char *__s, const char *__accept)
-     __THROW __asm ("strpbrk") __attribute_pure__ __nonnull ((1, 2));
-# ifdef __OPTIMIZE__
-__extern_always_inline char *
-strpbrk (char *__s, const char *__accept) __THROW
-{
-  return __builtin_strpbrk (__s, __accept);
-}
-__extern_always_inline const char *
-strpbrk (const char *__s, const char *__accept) __THROW
-{
-  return __builtin_strpbrk (__s, __accept);
-}
-# endif
-}
-#else
-extern char *strpbrk (const char *__s, const char *__accept)
-     __THROW __attribute_pure__ __nonnull ((1, 2));
-#endif
-/* Find the first occurrence of NEEDLE in HAYSTACK.  */
-#ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
-extern "C++"
-{
-extern char *strstr (char *__haystack, const char *__needle)
-     __THROW __asm ("strstr") __attribute_pure__ __nonnull ((1, 2));
-extern const char *strstr (const char *__haystack, const char *__needle)
-     __THROW __asm ("strstr") __attribute_pure__ __nonnull ((1, 2));
-# ifdef __OPTIMIZE__
-__extern_always_inline char *
-strstr (char *__haystack, const char *__needle) __THROW
-{
-  return __builtin_strstr (__haystack, __needle);
-}
-__extern_always_inline const char *
-strstr (const char *__haystack, const char *__needle) __THROW
-{
-  return __builtin_strstr (__haystack, __needle);
-}
-# endif
-}
-#else
-extern char *strstr (const char *__haystack, const char *__needle)
-     __THROW __attribute_pure__ __nonnull ((1, 2));
-#endif
-/* Divide S into tokens separated by characters in DELIM.  */
-extern char *strtok (char *__restrict __s, const char *__restrict __delim)
-     __THROW __nonnull ((2));
-/* Divide S into tokens separated by characters in DELIM.  Information
-   passed between calls are stored in SAVE_PTR.  */
-extern char *__strtok_r (char *__restrict __s,
-                         const char *__restrict __delim,
-                         char **__restrict __save_ptr)
-     __THROW __nonnull ((2, 3));
-#ifdef __USE_POSIX
-extern char *strtok_r (char *__restrict __s, const char *__restrict __delim,
-                       char **__restrict __save_ptr)
-     __THROW __nonnull ((2, 3));
-#endif
-#ifdef __USE_GNU
-/* Similar to `strstr' but this function ignores the case of both strings.  */
-# ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
-extern "C++" char *strcasestr (char *__haystack, const char *__needle)
-     __THROW __asm ("strcasestr") __attribute_pure__ __nonnull ((1, 2));
-extern "C++" const char *strcasestr (const char *__haystack,
-                                     const char *__needle)
-     __THROW __asm ("strcasestr") __attribute_pure__ __nonnull ((1, 2));
-# else
-extern char *strcasestr (const char *__haystack, const char *__needle)
-     __THROW __attribute_pure__ __nonnull ((1, 2));
-# endif
-#endif
-#ifdef __USE_GNU
-/* Find the first occurrence of NEEDLE in HAYSTACK.
-   NEEDLE is NEEDLELEN bytes long;
-   HAYSTACK is HAYSTACKLEN bytes long.  */
-extern void *memmem (const void *__haystack, size_t __haystacklen,
-                     const void *__needle, size_t __needlelen)
-     __THROW __attribute_pure__ __nonnull ((1, 3))
-    __attr_access ((__read_only__, 1, 2))
-    __attr_access ((__read_only__, 3, 4));
-/* Copy N bytes of SRC to DEST, return pointer to bytes after the
-   last written byte.  */
-extern void *__mempcpy (void *__restrict __dest,
-                        const void *__restrict __src, size_t __n)
-     __THROW __nonnull ((1, 2));
-extern void *mempcpy (void *__restrict __dest,
-                      const void *__restrict __src, size_t __n)
-     __THROW __nonnull ((1, 2));
-#endif
-/* Return the length of S.  */
-extern size_t strlen (const char *__s)
-     __THROW __attribute_pure__ __nonnull ((1));
-#ifdef        __USE_XOPEN2K8
-/* Find the length of STRING, but scan at most MAXLEN characters.
-   If no '\0' terminator is found in that many characters, return MAXLEN.  */
-extern size_t strnlen (const char *__string, size_t __maxlen)
-     __THROW __attribute_pure__ __nonnull ((1));
-#endif
-/* Return a string describing the meaning of the `errno' code in ERRNUM.  */
-extern char *strerror (int __errnum) __THROW;
-#ifdef __USE_XOPEN2K
-/* Reentrant version of `strerror'.
-   There are 2 flavors of `strerror_r', GNU which returns the string
-   and may or may not use the supplied temporary buffer and POSIX one
-   which fills the string into the buffer.
-   To use the POSIX version, -D_XOPEN_SOURCE=600 or -D_POSIX_C_SOURCE=200112L
-   without -D_GNU_SOURCE is needed, otherwise the GNU version is
-   preferred.  */
-# if defined __USE_XOPEN2K && !defined __USE_GNU
-/* Fill BUF with a string describing the meaning of the `errno' code in
-   ERRNUM.  */
-#  ifdef __REDIRECT_NTH
-extern int __REDIRECT_NTH (strerror_r,
-                           (int __errnum, char *__buf, size_t __buflen),
-                           __xpg_strerror_r) __nonnull ((2))
-    __attr_access ((__write_only__, 2, 3));
-#  else
-extern int __xpg_strerror_r (int __errnum, char *__buf, size_t __buflen)
-     __THROW __nonnull ((2)) __attr_access ((__write_only__, 2, 3));
-#   define strerror_r __xpg_strerror_r
-#  endif
-# else
-/* If a temporary buffer is required, at most BUFLEN bytes of BUF will be
-   used.  */
-extern char *strerror_r (int __errnum, char *__buf, size_t __buflen)
-     __THROW __nonnull ((2)) __wur  __attr_access ((__write_only__, 2, 3));
-# endif
-# ifdef __USE_GNU
-/* Return a string describing the meaning of tthe error in ERR.  */
-extern const char *strerrordesc_np (int __err) __THROW;
-/* Return a string with the error name in ERR.  */
-extern const char *strerrorname_np (int __err) __THROW;
-# endif
-#endif
-#ifdef __USE_XOPEN2K8
-/* Translate error number to string according to the locale L.  */
-extern char *strerror_l (int __errnum, locale_t __l) __THROW;
-#endif
-#ifdef __USE_MISC
-// # include <strings.h>
-/* Set N bytes of S to 0.  The compiler will not delete a call to this
-   function, even if S is dead after the call.  */
-extern void explicit_bzero (void *__s, size_t __n) __THROW __nonnull ((1))
-    __fortified_attr_access (__write_only__, 1, 2);
-/* Return the next DELIM-delimited token from *STRINGP,
-   terminating it with a '\0', and update *STRINGP to point past it.  */
-extern char *strsep (char **__restrict __stringp,
-                     const char *__restrict __delim)
-     __THROW __nonnull ((1, 2));
-#endif
-#ifdef        __USE_XOPEN2K8
-/* Return a string describing the meaning of the signal number in SIG.  */
-extern char *strsignal (int __sig) __THROW;
-# ifdef __USE_GNU
-/* Return an abbreviation string for the signal number SIG.  */
-extern const char *sigabbrev_np (int __sig) __THROW;
-/* Return a string describing the meaning of the signal number in SIG,
-   the result is not translated.  */
-extern const char *sigdescr_np (int __sig) __THROW;
-# endif
-/* Copy SRC to DEST, returning the address of the terminating '\0' in DEST.  */
-extern char *__stpcpy (char *__restrict __dest, const char *__restrict __src)
-     __THROW __nonnull ((1, 2));
-extern char *stpcpy (char *__restrict __dest, const char *__restrict __src)
-     __THROW __nonnull ((1, 2));
-/* Copy no more than N characters of SRC to DEST, returning the address of
-   the last character written into DEST.  */
-extern char *__stpncpy (char *__restrict __dest,
-                        const char *__restrict __src, size_t __n)
-     __THROW __nonnull ((1, 2));
-extern char *stpncpy (char *__restrict __dest,
-                      const char *__restrict __src, size_t __n)
-     __THROW __nonnull ((1, 2));
-#endif
-#ifdef        __USE_GNU
-/* Compare S1 and S2 as strings holding name & indices/version numbers.  */
-extern int strverscmp (const char *__s1, const char *__s2)
-     __THROW __attribute_pure__ __nonnull ((1, 2));
-/* Sautee STRING briskly.  */
-extern char *strfry (char *__string) __THROW __nonnull ((1));
-/* Frobnicate N bytes of S.  */
-extern void *memfrob (void *__s, size_t __n) __THROW __nonnull ((1))
-    __attr_access ((__read_write__, 1, 2));
-# ifndef basename
-/* Return the file name within directory of FILENAME.  We don't
-   declare the function if the `basename' macro is available (defined
-   in <libgen.h>) which makes the XPG version of this function
-   available.  */
-#  ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
-extern "C++" char *basename (char *__filename)
-     __THROW __asm ("basename") __nonnull ((1));
-extern "C++" const char *basename (const char *__filename)
-     __THROW __asm ("basename") __nonnull ((1));
-#  else
-extern char *basename (const char *__filename) __THROW __nonnull ((1));
-#  endif
-# endif
-#endif
-#if __GNUC_PREREQ (3,4)
-# if __USE_FORTIFY_LEVEL > 0 && defined __fortify_function
-/* Functions with security checks.  */
-#  include <bits/string_fortified.h>
-# endif
-__END_DECLS
+
+// #define __GLIBC_INTERNAL_STARTING_HEADER_IMPLEMENTATION
+// #include <bits/libc-header-start.h>
+// __BEGIN_DECLS
+// /* Get size_t and NULL from <stddef.h>.  */
+// #define        __need_size_t
+// #define        __need_NULL
+// #include <stddef.h>
+// /* Tell the caller that we provide correct C++ prototypes.  */
+// #if defined __cplusplus && (__GNUC_PREREQ (4, 4) \
+//                             || __glibc_clang_prereq (3, 5))
+// # define __CORRECT_ISO_CPP_STRING_H_PROTO
+// #endif
+// /* Copy N bytes of SRC to DEST.  */
+// extern void *memcpy (void *__restrict __dest, const void *__restrict __src,
+//                      size_t __n) __THROW __nonnull ((1, 2));
+// /* Copy N bytes of SRC to DEST, guaranteeing
+//    correct behavior for overlapping strings.  */
+// extern void *memmove (void *__dest, const void *__src, size_t __n)
+//      __THROW __nonnull ((1, 2));
+// /* Copy no more than N bytes of SRC to DEST, stopping when C is found.
+//    Return the position in DEST one byte past where C was copied,
+//    or NULL if C was not found in the first N bytes of SRC.  */
+// #if defined __USE_MISC || defined __USE_XOPEN || __GLIBC_USE (ISOC2X)
+// extern void *memccpy (void *__restrict __dest, const void *__restrict __src,
+//                       int __c, size_t __n)
+//     __THROW __nonnull ((1, 2)) __attr_access ((__write_only__, 1, 4));
+// #endif /* Misc || X/Open.  */
+// /* Set N bytes of S to C.  */
+// extern void *memset (void *__s, int __c, size_t __n) __THROW __nonnull ((1));
+// /* Compare N bytes of S1 and S2.  */
+// extern int memcmp (const void *__s1, const void *__s2, size_t __n)
+//      __THROW __attribute_pure__ __nonnull ((1, 2));
+// /* Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.
+//    Return some non-zero value otherwise.
+//    Essentially __memcmpeq has the exact same semantics as memcmp
+//    except the return value is less constrained.  memcmp is always a
+//    correct implementation of __memcmpeq.  As well !!memcmp, -memcmp,
+//    or bcmp are correct implementations.
+//    __memcmpeq is meant to be used by compilers when memcmp return is
+//    only used for its bolean value.
+//    __memcmpeq is declared only for use by compilers.  Programs should
+//    continue to use memcmp.  */
+// extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
+//      __THROW __attribute_pure__ __nonnull ((1, 2));
+// /* Search N bytes of S for C.  */
+// #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
+// extern "C++"
+// {
+// extern void *memchr (void *__s, int __c, size_t __n)
+//       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
+// extern const void *memchr (const void *__s, int __c, size_t __n)
+//       __THROW __asm ("memchr") __attribute_pure__ __nonnull ((1));
+// # ifdef __OPTIMIZE__
+// __extern_always_inline void *
+// memchr (void *__s, int __c, size_t __n) __THROW
+// {
+//   return __builtin_memchr (__s, __c, __n);
+// }
+// __extern_always_inline const void *
+// memchr (const void *__s, int __c, size_t __n) __THROW
+// {
+//   return __builtin_memchr (__s, __c, __n);
+// }
+// # endif
+// }
+// #else
+// extern void *memchr (const void *__s, int __c, size_t __n)
+//       __THROW __attribute_pure__ __nonnull ((1));
+// #endif
+// #ifdef __USE_GNU
+// /* Search in S for C.  This is similar to `memchr' but there is no
+//    length limit.  */
+// # ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
+// extern "C++" void *rawmemchr (void *__s, int __c)
+//      __THROW __asm ("rawmemchr") __attribute_pure__ __nonnull ((1));
+// extern "C++" const void *rawmemchr (const void *__s, int __c)
+//      __THROW __asm ("rawmemchr") __attribute_pure__ __nonnull ((1));
+// # else
+// extern void *rawmemchr (const void *__s, int __c)
+//      __THROW __attribute_pure__ __nonnull ((1));
+// # endif
+// /* Search N bytes of S for the final occurrence of C.  */
+// # ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
+// extern "C++" void *memrchr (void *__s, int __c, size_t __n)
+//       __THROW __asm ("memrchr") __attribute_pure__ __nonnull ((1))
+//       __attr_access ((__read_only__, 1, 3));
+// extern "C++" const void *memrchr (const void *__s, int __c, size_t __n)
+//       __THROW __asm ("memrchr") __attribute_pure__ __nonnull ((1))
+//       __attr_access ((__read_only__, 1, 3));
+// # else
+// extern void *memrchr (const void *__s, int __c, size_t __n)
+//       __THROW __attribute_pure__ __nonnull ((1))
+//       __attr_access ((__read_only__, 1, 3));
+// # endif
+// #endif
+// /* Copy SRC to DEST.  */
+// extern char *strcpy (char *__restrict __dest, const char *__restrict __src)
+//      __THROW __nonnull ((1, 2));
+// /* Copy no more than N characters of SRC to DEST.  */
+// extern char *strncpy (char *__restrict __dest,
+//                       const char *__restrict __src, size_t __n)
+//      __THROW __nonnull ((1, 2));
+// /* Append SRC onto DEST.  */
+// extern char *strcat (char *__restrict __dest, const char *__restrict __src)
+//      __THROW __nonnull ((1, 2));
+// /* Append no more than N characters from SRC onto DEST.  */
+// extern char *strncat (char *__restrict __dest, const char *__restrict __src,
+//                       size_t __n) __THROW __nonnull ((1, 2));
+// /* Compare S1 and S2.  */
+// extern int strcmp (const char *__s1, const char *__s2)
+//      __THROW __attribute_pure__ __nonnull ((1, 2));
+// /* Compare N characters of S1 and S2.  */
+// extern int strncmp (const char *__s1, const char *__s2, size_t __n)
+//      __THROW __attribute_pure__ __nonnull ((1, 2));
+// /* Compare the collated forms of S1 and S2.  */
+// extern int strcoll (const char *__s1, const char *__s2)
+//      __THROW __attribute_pure__ __nonnull ((1, 2));
+// /* Put a transformation of SRC into no more than N bytes of DEST.  */
+// extern size_t strxfrm (char *__restrict __dest,
+//                        const char *__restrict __src, size_t __n)
+//     __THROW __nonnull ((2)) __attr_access ((__write_only__, 1, 3));
+// #ifdef __USE_XOPEN2K8
+// /* POSIX.1-2008 extended locale interface (see locale.h).  */
+// // # include <bits/types/locale_t.h>
+// /* Compare the collated forms of S1 and S2, using sorting rules from L.  */
+// extern int strcoll_l (const char *__s1, const char *__s2, locale_t __l)
+//      __THROW __attribute_pure__ __nonnull ((1, 2, 3));
+// /* Put a transformation of SRC into no more than N bytes of DEST,
+//    using sorting rules from L.  */
+// extern size_t strxfrm_l (char *__dest, const char *__src, size_t __n,
+//                          locale_t __l) __THROW __nonnull ((2, 4))
+//      __attr_access ((__write_only__, 1, 3));
+// #endif
+// #if (defined __USE_XOPEN_EXTENDED || defined __USE_XOPEN2K8        \
+//      || __GLIBC_USE (LIB_EXT2) || __GLIBC_USE (ISOC2X))
+// /* Duplicate S, returning an identical malloc'd string.  */
+// extern char *strdup (const char *__s)
+//      __THROW __attribute_malloc__ __nonnull ((1));
+// #endif
+// /* Return a malloc'd copy of at most N bytes of STRING.  The
+//    resultant string is terminated even if no null terminator
+//    appears before STRING[N].  */
+// #if defined __USE_XOPEN2K8 || __GLIBC_USE (LIB_EXT2) || __GLIBC_USE (ISOC2X)
+// extern char *strndup (const char *__string, size_t __n)
+//      __THROW __attribute_malloc__ __nonnull ((1));
+// #endif
+// #if defined __USE_GNU && defined __GNUC__
+// /* Duplicate S, returning an identical alloca'd string.  */
+// # define strdupa(s)                                                              \
+//   (__extension__                                                              \
+//     ({                                                                              \
+//       const char *__old = (s);                                                      \
+//       size_t __len = strlen (__old) + 1;                                      \
+//       char *__new = (char *) __builtin_alloca (__len);                              \
+//       (char *) memcpy (__new, __old, __len);                                      \
+//     }))
+// /* Return an alloca'd copy of at most N bytes of string.  */
+// # define strndupa(s, n)                                                              \
+//   (__extension__                                                              \
+//     ({                                                                              \
+//       const char *__old = (s);                                                      \
+//       size_t __len = strnlen (__old, (n));                                      \
+//       char *__new = (char *) __builtin_alloca (__len + 1);                      \
+//       __new[__len] = '\0';                                                      \
+//       (char *) memcpy (__new, __old, __len);                                      \
+//     }))
+// #endif
+// /* Find the first occurrence of C in S.  */
+// #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
+// extern "C++"
+// {
+// extern char *strchr (char *__s, int __c)
+//      __THROW __asm ("strchr") __attribute_pure__ __nonnull ((1));
+// extern const char *strchr (const char *__s, int __c)
+//      __THROW __asm ("strchr") __attribute_pure__ __nonnull ((1));
+// # ifdef __OPTIMIZE__
+// __extern_always_inline char *
+// strchr (char *__s, int __c) __THROW
+// {
+//   return __builtin_strchr (__s, __c);
+// }
+// __extern_always_inline const char *
+// strchr (const char *__s, int __c) __THROW
+// {
+//   return __builtin_strchr (__s, __c);
+// }
+// # endif
+// }
+// #else
+// extern char *strchr (const char *__s, int __c)
+//      __THROW __attribute_pure__ __nonnull ((1));
+// #endif
+// /* Find the last occurrence of C in S.  */
+// #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
+// extern "C++"
+// {
+// extern char *strrchr (char *__s, int __c)
+//      __THROW __asm ("strrchr") __attribute_pure__ __nonnull ((1));
+// extern const char *strrchr (const char *__s, int __c)
+//      __THROW __asm ("strrchr") __attribute_pure__ __nonnull ((1));
+// # ifdef __OPTIMIZE__
+// __extern_always_inline char *
+// strrchr (char *__s, int __c) __THROW
+// {
+//   return __builtin_strrchr (__s, __c);
+// }
+// __extern_always_inline const char *
+// strrchr (const char *__s, int __c) __THROW
+// {
+//   return __builtin_strrchr (__s, __c);
+// }
+// # endif
+// }
+// #else
+// extern char *strrchr (const char *__s, int __c)
+//      __THROW __attribute_pure__ __nonnull ((1));
+// #endif
+// #ifdef __USE_GNU
+// /* This function is similar to `strchr'.  But it returns a pointer to
+//    the closing NUL byte in case C is not found in S.  */
+// # ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
+// extern "C++" char *strchrnul (char *__s, int __c)
+//      __THROW __asm ("strchrnul") __attribute_pure__ __nonnull ((1));
+// extern "C++" const char *strchrnul (const char *__s, int __c)
+//      __THROW __asm ("strchrnul") __attribute_pure__ __nonnull ((1));
+// # else
+// extern char *strchrnul (const char *__s, int __c)
+//      __THROW __attribute_pure__ __nonnull ((1));
+// # endif
+// #endif
+// /* Return the length of the initial segment of S which
+//    consists entirely of characters not in REJECT.  */
+// extern size_t strcspn (const char *__s, const char *__reject)
+//      __THROW __attribute_pure__ __nonnull ((1, 2));
+// /* Return the length of the initial segment of S which
+//    consists entirely of characters in ACCEPT.  */
+// extern size_t strspn (const char *__s, const char *__accept)
+//      __THROW __attribute_pure__ __nonnull ((1, 2));
+// /* Find the first occurrence in S of any character in ACCEPT.  */
+// #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
+// extern "C++"
+// {
+// extern char *strpbrk (char *__s, const char *__accept)
+//      __THROW __asm ("strpbrk") __attribute_pure__ __nonnull ((1, 2));
+// extern const char *strpbrk (const char *__s, const char *__accept)
+//      __THROW __asm ("strpbrk") __attribute_pure__ __nonnull ((1, 2));
+// # ifdef __OPTIMIZE__
+// __extern_always_inline char *
+// strpbrk (char *__s, const char *__accept) __THROW
+// {
+//   return __builtin_strpbrk (__s, __accept);
+// }
+// __extern_always_inline const char *
+// strpbrk (const char *__s, const char *__accept) __THROW
+// {
+//   return __builtin_strpbrk (__s, __accept);
+// }
+// # endif
+// }
+// #else
+// extern char *strpbrk (const char *__s, const char *__accept)
+//      __THROW __attribute_pure__ __nonnull ((1, 2));
+// #endif
+// /* Find the first occurrence of NEEDLE in HAYSTACK.  */
+// #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
+// extern "C++"
+// {
+// extern char *strstr (char *__haystack, const char *__needle)
+//      __THROW __asm ("strstr") __attribute_pure__ __nonnull ((1, 2));
+// extern const char *strstr (const char *__haystack, const char *__needle)
+//      __THROW __asm ("strstr") __attribute_pure__ __nonnull ((1, 2));
+// # ifdef __OPTIMIZE__
+// __extern_always_inline char *
+// strstr (char *__haystack, const char *__needle) __THROW
+// {
+//   return __builtin_strstr (__haystack, __needle);
+// }
+// __extern_always_inline const char *
+// strstr (const char *__haystack, const char *__needle) __THROW
+// {
+//   return __builtin_strstr (__haystack, __needle);
+// }
+// # endif
+// }
+// #else
+// extern char *strstr (const char *__haystack, const char *__needle)
+//      __THROW __attribute_pure__ __nonnull ((1, 2));
+// #endif
+// /* Divide S into tokens separated by characters in DELIM.  */
+// extern char *strtok (char *__restrict __s, const char *__restrict __delim)
+//      __THROW __nonnull ((2));
+// /* Divide S into tokens separated by characters in DELIM.  Information
+//    passed between calls are stored in SAVE_PTR.  */
+// extern char *__strtok_r (char *__restrict __s,
+//                          const char *__restrict __delim,
+//                          char **__restrict __save_ptr)
+//      __THROW __nonnull ((2, 3));
+// #ifdef __USE_POSIX
+// extern char *strtok_r (char *__restrict __s, const char *__restrict __delim,
+//                        char **__restrict __save_ptr)
+//      __THROW __nonnull ((2, 3));
+// #endif
+// #ifdef __USE_GNU
+// /* Similar to `strstr' but this function ignores the case of both strings.  */
+// # ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
+// extern "C++" char *strcasestr (char *__haystack, const char *__needle)
+//      __THROW __asm ("strcasestr") __attribute_pure__ __nonnull ((1, 2));
+// extern "C++" const char *strcasestr (const char *__haystack,
+//                                      const char *__needle)
+//      __THROW __asm ("strcasestr") __attribute_pure__ __nonnull ((1, 2));
+// # else
+// extern char *strcasestr (const char *__haystack, const char *__needle)
+//      __THROW __attribute_pure__ __nonnull ((1, 2));
+// # endif
+// #endif
+// #ifdef __USE_GNU
+// /* Find the first occurrence of NEEDLE in HAYSTACK.
+//    NEEDLE is NEEDLELEN bytes long;
+//    HAYSTACK is HAYSTACKLEN bytes long.  */
+// extern void *memmem (const void *__haystack, size_t __haystacklen,
+//                      const void *__needle, size_t __needlelen)
+//      __THROW __attribute_pure__ __nonnull ((1, 3))
+//     __attr_access ((__read_only__, 1, 2))
+//     __attr_access ((__read_only__, 3, 4));
+// /* Copy N bytes of SRC to DEST, return pointer to bytes after the
+//    last written byte.  */
+// extern void *__mempcpy (void *__restrict __dest,
+//                         const void *__restrict __src, size_t __n)
+//      __THROW __nonnull ((1, 2));
+// extern void *mempcpy (void *__restrict __dest,
+//                       const void *__restrict __src, size_t __n)
+//      __THROW __nonnull ((1, 2));
+// #endif
+// /* Return the length of S.  */
+// extern size_t strlen (const char *__s)
+//      __THROW __attribute_pure__ __nonnull ((1));
+// #ifdef        __USE_XOPEN2K8
+// /* Find the length of STRING, but scan at most MAXLEN characters.
+//    If no '\0' terminator is found in that many characters, return MAXLEN.  */
+// extern size_t strnlen (const char *__string, size_t __maxlen)
+//      __THROW __attribute_pure__ __nonnull ((1));
+// #endif
+// /* Return a string describing the meaning of the `errno' code in ERRNUM.  */
+// extern char *strerror (int __errnum) __THROW;
+// #ifdef __USE_XOPEN2K
+// /* Reentrant version of `strerror'.
+//    There are 2 flavors of `strerror_r', GNU which returns the string
+//    and may or may not use the supplied temporary buffer and POSIX one
+//    which fills the string into the buffer.
+//    To use the POSIX version, -D_XOPEN_SOURCE=600 or -D_POSIX_C_SOURCE=200112L
+//    without -D_GNU_SOURCE is needed, otherwise the GNU version is
+//    preferred.  */
+// # if defined __USE_XOPEN2K && !defined __USE_GNU
+// /* Fill BUF with a string describing the meaning of the `errno' code in
+//    ERRNUM.  */
+// #  ifdef __REDIRECT_NTH
+// extern int __REDIRECT_NTH (strerror_r,
+//                            (int __errnum, char *__buf, size_t __buflen),
+//                            __xpg_strerror_r) __nonnull ((2))
+//     __attr_access ((__write_only__, 2, 3));
+// #  else
+// extern int __xpg_strerror_r (int __errnum, char *__buf, size_t __buflen)
+//      __THROW __nonnull ((2)) __attr_access ((__write_only__, 2, 3));
+// #   define strerror_r __xpg_strerror_r
+// #  endif
+// # else
+// /* If a temporary buffer is required, at most BUFLEN bytes of BUF will be
+//    used.  */
+// extern char *strerror_r (int __errnum, char *__buf, size_t __buflen)
+//      __THROW __nonnull ((2)) __wur  __attr_access ((__write_only__, 2, 3));
+// # endif
+// # ifdef __USE_GNU
+// /* Return a string describing the meaning of tthe error in ERR.  */
+// extern const char *strerrordesc_np (int __err) __THROW;
+// /* Return a string with the error name in ERR.  */
+// extern const char *strerrorname_np (int __err) __THROW;
+// # endif
+// #endif
+// #ifdef __USE_XOPEN2K8
+// /* Translate error number to string according to the locale L.  */
+// extern char *strerror_l (int __errnum, locale_t __l) __THROW;
+// #endif
+// #ifdef __USE_MISC
+// // # include <strings.h>
+// /* Set N bytes of S to 0.  The compiler will not delete a call to this
+//    function, even if S is dead after the call.  */
+// extern void explicit_bzero (void *__s, size_t __n) __THROW __nonnull ((1))
+//     __fortified_attr_access (__write_only__, 1, 2);
+// /* Return the next DELIM-delimited token from *STRINGP,
+//    terminating it with a '\0', and update *STRINGP to point past it.  */
+// extern char *strsep (char **__restrict __stringp,
+//                      const char *__restrict __delim)
+//      __THROW __nonnull ((1, 2));
+// #endif
+// #ifdef        __USE_XOPEN2K8
+// /* Return a string describing the meaning of the signal number in SIG.  */
+// extern char *strsignal (int __sig) __THROW;
+// # ifdef __USE_GNU
+// /* Return an abbreviation string for the signal number SIG.  */
+// extern const char *sigabbrev_np (int __sig) __THROW;
+// /* Return a string describing the meaning of the signal number in SIG,
+//    the result is not translated.  */
+// extern const char *sigdescr_np (int __sig) __THROW;
+// # endif
+// /* Copy SRC to DEST, returning the address of the terminating '\0' in DEST.  */
+// extern char *__stpcpy (char *__restrict __dest, const char *__restrict __src)
+//      __THROW __nonnull ((1, 2));
+// extern char *stpcpy (char *__restrict __dest, const char *__restrict __src)
+//      __THROW __nonnull ((1, 2));
+// /* Copy no more than N characters of SRC to DEST, returning the address of
+//    the last character written into DEST.  */
+// extern char *__stpncpy (char *__restrict __dest,
+//                         const char *__restrict __src, size_t __n)
+//      __THROW __nonnull ((1, 2));
+// extern char *stpncpy (char *__restrict __dest,
+//                       const char *__restrict __src, size_t __n)
+//      __THROW __nonnull ((1, 2));
+// #endif
+// #ifdef        __USE_GNU
+// /* Compare S1 and S2 as strings holding name & indices/version numbers.  */
+// extern int strverscmp (const char *__s1, const char *__s2)
+//      __THROW __attribute_pure__ __nonnull ((1, 2));
+// /* Sautee STRING briskly.  */
+// extern char *strfry (char *__string) __THROW __nonnull ((1));
+// /* Frobnicate N bytes of S.  */
+// extern void *memfrob (void *__s, size_t __n) __THROW __nonnull ((1))
+//     __attr_access ((__read_write__, 1, 2));
+// # ifndef basename
+// /* Return the file name within directory of FILENAME.  We don't
+//    declare the function if the `basename' macro is available (defined
+//    in <libgen.h>) which makes the XPG version of this function
+//    available.  */
+// #  ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
+// extern "C++" char *basename (char *__filename)
+//      __THROW __asm ("basename") __nonnull ((1));
+// extern "C++" const char *basename (const char *__filename)
+//      __THROW __asm ("basename") __nonnull ((1));
+// #  else
+// extern char *basename (const char *__filename) __THROW __nonnull ((1));
+// #  endif
+// # endif
+// #endif
+// #if __GNUC_PREREQ (3,4)
+// # if __USE_FORTIFY_LEVEL > 0 && defined __fortify_function
+// /* Functions with security checks.  */
+// #  include <bits/string_fortified.h>
+// # endif
+// __END_DECLS
 
 #endif
\ No newline at end of file
diff --git a/lib/include/machine/endian.h b/lib/include/machine/endian.h
index ddb8ce1..a45542f 100644
--- a/lib/include/machine/endian.h
+++ b/lib/include/machine/endian.h
@@ -84,6 +84,6 @@
 #endif
 #define __STRICT_ALIGNMENT
 #include <sys/types.h>
-#include <sys/endian.h>
+// #include <sys/endian.h>
 
 #endif  /* !_ARM_ENDIAN_H_ */
\ No newline at end of file
diff --git a/lib/include/stdio.h b/lib/include/stdio.h
new file mode 100644
index 0000000..e8b8947
--- /dev/null
+++ b/lib/include/stdio.h
@@ -0,0 +1,439 @@
+/*	$OpenBSD: stdio.h,v 1.55 2022/01/05 20:57:27 millert Exp $	*/
+/*	$NetBSD: stdio.h,v 1.18 1996/04/25 18:29:21 jtc Exp $	*/
+
+/*-
+ * Copyright (c) 1990 The Regents of the University of California.
+ * All rights reserved.
+ *
+ * This code is derived from software contributed to Berkeley by
+ * Chris Torek.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	@(#)stdio.h	5.17 (Berkeley) 6/3/91
+ */
+
+#ifndef	_STDIO_H_
+#define	_STDIO_H_
+
+#include <sys/cdefs.h>
+#include <sys/_null.h>
+#include <sys/_types.h>
+
+#if __BSD_VISIBLE || __POSIX_VISIBLE || __XPG_VISIBLE
+#include <sys/types.h>	/* XXX should be removed */
+#endif
+
+#ifndef	_SIZE_T_DEFINED_
+#define	_SIZE_T_DEFINED_
+typedef	__size_t	size_t;
+#endif
+
+#ifndef	_OFF_T_DEFINED_
+#define	_OFF_T_DEFINED_
+typedef	__off_t	off_t;
+#endif
+
+#define	_FSTDIO			/* Define for new stdio with functions. */
+
+typedef off_t fpos_t;		/* stdio file position type */
+
+/*
+ * NB: to fit things in six character monocase externals, the stdio
+ * code uses the prefix `__s' for stdio objects, typically followed
+ * by a three-character attempt at a mnemonic.
+ */
+
+/* stdio buffers */
+struct __sbuf {
+	unsigned char *_base;
+	int	_size;
+};
+
+/*
+ * stdio state variables.
+ *
+ * The following always hold:
+ *
+ *	if (_flags&(__SLBF|__SWR)) == (__SLBF|__SWR),
+ *		_lbfsize is -_bf._size, else _lbfsize is 0
+ *	if _flags&__SRD, _w is 0
+ *	if _flags&__SWR, _r is 0
+ *
+ * This ensures that the getc and putc macros (or inline functions) never
+ * try to write or read from a file that is in `read' or `write' mode.
+ * (Moreover, they can, and do, automatically switch from read mode to
+ * write mode, and back, on "r+" and "w+" files.)
+ *
+ * _lbfsize is used only to make the inline line-buffered output stream
+ * code as compact as possible.
+ *
+ * _ub, _up, and _ur are used when ungetc() pushes back more characters
+ * than fit in the current _bf, or when ungetc() pushes back a character
+ * that does not match the previous one in _bf.  When this happens,
+ * _ub._base becomes non-nil (i.e., a stream has ungetc() data iff
+ * _ub._base!=NULL) and _up and _ur save the current values of _p and _r.
+ */
+typedef	struct __sFILE {
+	unsigned char *_p;	/* current position in (some) buffer */
+	int	_r;		/* read space left for getc() */
+	int	_w;		/* write space left for putc() */
+	short	_flags;		/* flags, below; this FILE is free if 0 */
+	short	_file;		/* fileno, if Unix descriptor, else -1 */
+	struct	__sbuf _bf;	/* the buffer (at least 1 byte, if !NULL) */
+	int	_lbfsize;	/* 0 or -_bf._size, for inline putc */
+
+	/* operations */
+	void	*_cookie;	/* cookie passed to io functions */
+	int	(*_close)(void *);
+	int	(*_read)(void *, char *, int);
+	fpos_t	(*_seek)(void *, fpos_t, int);
+	int	(*_write)(void *, const char *, int);
+
+	/* extension data, to avoid further ABI breakage */
+	struct	__sbuf _ext;
+	/* data for long sequences of ungetc() */
+	unsigned char *_up;	/* saved _p when _p is doing ungetc data */
+	int	_ur;		/* saved _r when _r is counting ungetc data */
+
+	/* tricks to meet minimum requirements even when malloc() fails */
+	unsigned char _ubuf[3];	/* guarantee an ungetc() buffer */
+	unsigned char _nbuf[1];	/* guarantee a getc() buffer */
+
+	/* separate buffer for fgetln() when line crosses buffer boundary */
+	struct	__sbuf _lb;	/* buffer for fgetln() */
+
+	/* Unix stdio files get aligned to block boundaries on fseek() */
+	int	_blksize;	/* stat.st_blksize (may be != _bf._size) */
+	fpos_t	_offset;	/* current lseek offset */
+} FILE;
+
+__BEGIN_DECLS
+extern FILE __sF[];
+__END_DECLS
+
+#define	__SLBF	0x0001		/* line buffered */
+#define	__SNBF	0x0002		/* unbuffered */
+#define	__SRD	0x0004		/* OK to read */
+#define	__SWR	0x0008		/* OK to write */
+	/* RD and WR are never simultaneously asserted */
+#define	__SRW	0x0010		/* open for reading & writing */
+#define	__SEOF	0x0020		/* found EOF */
+#define	__SERR	0x0040		/* found error */
+#define	__SMBF	0x0080		/* _buf is from malloc */
+#define	__SAPP	0x0100		/* fdopen()ed in append mode */
+#define	__SSTR	0x0200		/* this is an sprintf/snprintf string */
+#define	__SOPT	0x0400		/* do fseek() optimisation */
+#define	__SNPT	0x0800		/* do not do fseek() optimisation */
+#define	__SOFF	0x1000		/* set iff _offset is in fact correct */
+#define	__SMOD	0x2000		/* true => fgetln modified _p text */
+#define	__SALC	0x4000		/* allocate string space dynamically */
+#define __SIGN	0x8000		/* ignore this file in _fwalk */
+
+/*
+ * The following three definitions are for ANSI C, which took them
+ * from System V, which brilliantly took internal interface macros and
+ * made them official arguments to setvbuf(), without renaming them.
+ * Hence, these ugly _IOxxx names are *supposed* to appear in user code.
+ *
+ * Although numbered as their counterparts above, the implementation
+ * does not rely on this.
+ */
+#define	_IOFBF	0		/* setvbuf should set fully buffered */
+#define	_IOLBF	1		/* setvbuf should set line buffered */
+#define	_IONBF	2		/* setvbuf should set unbuffered */
+
+#define	BUFSIZ	1024		/* size of buffer used by setbuf */
+
+#define	EOF	(-1)
+
+/*
+ * FOPEN_MAX is a minimum maximum, and should be the number of descriptors
+ * that the kernel can provide without allocation of a resource that can
+ * fail without the process sleeping.  Do not use this for anything.
+ */
+#define	FOPEN_MAX	20	/* must be <= OPEN_MAX <sys/syslimits.h> */
+#define	FILENAME_MAX	1024	/* must be <= PATH_MAX <sys/syslimits.h> */
+
+/* System V/ANSI C; this is the wrong way to do this, do *not* use these. */
+#if __BSD_VISIBLE || __XPG_VISIBLE
+#define	P_tmpdir	"/tmp/"
+#endif
+#define	L_tmpnam	1024	/* XXX must be == PATH_MAX */
+#define	TMP_MAX		0x7fffffff	/* more, but don't overflow int */
+
+#ifndef SEEK_SET
+#define	SEEK_SET	0	/* set file offset to offset */
+#endif
+#ifndef SEEK_CUR
+#define	SEEK_CUR	1	/* set file offset to current plus offset */
+#endif
+#ifndef SEEK_END
+#define	SEEK_END	2	/* set file offset to EOF plus offset */
+#endif
+
+#define	stdin	(&__sF[0])
+#define	stdout	(&__sF[1])
+#define	stderr	(&__sF[2])
+
+/*
+ * Functions defined in ANSI C standard.
+ */
+__BEGIN_DECLS
+void	 clearerr(FILE *);
+#if __POSIX_VISIBLE >= 200809
+int	 dprintf(int, const char * __restrict, ...)
+		__attribute__((__format__ (printf, 2, 3)))
+		__attribute__((__nonnull__ (2)));
+#endif
+int	 fclose(FILE *);
+int	 feof(FILE *);
+int	 ferror(FILE *);
+int	 fflush(FILE *);
+int	 fgetc(FILE *);
+int	 fgetpos(FILE *, fpos_t *);
+char	*fgets(char *, int, FILE *)
+		__attribute__((__bounded__ (__string__,1,2)));
+FILE	*fopen(const char *, const char *);
+int	 fprintf(FILE *, const char *, ...);
+int	 fputc(int, FILE *);
+int	 fputs(const char *, FILE *);
+size_t	 fread(void *, size_t, size_t, FILE *)
+		__attribute__((__bounded__ (__size__,1,3,2)));
+FILE	*freopen(const char *, const char *, FILE *);
+int	 fscanf(FILE *, const char *, ...);
+int	 fseek(FILE *, long, int);
+int	 fseeko(FILE *, off_t, int);
+int	 fsetpos(FILE *, const fpos_t *);
+long	 ftell(FILE *);
+off_t	 ftello(FILE *);
+size_t	 fwrite(const void *, size_t, size_t, FILE *)
+		__attribute__((__bounded__ (__size__,1,3,2)));
+int	 getc(FILE *);
+int	 getchar(void);
+#if __POSIX_VISIBLE >= 200809
+ssize_t	 getdelim(char ** __restrict, size_t * __restrict, int,
+	    FILE * __restrict);
+ssize_t	 getline(char ** __restrict, size_t * __restrict,
+	    FILE * __restrict);
+#endif
+#if __BSD_VISIBLE && !defined(__SYS_ERRLIST)
+#define __SYS_ERRLIST
+
+extern int sys_nerr;			/* perror(3) external variables */
+extern char *sys_errlist[];
+#endif
+void	 perror(const char *);
+int	 printf(const char *, ...);
+int	 putc(int, FILE *);
+int	 putchar(int);
+int	 puts(const char *);
+int	 remove(const char *);
+int	 rename(const char *, const char *);
+#if __POSIX_VISIBLE >= 200809
+int	 renameat(int, const char *, int, const char *);
+#endif
+void	 rewind(FILE *);
+int	 scanf(const char *, ...);
+void	 setbuf(FILE *, char *);
+int	 setvbuf(FILE *, char *, int, size_t);
+int	 sprintf(char *, const char *, ...);
+int	 sscanf(const char *, const char *, ...);
+FILE	*tmpfile(void);
+char	*tmpnam(char *);
+int	 ungetc(int, FILE *);
+int	 vfprintf(FILE *, const char *, __va_list);
+int	 vprintf(const char *, __va_list);
+int	 vsprintf(char *, const char *, __va_list);
+#if __POSIX_VISIBLE >= 200809
+int	 vdprintf(int, const char * __restrict, __va_list)
+		__attribute__((__format__ (printf, 2, 0)))
+		__attribute__((__nonnull__ (2)));
+#endif
+
+#if __ISO_C_VISIBLE >= 1999 || __XPG_VISIBLE >= 500 || __BSD_VISIBLE
+int	 snprintf(char *, size_t, const char *, ...)
+		__attribute__((__format__ (printf, 3, 4)))
+		__attribute__((__nonnull__ (3)))
+		__attribute__((__bounded__ (__string__,1,2)));
+int	 vsnprintf(char *, size_t, const char *, __va_list)
+		__attribute__((__format__ (printf, 3, 0)))
+		__attribute__((__nonnull__ (3)))
+		__attribute__((__bounded__(__string__,1,2)));
+#endif /* __ISO_C_VISIBLE >= 1999 || __XPG_VISIBLE >= 500 || __BSD_VISIBLE */
+
+#if __ISO_C_VISIBLE >= 1999 || __BSD_VISIBLE
+int	 vfscanf(FILE *, const char *, __va_list)
+		__attribute__((__format__ (scanf, 2, 0)))
+		__attribute__((__nonnull__ (2)));
+int	 vscanf(const char *, __va_list)
+		__attribute__((__format__ (scanf, 1, 0)))
+		__attribute__((__nonnull__ (1)));
+int	 vsscanf(const char *, const char *, __va_list)
+		__attribute__((__format__ (scanf, 2, 0)))
+		__attribute__((__nonnull__ (2)));
+#endif /* __ISO_C_VISIBLE >= 1999 || __BSD_VISIBLE */
+
+__END_DECLS
+
+
+/*
+ * Functions defined in POSIX 1003.1.
+ */
+#if __BSD_VISIBLE || __POSIX_VISIBLE || __XPG_VISIBLE
+#define	L_ctermid	1024	/* size for ctermid(); PATH_MAX */
+
+__BEGIN_DECLS
+char	*ctermid(char *);
+FILE	*fdopen(int, const char *);
+int	 fileno(FILE *);
+
+#if __POSIX_VISIBLE >= 199209
+int	 pclose(FILE *);
+FILE	*popen(const char *, const char *);
+#endif
+
+#if __POSIX_VISIBLE >= 199506
+void	 flockfile(FILE *);
+int	 ftrylockfile(FILE *);
+void	 funlockfile(FILE *);
+
+/*
+ * These are normally used through macros as defined below, but POSIX
+ * requires functions as well.
+ */
+int	 getc_unlocked(FILE *);
+int	 getchar_unlocked(void);
+int	 putc_unlocked(int, FILE *);
+int	 putchar_unlocked(int);
+#endif /* __POSIX_VISIBLE >= 199506 */
+
+#if __POSIX_VISIBLE >= 200809
+FILE	*fmemopen(void *, size_t, const char *);
+FILE	*open_memstream(char **, size_t *);
+#endif /* __POSIX_VISIBLE >= 200809 */
+
+#if __XPG_VISIBLE
+char	*tempnam(const char *, const char *);
+#endif
+__END_DECLS
+
+#endif /* __BSD_VISIBLE || __POSIX_VISIBLE || __XPG_VISIBLE */
+
+/*
+ * Routines that are purely local.
+ */
+#if __BSD_VISIBLE
+__BEGIN_DECLS
+int	 asprintf(char **, const char *, ...)
+		__attribute__((__format__ (printf, 2, 3)))
+		__attribute__((__nonnull__ (2)));
+char	*fgetln(FILE *, size_t *);
+int	 fpurge(FILE *);
+int	 getw(FILE *);
+int	 putw(int, FILE *);
+void	 setbuffer(FILE *, char *, int);
+int	 setlinebuf(FILE *);
+int	 vasprintf(char **, const char *, __va_list)
+		__attribute__((__format__ (printf, 2, 0)))
+		__attribute__((__nonnull__ (2)));
+__END_DECLS
+
+/*
+ * Stdio function-access interface.
+ */
+__BEGIN_DECLS
+FILE	*funopen(const void *,
+		int (*)(void *, char *, int),
+		int (*)(void *, const char *, int),
+		off_t (*)(void *, off_t, int),
+		int (*)(void *));
+__END_DECLS
+#define	fropen(cookie, fn) funopen(cookie, fn, 0, 0, 0)
+#define	fwopen(cookie, fn) funopen(cookie, 0, fn, 0, 0)
+#endif /* __BSD_VISIBLE */
+
+/*
+ * Functions internal to the implementation.
+ */
+__BEGIN_DECLS
+int	__srget(FILE *);
+int	__swbuf(int, FILE *);
+__END_DECLS
+
+/*
+ * The __sfoo macros are here so that we can 
+ * define function versions in the C library.
+ */
+#define	__sgetc(p) (--(p)->_r < 0 ? __srget(p) : (int)(*(p)->_p++))
+static __inline int __sputc(int _c, FILE *_p) {
+	if (--_p->_w >= 0 || (_p->_w >= _p->_lbfsize && (char)_c != '\n'))
+		return (*_p->_p++ = _c);
+	else
+		return (__swbuf(_c, _p));
+}
+
+#define	__sfeof(p)	(((p)->_flags & __SEOF) != 0)
+#define	__sferror(p)	(((p)->_flags & __SERR) != 0)
+#define	__sclearerr(p)	((void)((p)->_flags &= ~(__SERR|__SEOF)))
+#define	__sfileno(p)	((p)->_file)
+
+extern int __isthreaded;
+
+#define feof(p)		(!__isthreaded ? __sfeof(p) : (feof)(p))
+#define ferror(p)	(!__isthreaded ? __sferror(p) : (ferror)(p))
+#define clearerr(p)	(!__isthreaded ? __sclearerr(p) : (clearerr)(p))
+
+#if __POSIX_VISIBLE
+#define fileno(p)	(!__isthreaded ? __sfileno(p) : (fileno)(p))
+#endif
+
+#define getc(fp)	(!__isthreaded ? __sgetc(fp) : (getc)(fp))
+
+#if __BSD_VISIBLE
+/*
+ * The macro implementations of putc and putc_unlocked are not
+ * fully POSIX compliant; they do not set errno on failure
+ */
+#define putc(x, fp)	(!__isthreaded ? __sputc(x, fp) : (putc)(x, fp))
+#endif /* __BSD_VISIBLE */
+
+#if __POSIX_VISIBLE >= 199506
+#define	getc_unlocked(fp)	__sgetc(fp)
+/*
+ * The macro implementations of putc and putc_unlocked are not
+ * fully POSIX compliant; they do not set errno on failure
+ */
+#if __BSD_VISIBLE
+#define putc_unlocked(x, fp)	__sputc(x, fp)
+#endif /* __BSD_VISIBLE */
+#endif /* __POSIX_VISIBLE >= 199506 */
+
+#define	getchar()	getc(stdin)
+#define	putchar(x)	putc(x, stdout)
+#define getchar_unlocked()	getc_unlocked(stdin)
+#define putchar_unlocked(c)	putc_unlocked(c, stdout)
+
+#endif /* _STDIO_H_ */
\ No newline at end of file
diff --git a/lib/include/string.h b/lib/include/string.h
index a38c44d..24c26cb 100644
--- a/lib/include/string.h
+++ b/lib/include/string.h
@@ -7,7 +7,7 @@
 #endif
 
 #ifndef size_t_defined
-typedef unsigned int size_t; // Define size_t if it's not already defined
+// typedef unsigned int size_t; // Define size_t if it's not already defined
 #endif
 
 #if !defined(_SIZE_T) && !defined(_SIZE_T_DEFINED)
diff --git a/lib/include/sys/_types.h b/lib/include/sys/_types.h
index 843f4d5..01fe5de 100644
--- a/lib/include/sys/_types.h
+++ b/lib/include/sys/_types.h
@@ -39,7 +39,7 @@
 typedef __int64_t	__blkcnt_t;	/* blocks allocated for file */
 typedef __int32_t	__blksize_t;	/* optimal blocksize for I/O */
 #ifndef  __clock_t_defined
-typedef	__int64_t	__clock_t;	/* ticks in CLOCKS_PER_SEC */
+// typedef	__int64_t	__clock_t;	/* ticks in CLOCKS_PER_SEC */
 #endif
 typedef	__int32_t	__clockid_t;	/* CLOCK_* identifiers */
 typedef	unsigned long	__cpuid_t;	/* CPU id */
@@ -62,7 +62,7 @@ typedef	__uint8_t	__sa_family_t;	/* sockaddr address family type */
 typedef	__int32_t	__segsz_t;	/* segment size */
 typedef	__uint32_t	__socklen_t;	/* length type for network syscalls */
 typedef	long		__suseconds_t;	/* microseconds (signed) */
-typedef	__int64_t	__time_t;	/* epoch time */
+// typedef	__int64_t	__time_t;	/* epoch time */
 typedef	__int32_t	__timer_t;	/* POSIX timer identifiers */
 typedef	__uint32_t	__uid_t;	/* user id */
 typedef	__uint32_t	__useconds_t;	/* microseconds */
diff --git a/lib/include/sys/types.h b/lib/include/sys/types.h
index d584959..884f247 100644
--- a/lib/include/sys/types.h
+++ b/lib/include/sys/types.h
@@ -44,7 +44,7 @@
 
 #include <sys/cdefs.h>
 #if __BSD_VISIBLE
-#include <sys/endian.h>
+// #include <sys/endian.h>
 #else
 #include <sys/_endian.h>
 #endif
diff --git a/lib/include/types.h b/lib/include/types.h
index 821e497..e45ff28 100644
--- a/lib/include/types.h
+++ b/lib/include/types.h
@@ -2,7 +2,7 @@
 #define __CACTUSOSLIB__TYPES_H
 
 
-
+#ifdef __cplusplus
 namespace LIBHeisenKernel
 {
     #define STATIC_ASSERT(condition) typedef char p__LINE__[ (condition) ? 1 : -1];
@@ -36,6 +36,23 @@ namespace LIBHeisenKernel
     }
 }
 
+#else 
+// typedef char                        int8_t;
+typedef unsigned char               uint8_t;
+typedef short                       int16_t;
+typedef unsigned short              uint16_t;
+typedef int                         int32_t;
+typedef unsigned int                uint32_t;
+typedef long long int               int64_t;
+typedef unsigned long long int      uint64_t;
+// typedef unsigned long long          uintptr_t;
+// typedef uint32_t size_t; 
+typedef unsigned char byte_t;
+typedef unsigned int dword_t;
+typedef long unsigned int word_t;
+
+#endif
+
 // extern "C"{
 
 //     typedef char                        int8_t;
diff --git a/libdrive/include/libusbserial.h b/libdrive/include/libusbserial.h
index 9077145..cc4dcf7 100644
--- a/libdrive/include/libusbserial.h
+++ b/libdrive/include/libusbserial.h
@@ -43,7 +43,7 @@ struct usbserial_config{
 
 /* Returns a nonzero value, if a USB device is supported by one
  * of the libusbserial drivers. */
-int usbserial_is_device_supported(uint16_t vid, uint16_t pid, uint8_t classs, uint8_t subclass);
+int usbserial_is_device_supported(uint16_t vid, uint16_t pid, uint8_t class, uint8_t subclass);
 /* Get a short device name. It is guaranteed to return a valid C
  * string (not NULL), if the device is supported, see
  * usbserial_is_device_supported(). Otherwise, the results are
diff --git a/libdrive/include/libusbtypes.h b/libdrive/include/libusbtypes.h
index 3b740c0..8714d88 100644
--- a/libdrive/include/libusbtypes.h
+++ b/libdrive/include/libusbtypes.h
@@ -1,7 +1,7 @@
 #ifndef _HEISEN_KERNEL_USB_TYPES_H
 #define _HEISEN_KERNEL_USB_TYPES_H
 
-typedef char                        int8_t;
+// typedef char                        int8_t;
 typedef unsigned char               uint8_t;
 typedef short                       int16_t;
 typedef unsigned short              uint16_t;
@@ -9,10 +9,8 @@ typedef int                         int32_t;
 typedef unsigned int                uint32_t;
 typedef long long int               int64_t;
 typedef unsigned long long int      uint64_t;
-typedef unsigned long long          uintptr_t;
+// typedef unsigned long long          uintptr_t;
 #if !defined(__cplusplus)
-#define false 0
-#define true 1
 typedef enum { false = 0, true = 1 } bool;
 #endif
 
-- 
2.43.0

